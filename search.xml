<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2017年阅读小结</title>
    <url>/p/c39637d5.html</url>
    <content><![CDATA[<p>整理下2017年的学习资料，总体目标还是只记录有所收获的那一部分，今年的学习方向主要是历史、哲学，在这方面给个人带来更多的思考方向、扩大思想范围；与以往不同的是，在接触时，对自己想了解什么和对方在表达什么保持思考；</p>
<a id="more"></a>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http权威指南</span><br><span class="line">走出软件作坊</span><br><span class="line">公司的概念</span><br><span class="line">卓有成效的管理者</span><br><span class="line">七年就是一辈子</span><br></pre></td></tr></table></figure>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">潜规则：中国历史中的真实游戏</span><br><span class="line">统一与分裂</span><br><span class="line">明朝那些事儿</span><br><span class="line">剑桥中国史-秦汉史</span><br><span class="line">中国近代史</span><br><span class="line">中国国民性演变历程</span><br><span class="line">留学的仕途</span><br><span class="line">宅兹中国：重建有关中国的历史论述</span><br><span class="line">唐朝穿越指南长安及各地人民生活手册</span><br><span class="line">罗马帝国衰亡史</span><br><span class="line">全球通史上</span><br></pre></td></tr></table></figure>
<h2 id="心理"><a href="#心理" class="headerlink" title="心理"></a>心理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">沐猴而冠：文化如何塑造人性</span><br><span class="line">社会心理学</span><br><span class="line">童话的魅力</span><br><span class="line">乌合之众</span><br></pre></td></tr></table></figure>
<h2 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">哲学九讲</span><br><span class="line">苏菲的世界</span><br><span class="line">第一本哲学书</span><br><span class="line">西方哲学史</span><br><span class="line">论证是一门学问</span><br><span class="line">看自己</span><br><span class="line">通往奴役之路</span><br><span class="line">逃避自由</span><br><span class="line">1984</span><br><span class="line">批判性思维</span><br><span class="line">学会提问-批判性思维指南</span><br><span class="line">道可道：《老子》的要义与诘难</span><br></pre></td></tr></table></figure>
<h2 id="传记"><a href="#传记" class="headerlink" title="传记"></a>传记</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们台湾那些年</span><br><span class="line">李鸿章传</span><br></pre></td></tr></table></figure>
<h2 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h2><p><code>时间简史</code></p>
<h2 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">论人的天性</span><br><span class="line">民主的细节</span><br><span class="line">枪炮，病菌与钢铁</span><br></pre></td></tr></table></figure>
<h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><h3 id="漫画动漫"><a href="#漫画动漫" class="headerlink" title="漫画动漫"></a>漫画动漫</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">铃音</span><br><span class="line">白色相簿2</span><br><span class="line">四叠半神话大系</span><br><span class="line">来自新世界</span><br><span class="line">布拉德哈利的马车</span><br><span class="line">恶魔人Crybody</span><br><span class="line">JOJO奇妙冒险 战斗潮流</span><br><span class="line">JOJO奇妙冒险 钻石斗士</span><br><span class="line">JOJO奇妙冒险 不灭星辰</span><br><span class="line">玛莉的音乐盒</span><br><span class="line">RWBY1234</span><br><span class="line">一人之下</span><br><span class="line">黑博物馆</span><br><span class="line">巴哈姆特之怒</span><br><span class="line">Adventure Time with Finn and Jake （探险时光）</span><br><span class="line">化物语—铁血篇</span><br><span class="line">Rick and Morty（瑞克和莫蒂）</span><br><span class="line">银河铁道999</span><br><span class="line">銃夢</span><br></pre></td></tr></table></figure>
<h3 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">亦恕與珂雪</span><br><span class="line">夜玫瑰</span><br><span class="line">爱尔兰咖啡</span><br><span class="line">雨衣</span><br><span class="line">第一次亲密接触</span><br><span class="line">我的老婆是公主</span><br><span class="line">永恒的终结</span><br><span class="line">修真四万年</span><br><span class="line">北京折叠</span><br><span class="line">奥术神座</span><br><span class="line">九州缥缈录</span><br><span class="line">死人经</span><br></pre></td></tr></table></figure>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">艾迪芬奇的记忆</span><br><span class="line">辐射3&#x2F;新维加斯</span><br><span class="line">elona plus</span><br><span class="line">黑暗之魂</span><br></pre></td></tr></table></figure>
<h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">霹雳侠影-轰动武林</span><br><span class="line">霹雳侠影-轰定干戈</span><br><span class="line">霹雳侠影-轰掣天下</span><br><span class="line">天地风云录-九龙变</span><br><span class="line">天地风云录-魔戮血战</span><br><span class="line">天地风云录-剑影魔踪</span><br><span class="line">金光御九界之墨武侠锋</span><br><span class="line">权利的游戏-冰与火之歌7</span><br><span class="line">至爱梵高</span><br><span class="line">大护法</span><br><span class="line">铁拳男人</span><br><span class="line">摔跤吧爸爸</span><br><span class="line">你的名字</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年终总结</title>
    <url>/p/4a3ebfa8.html</url>
    <content><![CDATA[<p>2018年也是带来很大成长的一年，在此记录下一年成就和感悟。</p>
<p><strong>关键字：人文、职业、爱好</strong></p>
<p>2018年底博客累计突破100篇，达成里程碑！</p>
<h2 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h2><p>进入深水区</p>
<p>在刚开始工作的1～2年，遇到的问题在掌握科学上网后通过google、github、stackoverflow基本就稳了，接触都RSS后建立自己的网络信息入口后每天下班看看blog就学习进步很多，但2018年明显进去“深水区”，区别有三点：</p>
<p><strong>一：问题变复杂和模糊</strong></p>
<p>问题不再单一，不再是技巧性问题。</p>
<p><strong>二：未知领域增多</strong></p>
<p><strong>三：新知识点变“大”了</strong></p>
<p>主要还是iOS开发，但今天在技术实现上基本已经得心应手，开始大范围扩展底层原理，在初期惊异底层的广泛，运行时、网络、图形图像、渲染原理、字体富文本等领域都是需要花费时间琢磨的知识，但也是必须要研究的知识，现在在工作中如果还需要继续提升的话，那么底层领域的知识块就需要啃下来，还需要建立知识结构否则大量的知识点之间的联系就让人晕头转向了；</p>
<p>明显的差异就在于过去工作中的问题google一下基本就OK了，现在的问题可能只能在网络上查到解决方向，需要自己回归文档、研究原理、定制化对应的实现，有种小鱼吃点虾米就饱了，但长成大鱼后饿肚子就需要吃上整个鱼群才能填饱肚子。</p>
<p>另外2018年扩展了Swift技术栈、在公司中推行了MVVM、和基于CocoaPods的私人组件化，接下来推动公司开发Swift化。</p>
<p>音视频技术只入门了图形图像，现阶段基本熟悉OpenGLES的开发操作，用Swift写了些OpenGLES的demoJDOpenGLES_Swift，因为网络上Swift的OpenGLES demo很少，可能是都用metal写了吧，但metal没有开关，入门还是选择了GLES资料更多，对于图像渲染原理有更好的理解。</p>
<h2 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h2><p>主要是优化过去的工作记录和推动方式，2018年主要还是在方法论上下功夫，在接触一些管理学上的理论后，对于工作管理有很大改观，有些事情真不是一个人埋头干能解决的，现在个人管理模型是 计划-执行-记录-总结</p>
<h2 id="数理"><a href="#数理" class="headerlink" title="数理"></a>数理</h2><p>2018年在研究计算机原理、图形图像学就感觉到数理知识真的很重要，一方面开始复习高等数学、另一方面是在leetCode上刷题，首先在接触了数学史后对数学有不一样的看法，过去数学成绩还行，但也谈不上喜欢，感觉公式很多时候都是死记硬背，但在接触数学史后发现数学也是曲折发展的，很多时候都是先用再补充定理，这就导致了两个问题，一：推导出来的定理可能比前置定理先出现；二：定理啰嗦的作用域定义；</p>
<p>现在看来数学还是很有趣的。</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>2018年还是看了不少好作品：2018阅览记录，在书、电影、动漫、漫画、游戏领域都有值得多次体验的艺术品，我只记录个人认为能够体验两次以上的作品，相较2017年的阅读类型，今年的阅读更多是以题材为出发点，主要是人文哲学和心理，对社会人文的认知扩展了不少，作品中大多蕴含强烈的矛盾和精神主旨，但同时也导致了精神上的消化不良，扩大的世界观导致我在精神上很难消化，直接影响生活中的行动指向，扩展了事物的多面性后，精神主体的主动性不足导致对事物选择无从下手，生活明显有悲观、消极倾向，还好及时注意到问题，通过回归生活，控制外部思想入口，建立自主思考体系进行消化和过滤，这才消停下来。</p>
<h2 id="body"><a href="#body" class="headerlink" title="body"></a>body</h2><p>健身锻炼从2016年就坚持到现在，虽然肌肉没练出来但身体基本没什么毛病，但也感觉到没有再进一步的动力，在2018年12月报了剑道练习开始剑士修炼，打磨下自己的胜负心，培养对抗意识。</p>
<h2 id="爱好：烹饪"><a href="#爱好：烹饪" class="headerlink" title="爱好：烹饪"></a>爱好：烹饪</h2><p>爱好是生活的调味料。</p>
<p>周末我基本会自己做饭，今年的一大突破是清蒸鱼、红烧鱼、炒青菜技术达标，通过某位嘴刁的大佬认证，</p>
<p>家庭主夫力up！</p>
<h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><p>目标：</p>
<p>图形图像进阶，实现自定义滤镜，发布博客<br>扩展计算机底层原理，在博客中发布文件说明程序编译运行原理<br>推广 Swift 程序开发和实现，实现新项目 Swift 开发<br>每周至少完成3道算法训练<br>精读，只有自己的情况下，作品看完不写读后感不能看下一部作品<br>英文原著阅读5部</p>
]]></content>
      <categories>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>2018计划：个人成长规划</title>
    <url>/p/aa896fbc.html</url>
    <content><![CDATA[<p>在2017年，自身在技术上的成长，主要是iOS的应用开发，在界面构建、功能实现上有了更成熟的发展，但同时也感受到应用开发的瓶颈，在新的一年中，我准备调整成长方向，主要有4个方面。</p>
<a id="more"></a>

<ul>
<li>iOS底层技术提升</li>
<li>音视频技术学习</li>
<li>工程管理知识</li>
<li>数理抽象能力</li>
</ul>
<h2 id="第一点：iOS底层技术提升"><a href="#第一点：iOS底层技术提升" class="headerlink" title="第一点：iOS底层技术提升"></a>第一点：iOS底层技术提升</h2><p>在应用开发层次，更多追求的是实现、结果、效率而不是底层实现原理，在多线程、动画、网络等功能下有着复杂的底层设计原理，接下来，不止知其然，还要知要知其然，要讲得出，说得来。</p>
<p>Apple的官方文档是最全面最权威的原理说明，结合技术blog的说明、通过demo的表现来强化认知、再写技术文章来总结，以遇到问题、思考问题、解决问题、总结问题的步骤来强化反馈，形成良好循环。</p>
<p>目标：保持每周总结一篇技术文章</p>
<h2 id="第二点：音视频技术"><a href="#第二点：音视频技术" class="headerlink" title="第二点：音视频技术"></a>第二点：音视频技术</h2><p>音视频技术是同时具备深度与广度的技术，在数理、架构、应用上都有很多技术相关，一方面是对音视频技术有兴趣，同时也是认为音视频技术在接下来的一段时间会有很多应用场景。但音视频技术涉及的理论和应用真的很多，硬件、软件、数理、网络等都有相关，我的学习路线定为两个方面：广和深。</p>
<p>广：在音视频的应用架构设计的技术进行泛读、形成大概的体系</p>
<p>深：专注音视频编码实现</p>
<p>目标：实现H.264视频编解码器</p>
<h2 id="第三点：工程管理知识"><a href="#第三点：工程管理知识" class="headerlink" title="第三点：工程管理知识"></a>第三点：工程管理知识</h2><p>在开发的过程中，如何提高效率、减少错误、这是个工程管理问题，一方面，在代码架构上是否可以选择组件化、RAC等其它架构？另一方面，在开发过程中能否用更高效的管理方法？敏捷开发、极限开发等开发方式是否有借鉴地方？持续集成与单元/自动测试？</p>
<p>工程管理技术的可以在网络上找到大量资料，问题是实现与推行，新方法是否合适、如何推行、怎么过度，需要在工程开发中不断反思、交流和调整。</p>
<h2 id="第四点-数理抽象能力"><a href="#第四点-数理抽象能力" class="headerlink" title="第四点:数理抽象能力"></a>第四点:数理抽象能力</h2><p>数理训练，现阶段指数据结构和算法，以前算法在印象中是计算力的问题，现在看是抽象力的问题。算法的锻炼没有捷径，只能是去刷题，可以从经典算法教程中锻炼，也可以在网络平台如leetcode上练习。</p>
<p>目标:保持每天半个小时的训练。</p>
<p>目标很困难，都不是好啃的问题，目标也容易，只要能做好今天就行了。</p>
]]></content>
      <categories>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年终总结</title>
    <url>/p/845ca7c4.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>A man chooses,A slave obeys -- 生化奇兵</title>
    <url>/p/e415a24c.html</url>
    <content><![CDATA[<p><img src="images/game_shqb_cover.png" alt=""></p>
<p>“I am Andrew Ryan, and I’m here to ask you a question.<br>Is a man not entitled to the sweat of his brow?</p>
<p>says the man in Washington, It belongs to the poor.<br>says the man in the Vatican, It belongs to God.<br>says the man in Moscow, It belongs to everyone.</p>
<p>I rejected those answers; instead, I chose something different. I chose the impossible. I chose…Rapture,<br>a city where the artist would not fear the censor,<br>where the scientist would not be bound by petty morality,<br>where the great would not be constrained by<br>the small!</p>
<p>And with the sweat of your brow, Rapture can become your city as well.”</p>
<p>Andrew Ryan<br>A man chooses,A slave obeys</p>
<p>人会思考，而奴隶只会服从</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetworking HTTPS配置</title>
    <url>/p/450b42bd.html</url>
    <content><![CDATA[<ul>
<li>一、HTTPS</li>
<li>二、App Transport Security</li>
<li>三、iOS 中用HTTPS 注意的问题</li>
<li>四、使用 AFNetworking HTTPS 遇到的问题</li>
<li>五、问题的解决方法</li>
<li>六、注意服务器端 两种证书的区别（以及如何验证HTTPS服务器是否符合ATS特性中的要求）</li>
</ul>
<h2 id="一、HTTPS"><a href="#一、HTTPS" class="headerlink" title="一、HTTPS"></a>一、HTTPS</h2><p>HTTPS就是将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。</p>
<h2 id="二、App-Transport-Security"><a href="#二、App-Transport-Security" class="headerlink" title="二、App Transport Security"></a>二、App Transport Security</h2><p>iOS9中新增App Transport Security（简称ATS）特性, 主要使到原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。</p>
<p>一般我们如果还是使用的http,不更新的话，可通过在 Info.plist 中声明，倒退回不安全的网络请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;NSAllowsArbitraryLoads&lt;&#x2F;key&gt;</span><br><span class="line">        &lt;true&#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;dict&gt;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">## 三、iOS 中用HTTPS 注意的问题</span><br><span class="line"></span><br><span class="line">先看文档中的描述：</span><br><span class="line"></span><br><span class="line">These are the App Transport Security requirements:</span><br><span class="line"></span><br><span class="line">* The protocol Transport Security Layer (TLS) must be at least version 1.2.</span><br><span class="line">* Connection ciphers are limited to those that provide forward secrecy (see the list of ciphers below.)</span><br><span class="line">* Certificates must use at least an SHA256 fingerprint with either a 2048 bit or greater RSA key, or a 256 bit or greater Elliptic-Curve (ECC) key. </span><br><span class="line"> </span><br><span class="line">根据原文描述，首先必须要基于TLS 1.2版本协议。再来就是连接的加密方式要提供Forward Secrecy，文档中罗列出支持的加密算法（如下表）。  最后就是证书至少要使用一个SHA256的指纹与任一个2048位或者更高位的RSA密钥，或者是256位或者更高位的ECC密钥。如果不符合其中一项，请求将被中断并返回nil。</span><br><span class="line"></span><br><span class="line">* 第一条就是TLS版本所需要支持的协议</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一条满足</span><br><span class="line"></span><br><span class="line">第一条就是连接的加密方式需要提供“Foward Secrecy”这个东东,下面是支持Forward Secrecy的加密方式</span><br></pre></td></tr></table></figure>
<p>  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384<br>  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<br>  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384<br>  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA<br>  <code>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</code><br>  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA<br>  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384<br>  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256<br>  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384<br>  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256<br>  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这是一个满足条件的证书信息中的情况</span><br><span class="line"></span><br><span class="line">满足上面中的条件</span><br><span class="line"></span><br><span class="line">但是也要注意证书的合法性,注意是否有效，iOS要求连接的HTTPS站点必须为CA签名过的合法证书。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">证书不被信任</span><br><span class="line"></span><br><span class="line">证书未经过验证</span><br><span class="line"></span><br><span class="line">### 有效</span><br><span class="line">注意以上不同的情况决定了AFSecurityPolicy--setAllowInvalidCertificates:是否要验证证书的有效性。</span><br><span class="line"></span><br><span class="line">## 四、使用AFNetworking HTTPS 遇到的问题（3.0.0之前）</span><br></pre></td></tr></table></figure>
<p>AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];<br>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];<br>//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO//如果是需要验证自建证书，需要设置为YES<br>securityPolicy.allowInvalidCertificates = YES;<br>//validatesDomainName 是否需要验证域名，默认为YES；<br>securityPolicy.validatesDomainName = YES;<br>manager.securityPolicy  = securityPolicy;<br>manager.responseSerializer = [AFHTTPResponseSerializer serializer];<br>[manager POST:urlString parameters:dic success:finishedBlock failure:failedBlock];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 五、Code&#x3D;-1012 错误解决方法</span><br><span class="line"></span><br><span class="line">### 步骤1：获取到站点的证书</span><br><span class="line"></span><br><span class="line">我们可以使用以下openssl命令来获取到服务器的公开二进制证书（以google为例）</span><br></pre></td></tr></table></figure>
<p>openssl s_client -connect <a href="http://www.google.com:443" target="_blank" rel="noopener">www.google.com:443</a> &lt;/dev/null 2&gt;/dev/null | openssl x509 -outform DER &gt; https.cer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">冒号中的为命令主要部分。该条命令将会在当前路径下，形成google.com站点的公开二进制证书，命名为https.cer。您可以将www.google.com 替换成您自己的站点以此来获取您自己站点的https.cer。</span><br><span class="line"></span><br><span class="line">### 步骤2：导入到Xcode中</span><br><span class="line"></span><br><span class="line">直接将https.cer放到资源目录中就好了，让我们可以通过pathForResource:获取到证书，就OK了。</span><br><span class="line"></span><br><span class="line">https</span><br><span class="line"></span><br><span class="line">### 步骤3：代码导入</span><br></pre></td></tr></table></figure>
<p>NSString *urlString = @”<a href="https://www.example.com/app/publicRequest&quot;" target="_blank" rel="noopener">https://www.example.com/app/publicRequest&quot;</a>;<br>NSString *cerPath = [[NSBundle mainBundle] pathForResource:@”https” ofType:@”cer”];<br>NSData * certData =[NSData dataWithContentsOfFile:cerPath];<br>NSSet * certSet = [[NSSet alloc] initWithObjects:certData, nil];<br>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];<br>// 是否允许,NO– 不允许无效的证书<br>[securityPolicy setAllowInvalidCertificates:YES];<br>// 设置证书<br>[securityPolicy setPinnedCertificates:certSet];<br>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];<br>manager.securityPolicy = securityPolicy;<br>manager.responseSerializer = [AFHTTPResponseSerializer serializer];<br>// request<br>[manager GET:urlString parameters:nil progress:^(NSProgress * progress){<br>} success:^(NSURLSessionDataTask *task, id responseObject) {<br>    NSArray * array = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableLeaves error:nil];<br>    NSLog(@”OK === %@”,array);<br>} failure:^(NSURLSessionDataTask *task, NSError *error) {<br>    NSLog(@”error ==%@”,error.description);<br>}];</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后，就OK了。</span><br><span class="line"></span><br><span class="line">## 六、注意下服务器端两种证书的区别</span><br><span class="line"></span><br><span class="line">* 第一种是创建证书请求，然后到权威机构认证，随之配置到服务器；</span><br><span class="line">* 第二种是自建证书，需要自己配置给服务器。  </span><br><span class="line"></span><br><span class="line">使用第一种还是好一点的，至少在我们 app 端不需要为ATS做过多的适配。但是如何才能知道一个HTTPS服务器是否符合ATS特性中的要求的呢？使用nscurl命令：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;nscurl --ats-diagnostics --verbose https:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>

<p>下面是测百度时，返回的某一段，结论是OK的，里面有很多测试的情况，我们可以逐一观察是否正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TLSv1.0 with PFS disabled and insecure HTTP allowed</span><br><span class="line">ATS Dictionary:</span><br><span class="line">&#123;</span><br><span class="line">    NSExceptionDomains &#x3D;     &#123;</span><br><span class="line">        &quot;www.baidu.com&quot; &#x3D;         &#123;</span><br><span class="line">            NSExceptionAllowsInsecureHTTPLoads &#x3D; true;</span><br><span class="line">            NSExceptionMinimumTLSVersion &#x3D; &quot;TLSv1.0&quot;;</span><br><span class="line">            NSExceptionRequiresForwardSecrecy &#x3D; false;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Result : PASS</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation 视频播放</title>
    <url>/p/6a08fb7e.html</url>
    <content><![CDATA[<p>AVFoundation 视频播放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSURL * url &#x3D; [NSURL fileURLWithPath:@&quot;视频地址&quot;];</span><br><span class="line">AVPlayerItem *playerItem &#x3D; [AVPlayerItem playerItemWithURL:url];</span><br><span class="line">self.player &#x3D; [AVPlayer playerWithPlayerItem:playerItem];</span><br><span class="line">[self.player addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">self.player.actionAtItemEnd &#x3D; AVPlayerActionAtItemEndNone;</span><br><span class="line">self.playerLayer &#x3D; [AVPlayerLayer playerLayerWithPlayer:self.player];</span><br><span class="line">self.playerLayer.videoGravity     &#x3D; AVLayerVideoGravityResizeAspect;</span><br><span class="line">self.playerLayer.frame &#x3D; self.view.bounds;</span><br><span class="line">[self.view.layer addSublayer:self.playerLayer];</span><br></pre></td></tr></table></figure>

<p>这里要监听一下AVPlayer的status属性，当status的状态变为AVPlayerStatusReadyToPlay时，说明视频就可以播放了，此时我们调用[self.player play];就好了。</p>
<p>如果是AVPlayerStatusFailed说明视频加载失败，这时可以通过self.player.error.description属性来找出具体的原因。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation 音视频混合</title>
    <url>/p/bfca531b.html</url>
    <content><![CDATA[<p>如何将一段音频插入到视频中？可以使用AVFoundation的AVMutableComposition来实现：</p>
<a id="more"></a>
<p>首先，设置导出路径，注意检查路径下是否已经有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *fileName &#x3D; [NSString stringWithFormat:@&quot;%@.mp4&quot;,[DataUtilities getFileName]];</span><br><span class="line">    NSString *outputFilePath &#x3D; @“new output file path”</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:outputFilePath]) &#123;</span><br><span class="line">        [[NSFileManager defaultManager] removeItemAtPath:outputFilePath error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            DLog(@&quot;error %@&quot;,error.description);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    error &#x3D; nil;</span><br></pre></td></tr></table></figure>

<h2 id="初始化混合器"><a href="#初始化混合器" class="headerlink" title="初始化混合器"></a>初始化混合器</h2><p><code>AVMutableComposition *mixComposition = [AVMutableComposition composition];</code></p>
<p>初始化音频混合器通道，从AVAsset文件中定位音频长度，提取音频通道对象AVAssetTrack，插入音频混合器通道，其中timeRange指提取是音频长度，CMTimeRange，ofTrack：提取音频文件的AVAsset对象的AVAssetTrack，atTime表示从要插入的视频的那个时间点开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVMutableCompositionTrack *audioCompostionTrack &#x3D; [mixComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;音频文件资源</span><br><span class="line">CMTimeRange audio_timeRange &#x3D; CMTimeRangeMake(kCMTimeZero, toVideoAsset.duration);</span><br><span class="line">AVAssetTrack *audioTrack &#x3D; [[fromVideoAsset tracksWithMediaType:AVMediaTypeAudio] firstObject];</span><br><span class="line">if (CMTimeGetSeconds(audioTrack.timeRange.duration)&lt;15) &#123;</span><br><span class="line">    DLog(@&quot;把fromVideo的音频提取混合到toVideo 音频长度异常&quot;);</span><br><span class="line">&#125;</span><br><span class="line">[audioCompostionTrack insertTimeRange:audio_timeRange ofTrack:audioTrack atTime:kCMTimeZero error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    DLog(@&quot;error %@&quot;,error.description);</span><br><span class="line">&#125;</span><br><span class="line">error &#x3D; nil;</span><br></pre></td></tr></table></figure>

<h2 id="与音频提取类似，提取视频通道，插入到混合器"><a href="#与音频提取类似，提取视频通道，插入到混合器" class="headerlink" title="与音频提取类似，提取视频通道，插入到混合器"></a>与音频提取类似，提取视频通道，插入到混合器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;视频文件资源</span><br><span class="line">AVMutableCompositionTrack *videoCompostionTrack &#x3D; [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line">CMTimeRange vedio_timeRange &#x3D; CMTimeRangeMake(kCMTimeZero, toVideoAsset.duration);</span><br><span class="line">[videoCompostionTrack insertTimeRange:vedio_timeRange ofTrack:[[toVideoAsset tracksWithMediaType:AVMediaTypeVideo] firstObject] atTime:kCMTimeZero error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    DLog(@&quot;error %@&quot;,error.description);</span><br><span class="line">&#125;</span><br><span class="line">error &#x3D; nil;</span><br></pre></td></tr></table></figure>

<p>视频导出，用AVAssetExportSession，outputURL设置导出路径，outputFileType：导出类型，AVFileTypeMPEG4即是导出为mp4，shouldOptimizeForNetworkUse:是否为网络优化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; presetName 与 outputFileType 要对应  导出合并的音频</span><br><span class="line">AVAssetExportSession* assetExportSession &#x3D; [[AVAssetExportSession alloc] initWithAsset:mixComposition presetName:AVAssetExportPresetMediumQuality];</span><br><span class="line">assetExportSession.outputURL &#x3D; [NSURL fileURLWithPath:outputFilePath];</span><br><span class="line">assetExportSession.outputFileType &#x3D; AVFileTypeMPEG4;</span><br><span class="line">assetExportSession.shouldOptimizeForNetworkUse &#x3D; YES;</span><br><span class="line"></span><br><span class="line">[assetExportSession exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">        completeBlock(outputFilePath,assetExportSession.error.description);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)mergeAudioFromVideoAsset:(AVAsset *)fromVideoAsset</span><br><span class="line">                    toVideoAsset:(AVAsset *)toVideoAsset</span><br><span class="line">                   completeBlock:(mergeToolCompleteBlock)completeBlock &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *fileName &#x3D; [NSString stringWithFormat:@&quot;%@.mp4&quot;,[DataUtilities getFileName]];</span><br><span class="line">    NSString *outputFilePath &#x3D; @“new output file path”</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:outputFilePath]) &#123;</span><br><span class="line">        [[NSFileManager defaultManager] removeItemAtPath:outputFilePath error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            DLog(@&quot;error %@&quot;,error.description);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    error &#x3D; nil;</span><br><span class="line">    </span><br><span class="line">    AVMutableComposition *mixComposition &#x3D; [AVMutableComposition composition];</span><br><span class="line">    </span><br><span class="line">    AVMutableCompositionTrack *audioCompostionTrack &#x3D; [mixComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;音频文件资源</span><br><span class="line">    CMTimeRange audio_timeRange &#x3D; CMTimeRangeMake(kCMTimeZero, toVideoAsset.duration);</span><br><span class="line">    AVAssetTrack *audioTrack &#x3D; [[fromVideoAsset tracksWithMediaType:AVMediaTypeAudio] firstObject];</span><br><span class="line">    if (CMTimeGetSeconds(audioTrack.timeRange.duration)&lt;15) &#123;</span><br><span class="line">        DLog(@&quot;把fromVideo的音频提取混合到toVideo 音频长度异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    [audioCompostionTrack insertTimeRange:audio_timeRange ofTrack:audioTrack atTime:kCMTimeZero error:&amp;error];</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        DLog(@&quot;error %@&quot;,error.description);</span><br><span class="line">    &#125;</span><br><span class="line">    error &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F;视频文件资源</span><br><span class="line">    AVMutableCompositionTrack *videoCompostionTrack &#x3D; [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line">    </span><br><span class="line">    CMTimeRange vedio_timeRange &#x3D; CMTimeRangeMake(kCMTimeZero, toVideoAsset.duration);</span><br><span class="line">    [videoCompostionTrack insertTimeRange:vedio_timeRange ofTrack:[[toVideoAsset tracksWithMediaType:AVMediaTypeVideo] firstObject] atTime:kCMTimeZero error:&amp;error];</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        DLog(@&quot;error %@&quot;,error.description);</span><br><span class="line">    &#125;</span><br><span class="line">    error &#x3D; nil;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; presetName 与 outputFileType 要对应  导出合并的音频</span><br><span class="line">    AVAssetExportSession* assetExportSession &#x3D; [[AVAssetExportSession alloc] initWithAsset:mixComposition presetName:AVAssetExportPresetMediumQuality];</span><br><span class="line">    assetExportSession.outputURL &#x3D; [NSURL fileURLWithPath:outputFilePath];</span><br><span class="line">    assetExportSession.outputFileType &#x3D; AVFileTypeMPEG4;</span><br><span class="line">    assetExportSession.shouldOptimizeForNetworkUse &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    [assetExportSession exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            completeBlock(outputFilePath,assetExportSession.error.description);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTE ：论文艺复兴时期女性画家的生存之路</title>
    <url>/p/84c74286.html</url>
    <content><![CDATA[<p><img src="/images/acg_arte_cover.jpg" alt=""></p>
<p>然看到一部讲述16世纪艺术工技的漫画，这种题材真是相当少见，而且主人公还是女性（阿爾蒂），从小喜欢画画的贵族少女，在父亲离世母亲催婚的情况下，离家出走成为画家的故事。</p>
<h2 id="阿爾蒂"><a href="#阿爾蒂" class="headerlink" title="阿爾蒂"></a>阿爾蒂</h2><p>勇敢、坚强，基本没有少女的矜持与优雅，永远不放弃的行动派，能够厚着脸皮接受一个个工坊的拒绝，在被讽刺“女人”的身份时断发明志（我不做女人啦！jojo!），在遇到师傅雷恩一开始的刁难，能够不逃避得表现自己，最后赢得雷恩的认可。</p>
<p>有趣的是后面剧情发展中，对于阿爾蒂的“女人”、“贵族”身份，有人羡慕、有人鄙视，而阿爾蒂也从开始的抵触到认识出身的不可改变，利用这些元素增长自己的画技，她的人物画中的细腻和精美正是由于“女性”和“贵族”才发展进步的，既然“女画家”不能避免，那就成为“优秀的女画家”吧。</p>
<h2 id="职业、知识和人"><a href="#职业、知识和人" class="headerlink" title="职业、知识和人"></a>职业、知识和人</h2><p>整部作品对职业的描写非常细致，对十六世纪知识的宝贵、商人的经营、社会的风俗都有大量描写。</p>
<p>工匠背后的刻苦训练、艺术品背后沉重的体力的劳动、普通人和有天赋者间的差距让人看到工匠们的真诚实在。</p>
<p>同时工艺作品背后的人文思考、科学考究这种文艺复兴时期的精神宣扬在作品中也表现不少。</p>
<h2 id="女性的独立"><a href="#女性的独立" class="headerlink" title="女性的独立"></a>女性的独立</h2><p>嫁妆的丰厚决定丈夫的家庭，这是那个时期的婚姻前提，更多的嫁妆代表着更好的对象。</p>
<p>工匠对女性的排斥，很大一方面是体力和思想上的限制，工匠的活真是很疲累，而当时的思想也决定着好人家的女儿不会抛头露面，但阿爾蒂慢慢被接受也表现知识技术的进步本身已经提供给女性机会去追求自己独立事业</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation：功能架构</title>
    <url>/p/43bbfa4b.html</url>
    <content><![CDATA[<p>AVFoundation 框架结合了音视频的主要技术领域，共同涵盖了在 Apple 平台上捕获、处理、合成、控制、导入和导出音视频的各种任务。</p>
<h2 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h2><p>AVFoundation 框架提供了大量的类及功能，下面对 AVFoundation 的一些核心功能进行分类说明。</p>
<h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><p>AVFoundation框架封装了 AVPlayer 和 AVPlayerItem，可以实现本地文件或远程流视频资源的播放，并且能够对视频播放内容、速度等属性进行控制。</p>
<h2 id="音频播放和记录"><a href="#音频播放和记录" class="headerlink" title="音频播放和记录"></a>音频播放和记录</h2><p>与 AVPlayer 不同，系统提供的 AVAudioPlayer 和 AVAudioRecorder 指出简单的音频播放和录制功能，方便开发者进行音频相关开发，API 非常简单。</p>
<h2 id="媒体捕捉"><a href="#媒体捕捉" class="headerlink" title="媒体捕捉"></a>媒体捕捉</h2><p>AVFoundation 提供了以 AVCaptureSession 为核心的设备控制类，主要处理摄像头捕捉和麦克风录音。</p>
<h2 id="媒体编辑"><a href="#媒体编辑" class="headerlink" title="媒体编辑"></a>媒体编辑</h2><p>AVFoundation框架支持多个音频和视频资源进行组合和修改，无论是视频合成、裁切，或者调整音频参数等，AVFoundation 基于 AVAsset 的子类 AVComposition 来处理这部分功能。AVComposition 中的轨道都是 AVAssetTrack 的子类 AVCompositionTrack。一个组合轨迹本身由一个或多个媒体片断组成，由 AVCompositionTrackSegment 类定义，代表这个组合中的实际媒体区域。</p>
<p>AVComposition 和 AVCompositionTrack 只提供对资源的只读操作，都是不可变对象。当需要创建视频组合时，就使用 AVMutableComposition 和 AVMutableCompositionTrack 所提供的可变子类。</p>
<h2 id="媒体处理"><a href="#媒体处理" class="headerlink" title="媒体处理"></a>媒体处理</h2><p>通过 AVFoundation 框架的 AVAssetReader 和 AVAssetWriter 对媒体资源进行字节级别的操作，这些类提供直接访问视频帧和音频样本的功能，所以可以对媒体资源进行任何更高级的处理。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title>Animation Farm：美好理想的失控</title>
    <url>/p/1756ed8f.html</url>
    <content><![CDATA[<p>一个10*10的方阵，如果要求整齐的话，那么就需要每个人都站好自己的位置，而想要破坏它的整齐，则只需要一个人的站位出错就可以了。</p>
<p>追求秩序的道路上是否也会有这种问题呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Whatever goes upon two legs is an enemy.</span><br><span class="line">Whatever goes upon four legs, or has wings, is a friend.</span><br><span class="line">No animal shall wear clothes.</span><br><span class="line">No animal shall sleep in a bed.</span><br><span class="line">No animal shall drink alcohol.</span><br><span class="line">No animal shall kill any other animal.</span><br><span class="line">All animals are equal.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>CKOU 晋级考试内容</title>
    <url>/p/51639e84.html</url>
    <content><![CDATA[<h1 id="CKOU-剑道晋级考级内容"><a href="#CKOU-剑道晋级考级内容" class="headerlink" title="CKOU 剑道晋级考级内容"></a>CKOU 剑道晋级考级内容</h1><p>整理一下剑道考级内容，剑道考级包括三项：</p>
<p>剑道型(kata)、切返(kiri-kaeshi)和对战(ji-geiko)。1级以下的考级没有剑道型的审查，而且有冲击练习（kakari-geiko）替代对战。</p>
<a id="more"></a>

<h2 id="8级"><a href="#8级" class="headerlink" title="8级"></a>8级</h2><p>掌握技术：</p>
<p>礼法、正确的着装、握剑法、中段构</p>
<p>基本步法：送足，步足，开足，继足</p>
<p>基本素振：三举动素振、二举动素振、一举动素振、跳跃素振</p>
<p>形：九形十三刀之一本目</p>
<h2 id="7级"><a href="#7级" class="headerlink" title="7级"></a>7级</h2><p>掌握技术：</p>
<p>大动作打突振足穿越：大动作击面、大动作击小手、大动作击胴、切返</p>
<p>基本滑步组合打击：(大动作)小手-面、面-面、拂击面(Harai-men)，小手-面-胴</p>
<p>形：九形十三刀之一本目到三本目</p>
<h2 id="6级"><a href="#6级" class="headerlink" title="6级"></a>6级</h2><p>掌握技术：</p>
<p>能正确的穿戴全套护具并完成以下除剑道形以外的内容</p>
<p>退击技：(大动作)退击面、退击小手、退击胴</p>
<p>基本打突技：大动作击面、大动作击小手、大动作击胴、</p>
<p>切返、小手-面、面-面、拂击面(Harai-men)、小手-面-胴</p>
<p>形：九形十三刀之一本目到六本目</p>
<h2 id="5级"><a href="#5级" class="headerlink" title="5级"></a>5级</h2><p>掌握技术：</p>
<p>正确的穿戴全套护具并能完成以下除剑道形以外的内容</p>
<p>基本打击练习(Uchikomi-geiko)：(大动作)击面、击小手、击胴、小手-面、面-面、拂击面(Harai-<br>men)、小手-面-胴、退击面、退击小手、退击胴</p>
<p>形：九形十三刀之一本目到九本目</p>
<h2 id="4级-："><a href="#4级-：" class="headerlink" title="4级 ："></a>4级 ：</h2><p>掌握技术：</p>
<p>正确的穿戴全套护具并能完成以下除剑道形以外的内容</p>
<p>基本打击练习(Uchikomi-geiko)：(大动作)小手-面-退击面、小手-面-退击小手、小手-面-退击胴、小手-面-退击面-小手-面、小手-面-退击小手-小手-面、小手-面-退击胴-小手-面</p>
<p>地稽古(Ji-geiko)：(大动作)</p>
<p>形：九形十三刀全部，日本剑道形之一本目到二本目</p>
<h2 id="3级-："><a href="#3级-：" class="headerlink" title="3级 ："></a>3级 ：</h2><p>正确的穿戴全套护具并能完成以下除剑道形以外的内容</p>
<p>基本打突：(小动作)小动作击面、小动作击小手、小动作小手/拂击-大动作击面、大动作小手-小动作击面</p>
<p>地稽古(Ji-geiko)：与段位审查之“实技”相同</p>
<p>形：九形十三刀全部，日本剑道形之一本目到三本目</p>
<h2 id="2级-："><a href="#2级-：" class="headerlink" title="2级 ："></a>2级 ：</h2><p>掌握技术：</p>
<p>基本连续技：(小动作)小手-面、面-面、竹刀-面、小手/拂击<br>面-退击面、小手/拂击-面-退击小手、小手/拂击-面-退击胴、小手/拂击-面-退击面-小手/竹刀-面、小手/竹刀-面-退击小手-小手/竹刀-面、小手/竹刀-面-退击胴-小手/竹刀-面</p>
<p>地稽古(Ji-geiko)：与段位审查之“实技”相同(必考)</p>
<p>形：九形十三刀全部，日本剑道形之一本目到四本目</p>
<h2 id="1级-："><a href="#1级-：" class="headerlink" title="1级 ："></a>1级 ：</h2><p>掌握技术：</p>
<p>基本实战组合技：(小动作)小手/拂击-面-转身退击面、小手/拂击-面-转身退击小手、小手/拂击-面-转身退击胴、小手/拂击-面-转身退击面-小手/拂击-面、小手/拂击-面-转身退击小手-小手/拂击-面、小手/拂击-面-转身退击胴-小手/拂击-面</p>
<p>冲击练习(Kakari-geiko)</p>
<p>地稽古(Ji-geiko)：与段位审查之“实技”相同(必考)</p>
<p>形：九形十三刀全部，日本剑道形之一本目到五本目</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>以上内容是通过网络搜索和询问老师后整理的，具体考级内容请在考试前和老师确定下，祝各位考级顺利，武运昌隆。</p>
]]></content>
      <tags>
        <tag>kendo</tag>
      </tags>
  </entry>
  <entry>
    <title>CA证书</title>
    <url>/p/d9904f0c.html</url>
    <content><![CDATA[<h1 id="证书、私钥和CA"><a href="#证书、私钥和CA" class="headerlink" title="证书、私钥和CA"></a>证书、私钥和CA</h1><p>现在我们所说的证书一般是指服务器证书，也就是公钥加上域名、公司信息、序列号、签名信息等组成；</p>
<p>私钥和公钥相对应，私钥加密的东西只能公钥解密，公钥加密的东西只能私钥解密，并且不能由公钥推断出私钥，但是可以由私钥算出公钥来。所以这里有一件非常有意思的事情，你可以在公私钥不变的情况下换一张证书，因为证书其实包括其他信息，所以你换的是别的信息，这些信息的变化会导致证书签名也会变化，所以就变成了一张新的证书，但是公钥私钥是没有变化的。</p>
<p>CA也由证书和私钥组成，它的证书和普通的证书长得差不多，只是其中的Basic Constraint字段里面的CA值为True而已，普通的服务器证书这一块为False，但是因为有了这个True，所以CA可以签发别的证书。<br>服务器证书的分类</p>
<p>可以从两个维度去看证书的分类，一种是商业角度，为了区分不同的用户级别，服务端证书可以分成DV、OV和EV证书。</p>
<a id="more"></a>

<h2 id="DV-OV"><a href="#DV-OV" class="headerlink" title="DV\OV"></a>DV\OV</h2><p>DV（Domain Validation）证书只进行域名的验证，一般验证方式是提交申请之后CA会往你在whois信息里面注册的邮箱发送邮件，只需要按照邮件里面的内容进行验证即可。<br>OV（Organization Validation）证书在DV证书验证的基础上还需要进行公司的验证，一般他们会通过购买邓白氏等这类信息库来查询域名所属的公司以及这个公司的电话信息，通过拨打这个公司的电话来确认公司是否授权申请OV证书。<br>EV证书一般是在OV的基础上还需要公司的金融机构的开户许可证，不过不同CA的做法不一定一样，例如申请人是地方政府机构的时候是没有金融机构的开户证明的，这时候就会需要通过别的方式去鉴别申请人的实体信息。<br>从业务角度来看证书还可以分成单域名证书、多域名证书、泛域名证书和多泛域名证书，具体可以参考表格里面的例子。<br>因为DV证书认证级别比较低，所以你查看DV证书的时候只能查看到域名信息，无法查看组织、公司信息，而OV和EV证书是可以的，特别是EV证书在地址栏上会展现成绿色的长条并且显示公司信息，给人的感觉比较专业和安全。</p>
<p>DV证书因为主要面向个人用户，安全体系会相对比较弱，所以只支持单域名和多域名证书，价格非常便宜，甚至现在有CA提供免费的DV证书（例如国内的wosign和国外即将上线的Let’s Encrypt）。</p>
<p>OV和EV证书比较贵，除了需要人工验证之外，还在于他们有比较高的保险费用，如果CA的私钥出问题了，那么这些OV、EV证书都将得到巨额的赔偿，一般一张证书的赔偿金额都在100万美元以上。</p>
<p>这里最有特色的就是多泛域名证书，到现在为止也还没有正式的名字，我一般叫做Wildcard SAN certificate，简称WSAN，现在在CA的申请网页里面一般也很难看到有这样一个单独的申请选项，不过主流的CA现在都已经支持这种证书了，我所知道的Digicert和GlobalSign都可以申请，你如果有需要可以找他们的客服问问。</p>
<h2 id="如何生成和查看CA-服务器证书"><a href="#如何生成和查看CA-服务器证书" class="headerlink" title="如何生成和查看CA/服务器证书"></a>如何生成和查看CA/服务器证书</h2><p>这是我觉得非常好的介绍如何创建Root、签发CA以及服务器证书的文章，大家有兴趣可以参考：<a href="https://jamielinux.com/docs/openssl-certificate-authority/" target="_blank" rel="noopener">https://jamielinux.com/docs/openssl-certificate-authority/</a></p>
<p>这里简单说一下为什么现在都是二层的CA架构？首先这二层CA我们一般叫做RootCA和IssuingCA，RootCA是自签名的，IssuingCA是由RootCA签发的。其实很早以前CA会直接使用他们的RootCA签发证书，但是因为RootCA的证书非常干净，上面没有任何的限制，容易出问题，所以现在都会签发一个pathlen=0的IssuingCA，再由这个CA去签发证书，表示这个CA只能签发普通证书，是无法在签发新的CA的。</p>
<h2 id="CA的历史和事故"><a href="#CA的历史和事故" class="headerlink" title="CA的历史和事故"></a>CA的历史和事故</h2><p>Verisign是第一家CA厂商，创办于1995年，当时得到了RSA算法的使用授权，是全世界最大的CA厂商，在2010年以12.8亿美元卖给了赛门铁克。当前TOP5的CA厂商分别是Symantec、Comodo、Godaddy、GlobalSign和Digicert，占据了90%以上的市场份额。</p>
<p>CA的历史上也出过几次严重的问题：</p>
<ul>
<li>2002年Verisign在未经微软授权的情况下签发了一张微软的证书，攻击者通过使用伪造的身份来通过Verisign的验证，最终的后果就是微软为此发布了一个紧急的更新补丁。  </li>
<li>2008年在实验室里通过MD5的碰撞获取了一个“真”的CA，用它签发出来的证书会被认为是浏览器里面已经受信的某个CA签发出来的。  </li>
<li>2011年连续出现了几次攻击，最严重的就是DigiNotar被伊朗的黑客入侵，签发了500多张未授权证书，所以他的Root全部被浏览器和操作系统吊销，整个公司也最终破产，可以说这是有史以来最严重的CA事故。<br>之后Google利用HPKP还发现了很多MITM（Man in the Middle）攻击，例如TURKTRUST和ANSSI，有兴趣的可以去搜索了解一下。</li>
</ul>
<h2 id="PKI体系介绍、漏洞和方案"><a href="#PKI体系介绍、漏洞和方案" class="headerlink" title="PKI体系介绍、漏洞和方案"></a>PKI体系介绍、漏洞和方案</h2><p>PKI体系的原理就是浏览器内置可信赖的RootCA的证书，所有由这些RootCA签发出来的证书都信任。所以今天虽然很多网站已经上了HTTPS，但是如果另外一家CA他偷偷签发了同样域名的证书然后进行流量劫持或者篡改，我们也是无法知道的。</p>
<p>所以为了应对这种问题，现在比较主流的两种方案是HPKP和Certificate Transparency：</p>
<p>HPKP的基本原理就是用户在第一次访问的时候在Response Header里面发送给用户正确的域名证书的签名信息，之后用户在访问我们网站如果遇到了别的证书发现签名信息不匹配就上报甚至拒绝访问。</p>
<ul>
<li>当然这种方案缺点也很明显，它采用类似HSTS的所谓的<strong>首次信任</strong>原则，也就是认为用户第一次的请求是可信没有被篡改的，而实际上这个无法百分百保证。</li>
<li>第二个问题是我们的证书太多，这样我们的配置发布系统就需要在证书更新之后发布新的签名信息给用户，而且还需要根据证书的有效期去设定返回头的有效期时间，如果再次遇到HeartBleed之类的攻击导致我们短期内大批量的吊销证书就蛋疼了。</li>
<li>另外当前只有Chrome 38 和 Firefox 36以上的版本支持，不过用这个功能来进行汇报还是不错的选择，具体如何配置可以Google一下。<br>第二种方式是让CA支持的透明证书功能，也就是要求所有的CA将他们颁发的证书日志全部都公开出来，这样我们就可以检索所有CA看看是否在我们未授权的情况下颁发了我们的域名证书。</li>
</ul>
<h2 id="多证书问题"><a href="#多证书问题" class="headerlink" title="多证书问题"></a>多证书问题</h2><p>SHA1证书安全问题，理论上从2016年1月1日开始CA是不能在颁发SHA1的证书给用户了，从2017年开始，所有的浏览器和操作系统都不应该支持SHA1的证书，对于最新的Chrome用户如果你的证书过期时间超过2016年1月1日，那么就会出现左边提醒，地址栏上也会显示成黄色三角。但是如果直接升级到SHA256就会导致老的XP SP2的用户不能访问你的网站，所以对于这个问题，我们的建议是：</p>
<h2 id="如果一定要使用SHA1证书，过期时间不超过2015年年底"><a href="#如果一定要使用SHA1证书，过期时间不超过2015年年底" class="headerlink" title="如果一定要使用SHA1证书，过期时间不超过2015年年底"></a>如果一定要使用SHA1证书，过期时间不超过2015年年底</h2><p>提供多证书支持，对于新的浏览器提供SHA256的证书，对于那些老的XP用户提供SHA1证书，还有一个注意点是中间证书也需要是SHA256的。<br>SNI（Server Name Indication）问题和WSAN证书</p>
<p>大家都知道我们可以在一个IP:PORT上部署多个虚拟主机，它的原理就是在HTTP请求头里面的Host字段带上了域名信息，例如Host: <a href="http://www.a.com，nginx在收到这个请求的时候就会通过匹配这个Host，然后把请求对应到具体的servername的配置。" target="_blank" rel="noopener">www.a.com，nginx在收到这个请求的时候就会通过匹配这个Host，然后把请求对应到具体的servername的配置。</a></p>
<p>但是SSL/TLS的握手过程是在HTTP传输之前，所以我们是无法使用HTTP的Host字段进行区分的。如果有多个域名指向到同一个VIP并且端口相同，例如a.com、b.com都指向到192.168.1.1，那么在SSL/TLS握手的过程中，我们是该返回a.com域名的证书还是b.com域名的证书呢？</p>
<p>解决方案很简单，可以使用前面提到的WSAN来解决这个问题，因为你可以把所有的域名合并在一张证书里面，而且WSAN证书还可以让你在多个域名之间保持连接复用，也就是说如果你之前访问了<a href="http://www.a.com，然后跳转到www.b.com，这个证书可以让你跳过**TCP**和**TLS**的握手，直接发送数据，当然，这是有前提的，你需要满足这些域名指定到同样的IP、使用SPDY3.1或者HTTP2，而且只有Chrome支持这个功能。" target="_blank" rel="noopener">www.a.com，然后跳转到www.b.com，这个证书可以让你跳过**TCP**和**TLS**的握手，直接发送数据，当然，这是有前提的，你需要满足这些域名指定到同样的IP、使用SPDY3.1或者HTTP2，而且只有Chrome支持这个功能。</a></p>
<h2 id="WSAN证书（WildCard-SubjectAlternativeName-Certificate）"><a href="#WSAN证书（WildCard-SubjectAlternativeName-Certificate）" class="headerlink" title="WSAN证书（WildCard SubjectAlternativeName Certificate）"></a>WSAN证书（WildCard SubjectAlternativeName Certificate）</h2><p>这种证书想必大家已经很熟悉了，下一步具体介绍一下WSAN还有什么其他好处：</p>
<p>统一的过期时间：</p>
<p>如果你管理过证书你就知道当有几百张证书的时候，每张证书的过期时间都不一样，时不时的需要重新renew，非常的痛苦；而使用WSAN之后，每次新增域名直接加到证书里面，这样大家的过期时间都一样，进行renew的时候只需要renew一张就所有的都renew了，每年统一干一次就好了</p>
<p>证书使用范围控制：</p>
<p>因为WSAN证书里面域名非常多，安全级别要求也非常高，所以需要妥善保管私钥。</p>
<p>当然WSAN也有不好的地方，就是每次需要新增域名的话都需要进行证书的更新（私钥可以不更新），所以可以限制WSAN证书的更新频率，例如每两个月固定新增一批新的域名。</p>
<p>总体来看WSAN让运维效率可以大幅提升，同时通过限制使用范围，使用自动化的方式更新WSAN证书。</p>
<h2 id="评估-CA-供应商"><a href="#评估-CA-供应商" class="headerlink" title="评估 CA 供应商"></a>评估 CA 供应商</h2><p>CA 供应商很多，提供服务的侧重点可能也存在一些差异，比如很多 CA 都没有提供证书吊销的服务，这一点对于安全性要求很高的企业来说是完全不能接受的，那么对 CA 供应商的评估需要注意写什么呢？</p>
<h3 id="内置根"><a href="#内置根" class="headerlink" title="内置根"></a>内置根</h3><p>所谓内置根，就是 CA 的根证书内置到各种通用的系统/浏览器中，只有根证书的兼容性够强，它所能覆盖的浏览器才会越多。</p>
<h3 id="安全体系"><a href="#安全体系" class="headerlink" title="安全体系"></a>安全体系</h3><p>两个指标可以判断 CA 供应商是否靠谱，一是看价格，价格高自然有它的理由，必然提供了全套的安全保障体系；二是看黑历史，该 CA 供应商有没有爆出过什么漏洞，比如之前的 DigiNotar，被伊朗入侵，签发了 500 多张未授权的证书，结果直接被各系统/浏览器将其根拉入黑名单，毫无疑问公司直接倒闭。</p>
<h3 id="核心功能和扩展功能"><a href="#核心功能和扩展功能" class="headerlink" title="核心功能和扩展功能"></a>核心功能和扩展功能</h3><p>这就需要从业务上考虑了，不同的规模的企业、不同的业务对证书的要求不一样，比如证书是否会考虑无 SNI 支持的浏览器问题，是否支持在 reissue 的时候添加域名，是否支持 CAA，是否支持短周期证书等等。</p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>企业完全没必要购买 Github 那样的 EV 证书，太昂贵，而且一般的企业也未必能够申请到这样的证书。供应商很大，价格可以好好评估下，不一定要最贵，最适合的就行。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>Cocoapods创建私有podspec</title>
    <url>/p/1d676992.html</url>
    <content><![CDATA[<p>创建一个私有的podspec包括如下那么几个步骤：</p>
<ol>
<li>创建并设置一个私有的Spec Repo。</li>
<li>创建Pod的所需要的项目工程文件，并且有可访问的项目版本控制地址。</li>
<li>创建Pod所对应的podspec文件。</li>
<li>本地测试配置好的podspec文件是否可用。</li>
<li>向私有的Spec Repo中提交podspec。</li>
<li>在个人项目中的Podfile中增加刚刚制作的好的Pod并使用。</li>
<li>更新维护podspec。</li>
<li>创建私有Spec Repo</li>
</ol>
<p>先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的</p>
<ol>
<li>├── Specs</li>
<li>└── [SPEC_NAME]</li>
<li>└── [VERSION]</li>
<li>└── [SPEC_NAME].podspec</li>
</ol>
<p>因此我们需要创建一个类似于master的私有Spec Repo，可以fork官方的Repo</p>
<p>创建完成之后在Terminal中执行如下命令</p>
<ol>
<li>pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</li>
<li>pod repo add NewRepo <a href="http://github.com/newrepo/NewRepo.git" target="_blank" rel="noopener">http://github.com/newrepo/NewRepo.git</a></li>
</ol>
<p>此时如果成功的话进入到 <code>~/.cocoapods/repos</code> 目录下就可以看到 <code>NewRepo</code> 这个目录了。至此第一步创建私有 <code>Spec Repo</code> 完成。</p>
<p>PS：如果有其他合作人员共同使用这个私有 <code>Spec Repo</code> 的话在他有对应 <code>Git</code> 仓库的权限的前提下执行相同的命令添加这个 <code>Spec Repo</code> 即可。</p>
<p>创建 <code>Pod</code> 项目工程文件</p>
<p>创建新的组件项目，可以使用Using Pod Lib Create来创建项目</p>
<ol>
<li>$ pod lib create PodDemoLibrary</li>
</ol>
<p>之后四个问题，</p>
<ol>
<li>是否需要一个例子工程；</li>
<li>选择一个测试框架；</li>
<li>是否基于View测试；</li>
<li>类的前缀；</li>
</ol>
<p>具体介绍可以去看官方文档，我这里选择的是 1.yes；2.Specta/Expecta；3.yes；4.JD。 </p>
<p>问完这4个问题他会自动执行pod install命令创建项目并生成依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree PodDemoLibrary -L 2</span><br><span class="line">PodDemoLibrary</span><br><span class="line">├── Example                                  #demo APP</span><br><span class="line">│   ├── PodDemoLibrary</span><br><span class="line">│   ├── PodDemoLibrary.xcodeproj</span><br><span class="line">│   ├── PodDemoLibrary.xcworkspace</span><br><span class="line">│   ├── Podfile                              #demo APP 的依赖描述文件</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods                                  #demo APP 的依赖文件</span><br><span class="line">│   └── Tests</span><br><span class="line">├── LICENSE                               #开源协议 默认MIT</span><br><span class="line">├── Pod                                       #组件的目录</span><br><span class="line">│   ├── Assets                            #资源文件</span><br><span class="line">│   └── Classes                              #类文件</span><br><span class="line">├── PodDemoLibrary.podspec           #第三步要创建的podspec文件</span><br><span class="line">└── README.md                                #markdown格式的README</span><br><span class="line">9 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>以上是项目生成的目录结构及相关介绍。</p>
<p>接下来就是向Pod文件夹中添加库文件和资源，并配置podspec文件，我把一个网络模块的组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/PodDemoLibrary中了，然后编辑demo工程，测试组件。</p>
<p>注：这里需要注意的是每当你向Pod中添加了新的文件或者以后更新了podspec的版本都需要重新执行一遍pod update命令。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>
<p>通过Cocoapods创建出来的目录本身就在本地的Git管理下，我们需要做的就是给它添加远端仓库，同样去GitHub或其他的Git服务提供商那里创建一个私有的仓库，拿到SSH地址，然后cd到PodDemoLibrary目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;Initial Commit of Library&quot;</span><br><span class="line">$ git remote add origin &lt;git ssh url&gt;          #添加远端仓库</span><br><span class="line">$ git push origin master     #提交到远端仓库</span><br></pre></td></tr></table></figure>

<p>因为 <code>podspec</code> 文件中获取 <code>Git</code> 版本控制的项目还需要 <code>tag</code> 号，所以我们要打上一个 <code>tag</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag &#39;0.1.0&#39;</span><br><span class="line">$ git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure>

<p>做完这些就可以开始编辑podspec文件了，它是一个Ruby的文件，把编辑器的格式改成Ruby就能看到语法高亮，下面我贴上我的podspec文件，并在后面以注释的形式说明每个字段的含义，没有涉及到的字段可以去官方文档查阅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             &#x3D; &quot;PodDemoLibrary&quot;    #名称</span><br><span class="line">s.version          &#x3D; &quot;0.1.0&quot;             #版本号</span><br><span class="line">s.summary          &#x3D; &quot;Just Testing.&quot;     #简短介绍，下面是详细介绍</span><br><span class="line">s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">Testing Private Podspec.</span><br><span class="line">* Markdown format.</span><br><span class="line">* Don&#39;t worry about the indent, we strip it!</span><br><span class="line">DESC</span><br><span class="line">s.homepage         &#x3D; &quot;&lt;git project url&gt;&quot;                           #主页,这里要填写可以访问到的地址，不然验证不通过</span><br><span class="line"># s.screenshots     &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot;           #截图</span><br><span class="line">s.license          &#x3D; &#39;MIT&#39;              #开源协议</span><br><span class="line">s.author           &#x3D; &#123; &quot;abc&quot; &#x3D;&gt; &quot;abc@gmail.com&quot; &#125;                   #作者信息</span><br><span class="line">s.source           &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.git&quot;, :tag &#x3D;&gt; &quot;0.1.0&quot; &#125;      #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span><br><span class="line"># s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;twitter_username&gt;&#39;                       #多媒体介绍地址</span><br><span class="line">s.platform     &#x3D; :ios, &#39;8.0&#39;            #支持的平台及版本</span><br><span class="line">s.requires_arc &#x3D; true                   #是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span><br><span class="line">s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39;     #代码源文件地址，**&#x2F;*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span><br><span class="line">s.resource_bundles &#x3D; &#123;</span><br><span class="line">&#39;PodDemoLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">&#125;                                       #资源文件地址</span><br><span class="line">s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39;   #公开头文件地址</span><br><span class="line">s.frameworks &#x3D; &#39;UIKit&#39;                  #所需的framework，多个用逗号隔开</span><br><span class="line">s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;   #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span><br><span class="line">end&lt;&#x2F;twitter_username&gt;</span><br></pre></td></tr></table></figure>

<p>编辑完podspec文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，验证需要执行一下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure>

<p>当你看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt; PodDemoLibrary (0.1.0)</span><br><span class="line">PodDemoLibrary passed validation.</span><br></pre></td></tr></table></figure>

<p>时，说明验证通过了，不过这只是这个podspec文件是合格的，不一定说明这个Pod是可以用的，我们需要在本地做一下验证，这就是第四步的内容了，第四步在具体说明。</p>
<h2 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h2><p>如果从第二步过来，已经有了现成的项目，那么就需要给这个项目创建一个podspec文件，创建它需要执行Cocoapods的另外一个命令，官方文档在这里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod spec create PodDemoLibrary git@github.com:abc&#x2F;PodDemoLibrary.git</span><br></pre></td></tr></table></figure>

<p>执行完之后，就创建了一个podspec文件，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令验证一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure>

<p>验证无误就可以进入下一步了。</p>
<p>本地测试podspec文件</p>
<p>我们可以创建一个新的项目，在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 在Podfile中我们可以这样编辑，有两种方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &#39;7.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, :path &#x3D;&gt; &#39;~&#x2F;code&#x2F;Cocoapods&#x2F;podTest&#x2F;PodDemoLibrary&#39;      #指定路径</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, :podspec &#x3D;&gt; &#39;~&#x2F;code&#x2F;Cocoapods&#x2F;podTest&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.podspec&#39;  #指定podspec文件</span><br></pre></td></tr></table></figure>

<p>然后执行pod install命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了，不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/PodDemoLibrary中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。</p>
<p>在项目中编写代码，测试库文件无误后就可以开始下一步了，提交podspec到Spec Repo中。</p>
<p>向Spec Repo提交podspec</p>
<p>向Spec Repo提交podspec需要完成两点一个是podspec必须通过验证无误，在一个就是删掉无用的注释（这个不是必须的，为了规范还是删掉吧）。</p>
<p>向我们的私有Spec Repo提交podspec只需要一个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod repo push NewRepo PodDemoLibrary.podspec  #前面是本地Repo名字 后面是podspec名字</span><br></pre></td></tr></table></figure>

<p>完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/NewRepo目录下查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── PodDemoLibrary</span><br><span class="line">│   └── 0.1.0</span><br><span class="line">│       └── PodDemoLibrary.podspec</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被Push上去了。</p>
<p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod search PodDemoLibrary</span><br><span class="line">-&gt; PodDemoLibrary (0.1.0)</span><br><span class="line">Just Testing.</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, &#39;~&gt; 0.1.0&#39;</span><br><span class="line">- Homepage: https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;PodDemoLibrary</span><br><span class="line">- Source:   https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;PodDemoLibrary.git</span><br><span class="line">- Versions: 0.1.0 [NewRepo repo]</span><br></pre></td></tr></table></figure>

<p>这里说的是添加到私有的Repo，如果要添加到Cocoapods的官方库了，可以使用trunk工具，具体可以查看官方文档。</p>
<h3 id="使用制作好的Pod"><a href="#使用制作好的Pod" class="headerlink" title="使用制作好的Pod"></a>使用制作好的Pod</h3><p>在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下代码即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#指出Pod源地址，否则只会在官方地址中寻找</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;newRepo&#x2F;NewRepo.git&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod &#39;PodDemoLibrary&#39;, &#39;~&gt; 0.1.0&#39;</span><br></pre></td></tr></table></figure>

<p>然后执行pod update，更新库依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。</p>
<h3 id="更新维护podspec"><a href="#更新维护podspec" class="headerlink" title="更新维护podspec"></a>更新维护podspec</h3><p>最后再来说一下制作好的podspec文件后续的更新维护工作，比如如何添加新的版本，如何删除Pod。</p>
<p>我已经制作好了PodDemoLibrary的0.1.0版本，现在我对他进行升级工作，这次我添加了更多的模块到PodDemoLibrary之中，包括工具类，底层Model及UIKit扩展等，这里又尝试了一下subspec功能，给PodDemoLibrary创建了多个子分支。</p>
<p>具体做法是先将源文件添加到Pod/Classes中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在Pod/Classes下有创建了四个子目录，完成之后继续编辑之前的PodDemoLibrary.podspec，这次增加了subspec特性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             &#x3D; &quot;PodDemoLibrary&quot;</span><br><span class="line">s.version          &#x3D; &quot;1.0.0&quot;</span><br><span class="line">s.summary          &#x3D; &quot;Just Testing.&quot;</span><br><span class="line">s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">Testing Private Podspec.</span><br><span class="line">* Markdown format.</span><br><span class="line">* Don&#39;t worry about the indent, we strip it!</span><br><span class="line">DESC</span><br><span class="line">s.homepage         &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary&quot;</span><br><span class="line"># s.screenshots     &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot;</span><br><span class="line">s.license          &#x3D; &#39;MIT&#39;</span><br><span class="line">s.author           &#x3D; &#123; &quot;abc&quot; &#x3D;&gt; &quot;abc@gmail.com&quot; &#125;</span><br><span class="line">s.source           &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.git&quot;, :tag &#x3D;&gt; &quot;1.0.0&quot; &#125;</span><br><span class="line"># s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;twitter_username&gt;&#39;</span><br><span class="line">s.platform     &#x3D; :ios, &#39;8.0&#39;</span><br><span class="line">s.requires_arc &#x3D; true</span><br><span class="line">#s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line">#s.resource_bundles &#x3D; &#123;</span><br><span class="line">#  &#39;PodDemoLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">#&#125;</span><br><span class="line">#s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">s.subspec &#39;NetWorkEngine&#39; do |networkEngine|</span><br><span class="line">networkEngine.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;NetworkEngine&#x2F;**&#x2F;*&#39;</span><br><span class="line">networkEngine.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;NetworkEngine&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">networkEngine.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;DataModel&#39; do |dataModel|</span><br><span class="line">dataModel.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;DataModel&#x2F;**&#x2F;*&#39;</span><br><span class="line">dataModel.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;DataModel&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;CommonTools&#39; do |commonTools|</span><br><span class="line">commonTools.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;CommonTools&#x2F;**&#x2F;*&#39;</span><br><span class="line">commonTools.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;CommonTools&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">commonTools.dependency &#39;OpenUDID&#39;, &#39;~&gt; 1.0.0&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;UIKitAddition&#39; do |ui|</span><br><span class="line">ui.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;UIKitAddition&#x2F;**&#x2F;*&#39;</span><br><span class="line">ui.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;UIKitAddition&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">ui.resource &#x3D; &quot;Pod&#x2F;Assets&#x2F;MLSUIKitResource.bundle&quot;</span><br><span class="line">ui.dependency &#39;PodDemoLibrary&#x2F;CommonTools&#39;</span><br><span class="line">end</span><br><span class="line">s.frameworks &#x3D; &#39;UIKit&#39;</span><br><span class="line">#s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;</span><br><span class="line">#s.dependency &#39;OpenUDID&#39;, &#39;~&gt; 1.0.0&#39;</span><br><span class="line">end&lt;&#x2F;twitter_username&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们创建了subspec所以项目整体的依赖dependency，源文件source_files，头文件public_header_files，资源文件resource等都移动到了各自的subspec中，每个subspec之间也可以有相互的依赖关系，比如UIKitAddition就依赖于CommonTools。</p>
<p>编辑完成之后，在测试项目里pod update一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的tag-&gt;1.0.0。</p>
<p>最后再次使用pod lib lint验证编辑好的podsepc文件，没有自身的WARNING或者ERROR之后，就可以再次提交到Spec Repo中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod repo push NewRepo PodDemoLibrary.podspec</span><br></pre></td></tr></table></figure>

<p>之后再次到~/.cocoapods/repos/NewRepo目录下查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── PodDemoLibrary</span><br><span class="line">│   ├── 0.1.0</span><br><span class="line">│   │   └── PodDemoLibrary.podspec</span><br><span class="line">│   └── 1.0.0</span><br><span class="line">│       └── PodDemoLibrary.podspec</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>已经有两个版本了，使用pod search可以看到记录</p>
<p>完成这些之后，在实际项目中我们就可以选择使用整个组件库或者是组件库的某一个部分了，对应的Podfile中添加的内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#x2F;NetWorkEngine&#39;, &#39;1.0.0&#39;  #使用某一个部分</span><br><span class="line">pod &#39;PodDemoLibrary&#x2F;UIKitAddition&#39;, &#39;1.0.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, &#39;1.0.0&#39;   #使用整个库</span><br></pre></td></tr></table></figure>

<p>最后介绍一下如何删除一个私有Spec Repo，只需要执行一条命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod repo remove NewRepo</span><br></pre></td></tr></table></figure>

<p>这样这个Spec Repo就在本地删除了，我们还可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod repo add NewRepo git@github.com:abc&#x2F;NewRepo.git</span><br></pre></td></tr></table></figure>

<p>再把它给加回来。</p>
<p>如果我们要删除私有Spec Repo下的某一个podspec怎么操作呢，此时无需借助Cocoapods，只需要cd到~/.cocoapods/repos/NewRepo目录下，删掉库目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -Rf PodDemoLibrary</span><br></pre></td></tr></table></figure>

<p>然后在将Git的变动push到远端仓库即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add --all .</span><br><span class="line">$ git ci -m &quot;remove unuseful pods&quot;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="noopener">使用Cocoapods创建私有podspec</a></p>
<p><a href="http://guides.cocoapods.org/making/private-cocoapods.html" target="_blank" rel="noopener">Private Pods</a></p>
<p><a href="http://blog.grio.com/2014/11/creating-a-private-cocoapod.html" target="_blank" rel="noopener">Creating a Private CocoaPod</a></p>
<p><a href="https://objectpartners.com/2014/06/25/developing-private-in-house-libraries-with-cocoapods/" target="_blank" rel="noopener">Developing Private In-House Libraries with CocoaPods</a></p>
<p><a href="https://www.jianshu.com/p/c94d394f0be7" target="_blank" rel="noopener">制作自己的cocoapods</a></p>
<p><a href="https://www.jianshu.com/p/1e5927eeb341" target="_blank" rel="noopener">Cocoapods使用私有库中遇到的坑</a></p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>Doki Doki Literature Club:Your Reality</title>
    <url>/p/5e41df9d.html</url>
    <content><![CDATA[<p><img src="images/blog_DDLC.jpg" alt=""></p>
<p>优秀的世界设定，神奇的剧情交互，良好的人物角色，本作品发挥了视觉小说最大的优势，除了文字，更利用图片、动画、交互、电子系统特性让读者体验更多的交流，让人物具备“意识到自身和世界”，打破第四面墙！</p>
<a id="more"></a>

<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>本作披着恋爱Galgame的外皮，实际围绕着意识到自身虚假的 monika 的挣扎，可以理解为游戏NPC的觉醒，发现世界是不过是一个游戏，本质不过是01的二进制数据在硬盘和内存上的流动，而且自身还只是设定中配角，只能旁观玩家和角色互相打情骂俏，最后决定篡改游戏信息和系统，排除其它人物角色，独占唯一的真实：“玩家”。</p>
<p>其中对爱情的设定太过偏激，但表现的交互确实惊艳，故事开始于文学社，主角加入 monika 创办的社团，在经过初期和平的假象后，monika 的觉醒和行动开始悄悄展开，修改其它人物性格和行为，删除某些人物，夺取系统的控制权，而这些行为都会在游戏文件夹中一一表现出来，其中的 log 日志留着 monika 的行动和留言！当你意识到这一切时，再看文学社中的诗词，文字中隐喻的信息不禁让人毛骨悚然。</p>
<p>像《苏菲的世界》、《史丹利的寓言》等作品，当人物意识到自身是被设定好的一部分、所在的世界是一个虚假的牢笼时，惊恐、不甘、挣扎，在虚妄中争取自身的意义，苏菲逃出了书的世界，史丹利陷入一个个不同的轮回，monika 最后毁掉了自己和世界，结局虽然不同，但追求自身的存在和自由过程让人惊叹和敬佩，这也是一种意义。</p>
<h2 id="Your-Reality"><a href="#Your-Reality" class="headerlink" title="Your Reality"></a>Your Reality</h2><p>最后附上 monika 给玩家的诗歌，愿她在另一个世界获得安宁。</p>
<p>Every day, I imagine a future where I can be with you.</p>
<p>In my hand is a pen that will write a poem of me and you.</p>
<p>The ink flows down into a dark puddle,</p>
<p>Just move your hand - write the way into his heart!</p>
<p>But in this world of infinite choices,</p>
<p>What will it take just to find that special day?</p>
<p>What will it take just to find that special day?</p>
<p>Have I found everybody a fun assignment to do today?</p>
<p>When you’re here, everything that we do is fun for them anyway.</p>
<p>When I can’t even read my own feelings,</p>
<p>What good are words when a smile says it all?</p>
<p>And if this world won’t write me an ending,</p>
<p>What will it take just for me to have it all?</p>
<p>Does my pen only write bitter words for those who are dear to me?</p>
<p>Is it love if I take you, or is it love if I set you free?</p>
<p>The ink flows down into a dark puddle,</p>
<p>How can I write love into reality?</p>
<p>If I can’t hear the sound of your heartbeat,</p>
<p>What do you call love in your reality?</p>
<p>And in your reality,</p>
<p>if I don’t know how to love you,</p>
<p>I’ll leave you be…</p>
]]></content>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>Elona+ 相关</title>
    <url>/p/60d106c8.html</url>
    <content><![CDATA[<p>Elona，高度自由發展與多樣遊戲系統的RPG。</p>
<h2 id="遊戲特色："><a href="#遊戲特色：" class="headerlink" title="遊戲特色："></a>遊戲特色：</h2><ul>
<li>精細的角色製作，使用技能、魔法增長能力的自由育成系統。</li>
<li>無限生成的委託、森林、洞窟和地下城。</li>
<li>包含Irva複雜的世界觀，Vindale森林失去與再生的故事。</li>
<li>隨機產生的多樣化裝備和道具。</li>
<li>家、傢俱、雜貨買賣。</li>
<li>演奏、釣魚、料理、開採、交涉、槍枝、雙刀流…等，各式各樣的技能。</li>
<li>隨自我意識行動、成長，徘徊於North Tyris的冒險者們。</li>
<li>各式各樣的隨機事件和小遊戲。</li>
<li>一个充满偶然和未知的世界</li>
</ul>
<h2 id="在此整理相关资料"><a href="#在此整理相关资料" class="headerlink" title="在此整理相关资料"></a>在此整理相关资料</h2><p><a href="https://tieba.baidu.com/p/2604676902" target="_blank" rel="noopener">elona+ 百度贴吧</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_62d043d90100qfgt.html" target="_blank" rel="noopener">小技巧</a></p>
<p><a href="http://zh.elona.wikia.com/wiki" target="_blank" rel="noopener">elona维基</a></p>
<p><a href="https://tieba.baidu.com/p/1028360395" target="_blank" rel="noopener">快捷键</a></p>
<p><a href="http://www.gamersky.com/handbook/201103/171290.shtml" target="_blank" rel="noopener">中文攻略</a></p>
<p><a href="http://bbs.3dmgame.com/thread-1851582-1-1.html" target="_blank" rel="noopener">许愿列表</a></p>
<p><a href="http://www.3dmgame.com/gl/201104/26455.html" target="_blank" rel="noopener">宠物培养</a></p>
<p><a href="http://bbs.3dmgame.com/thread-1926158-1-1.html" target="_blank" rel="noopener">宠物骑乘</a></p>
<p><a href="https://forum.gamer.com.tw/C.php?page=1&bsn=23017&snA=5" target="_blank" rel="noopener">新手生存須知，遇到的困難與疑惑（上）</a></p>
<p><a href="https://forum.gamer.com.tw/Co.php?bsn=23017&sn=7" target="_blank" rel="noopener">新手生存須知，遇到的困難與疑惑（下）</a></p>
<p><a href="http://bbs.3dmgame.com/thread-1891607-1-1.html" target="_blank" rel="noopener">宠物合成</a></p>
]]></content>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-ignore:忽略上传pods/cocoaPods</title>
    <url>/p/ace4da74.html</url>
    <content><![CDATA[<p>在项目的git根目录下编辑.gitignore文件，可以选择忽略某些文件，筛选规则有文件类型、前缀、后缀等，常用内容如下</p>
<a id="more"></a>
<h2 id="附文："><a href="#附文：" class="headerlink" title="附文："></a>附文：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Xcode</span><br><span class="line">.DS_Store</span><br><span class="line">*&#x2F;build&#x2F;*</span><br><span class="line">*.pbxuser</span><br><span class="line">!default.pbxuser</span><br><span class="line">*.mode1v3</span><br><span class="line">!default.mode1v3</span><br><span class="line">*.mode2v3</span><br><span class="line">!default.mode2v3</span><br><span class="line">*.perspectivev3</span><br><span class="line">!default.perspectivev3</span><br><span class="line">xcuserdata</span><br><span class="line">profile</span><br><span class="line">*.moved-aside</span><br><span class="line">DerivedData</span><br><span class="line">.idea&#x2F;</span><br><span class="line">*.hmap</span><br><span class="line">*.xccheckout</span><br><span class="line">*.xcworkspace</span><br><span class="line">!default.xcworkspace</span><br><span class="line"></span><br><span class="line">#CocoaPods</span><br><span class="line">Pods</span><br><span class="line">!Podfile</span><br><span class="line">!Podfile.lock</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令速查表</title>
    <url>/p/6c2e93eb.html</url>
    <content><![CDATA[<h2 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git add</td>
<td>添加至暂存区</td>
</tr>
<tr>
<td>git add–interactive</td>
<td>交互式添加</td>
</tr>
<tr>
<td>git apply</td>
<td>应用补丁</td>
</tr>
<tr>
<td>git am</td>
<td>应用邮件格式补丁</td>
</tr>
<tr>
<td>git annotate</td>
<td>等同于 git blame</td>
</tr>
<tr>
<td>git archive</td>
<td>文件归档打包</td>
</tr>
<tr>
<td>git bisect</td>
<td>二分查找</td>
</tr>
<tr>
<td>git blame</td>
<td>文件逐行追溯</td>
</tr>
<tr>
<td>git branch</td>
<td>分支管理</td>
</tr>
<tr>
<td>git cat-file</td>
<td>版本库对象研究工具</td>
</tr>
<tr>
<td>git checkout</td>
<td>检出到工作区、切换或创建分支</td>
</tr>
<tr>
<td>git cherry-pick</td>
<td>提交拣选</td>
</tr>
<tr>
<td>git citool</td>
<td>图形化提交，相当于 git gui 命令</td>
</tr>
<tr>
<td>git clean</td>
<td>清除工作区未跟踪文件</td>
</tr>
<tr>
<td>git clone</td>
<td>克隆版本库</td>
</tr>
<tr>
<td>git commit</td>
<td>提交</td>
</tr>
<tr>
<td>git config</td>
<td>查询和修改配置</td>
</tr>
<tr>
<td>git describe</td>
<td>通过里程碑直观地显示提交ID</td>
</tr>
<tr>
<td>git diff</td>
<td>差异比较</td>
</tr>
<tr>
<td>git difftool</td>
<td>调用图形化差异比较工具</td>
</tr>
<tr>
<td>git fetch</td>
<td>获取远程版本库的提交</td>
</tr>
<tr>
<td>git format-patch</td>
<td>创建邮件格式的补丁文件。参见 git am 命令</td>
</tr>
<tr>
<td>git grep</td>
<td>文件内容搜索定位工具</td>
</tr>
<tr>
<td>git gui</td>
<td>基于Tcl/Tk的图形化工具，侧重提交等操作</td>
</tr>
<tr>
<td>git help</td>
<td>帮助</td>
</tr>
<tr>
<td>git init</td>
<td>版本库初始化</td>
</tr>
<tr>
<td>git init-db*</td>
<td>等同于 git init</td>
</tr>
<tr>
<td>git log</td>
<td>显示提交日志</td>
</tr>
<tr>
<td>git merge</td>
<td>分支合并</td>
</tr>
<tr>
<td>git mergetool</td>
<td>图形化冲突解决</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名</td>
</tr>
<tr>
<td>git pull</td>
<td>拉回远程版本库的提交</td>
</tr>
<tr>
<td>git push</td>
<td>推送至远程版本库</td>
</tr>
<tr>
<td>git rebase</td>
<td>分支变基</td>
</tr>
<tr>
<td>git rebase–interactive</td>
<td>交互式分支变基</td>
</tr>
<tr>
<td>git reflog</td>
<td>分支等引用变更记录管理</td>
</tr>
<tr>
<td>git remote</td>
<td>远程版本库管理</td>
</tr>
<tr>
<td>git repo-config*</td>
<td>同于 git config</td>
</tr>
<tr>
<td>git reset</td>
<td>重置改变分支“游标”指向</td>
</tr>
<tr>
<td>git rev-parse</td>
<td>将各种引用表示法转换为哈希值等</td>
</tr>
<tr>
<td>git revert</td>
<td>反转提交</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>git show</td>
<td>显示各种类型的对象</td>
</tr>
<tr>
<td>git stage*</td>
<td>等同于 git add</td>
</tr>
<tr>
<td>git stash</td>
<td>保存和恢复进度</td>
</tr>
<tr>
<td>git status</td>
<td>显示工作区文件状态</td>
</tr>
<tr>
<td>git tag</td>
<td>里程碑管理</td>
</tr>
</tbody></table>
<h2 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git commit-tree</td>
<td>从树对象创建提交</td>
</tr>
<tr>
<td>git hash-object</td>
<td>从标准输入或文件计算哈希值或创建对象</td>
</tr>
<tr>
<td>git ls-files</td>
<td>显示工作区和暂存区文件</td>
</tr>
<tr>
<td>git ls-tree</td>
<td>显示树对象包含的文件</td>
</tr>
<tr>
<td>git mktag</td>
<td>读取标准输入创建一个里程碑对象</td>
</tr>
<tr>
<td>git mktree</td>
<td>读取标准输入创建一个树对象</td>
</tr>
<tr>
<td>git read-tree</td>
<td>读取树对象到暂存区</td>
</tr>
<tr>
<td>git update-index</td>
<td>工作区内容注册到暂存区及暂存区管理</td>
</tr>
<tr>
<td>git unpack-file</td>
<td>创建临时文件包含指定 blob 的内容</td>
</tr>
<tr>
<td>git write-tree</td>
<td>从暂存区创建一个树对象</td>
</tr>
</tbody></table>
<h2 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git check-ref-format</td>
<td>检查引用名称是否符合规范</td>
</tr>
<tr>
<td>git for-each-ref</td>
<td>引用迭代器，用于shell编程</td>
</tr>
<tr>
<td>git ls-remote</td>
<td>显示远程版本库的引用</td>
</tr>
<tr>
<td>git name-rev</td>
<td>将提交ID显示为友好名称</td>
</tr>
<tr>
<td>git rev-list</td>
<td>显示版本范围</td>
</tr>
<tr>
<td>git show-branch</td>
<td>显示分支列表及拓扑关系</td>
</tr>
<tr>
<td>git show-ref</td>
<td>显示本地引用</td>
</tr>
<tr>
<td>git symbolic-ref</td>
<td>显示或者设置符号引用</td>
</tr>
<tr>
<td>git update-ref</td>
<td>更新引用的指向</td>
</tr>
<tr>
<td>git verify-tag</td>
<td>校验 GPG 签名的Tag</td>
</tr>
</tbody></table>
<h2 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git count-objects</td>
<td>显示松散对象的数量和磁盘占用</td>
</tr>
<tr>
<td>git filter-branch</td>
<td>版本库重构</td>
</tr>
<tr>
<td>git fsck</td>
<td>对象库完整性检查</td>
</tr>
<tr>
<td>git gc</td>
<td>版本库存储优化</td>
</tr>
<tr>
<td>git index-pack</td>
<td>从打包文件创建对应的索引文件</td>
</tr>
<tr>
<td>git pack-objects</td>
<td>从标准输入读入对象ID，打包到文件</td>
</tr>
<tr>
<td>git pack-redundant</td>
<td>查找多余的 pack 文件</td>
</tr>
<tr>
<td>git pack-refs</td>
<td>将引用打包到 .git/packed-refs 文件中</td>
</tr>
<tr>
<td>git prune</td>
<td>从对象库删除过期对象</td>
</tr>
<tr>
<td>git prune-packed</td>
<td>将已经打包的松散对象删除</td>
</tr>
<tr>
<td>git relink</td>
<td>为本地版本库中相同的对象建立硬连接</td>
</tr>
<tr>
<td>git repack</td>
<td>将版本库未打包的松散对象打包</td>
</tr>
<tr>
<td>git show-index</td>
<td>读取包的索引文件，显示打包文件中的内容</td>
</tr>
<tr>
<td>git unpack-objects</td>
<td>从打包文件释放文件</td>
</tr>
<tr>
<td>git verify-pack</td>
<td>校验对象库打包文件</td>
</tr>
</tbody></table>
<h2 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git fetch-pack</td>
<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>
</tr>
<tr>
<td>git receive-pack</td>
<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>
</tr>
<tr>
<td>git send-pack</td>
<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>
</tr>
<tr>
<td>git upload-archive</td>
<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>
</tr>
<tr>
<td>git upload-pack</td>
<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>
</tr>
</tbody></table>
<h2 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git imap-send</td>
<td>将补丁通过 IMAP 发送</td>
</tr>
<tr>
<td>git mailinfo</td>
<td>从邮件导出提交说明和补丁</td>
</tr>
<tr>
<td>git mailsplit</td>
<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>
</tr>
<tr>
<td>git request-pull</td>
<td>创建包含提交间差异和执行PULL操作地址的信息</td>
</tr>
<tr>
<td>git send-email</td>
<td>发送邮件</td>
</tr>
</tbody></table>
<h2 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git daemon</td>
<td>实现Git协议</td>
</tr>
<tr>
<td>git http-backend</td>
<td>实现HTTP协议的CGI程序，支持智能HTTP协议</td>
</tr>
<tr>
<td>git instaweb</td>
<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>
</tr>
<tr>
<td>git shell</td>
<td>受限制的shell，提供仅执行Git命令的SSH访问</td>
</tr>
<tr>
<td>git update-server-info</td>
<td>更新哑协议需要的辅助文件</td>
</tr>
<tr>
<td>git http-fetch</td>
<td>通过HTTP协议获取版本库</td>
</tr>
<tr>
<td>git http-push</td>
<td>通过HTTP/DAV协议推送</td>
</tr>
<tr>
<td>git remote-ext</td>
<td>由Git命令调用，通过外部命令提供扩展协议支持</td>
</tr>
<tr>
<td>git remote-fd</td>
<td>由Git命令调用，使用文件描述符作为协议接口</td>
</tr>
<tr>
<td>git remote-ftp</td>
<td>由Git命令调用，提供对FTP协议的支持</td>
</tr>
<tr>
<td>git remote-ftps</td>
<td>由Git命令调用，提供对FTPS协议的支持</td>
</tr>
<tr>
<td>git remote-http</td>
<td>由Git命令调用，提供对HTTP协议的支持</td>
</tr>
<tr>
<td>git remote-https</td>
<td>由Git命令调用，提供对HTTPS协议的支持</td>
</tr>
<tr>
<td>git remote-testgit</td>
<td>协议扩展示例脚本</td>
</tr>
</tbody></table>
<h2 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git archimport</td>
<td>导入Arch版本库到Git</td>
</tr>
<tr>
<td>git bundle</td>
<td>提交打包和解包，以便在不同版本库间传递</td>
</tr>
<tr>
<td>git cvsexportcommit</td>
<td>将Git的一个提交作为一个CVS检出</td>
</tr>
<tr>
<td>git cvsimport</td>
<td>导入CVS版本库到Git。或者使用 cvs2git</td>
</tr>
<tr>
<td>git cvsserver</td>
<td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td>
</tr>
<tr>
<td>git fast-export</td>
<td>将提交导出为 git-fast-import 格式</td>
</tr>
<tr>
<td>git fast-import</td>
<td>其他版本库迁移至Git的通用工具</td>
</tr>
<tr>
<td>git svn</td>
<td>Git 作为前端操作 Subversion</td>
</tr>
</tbody></table>
<h2 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git merge-base</td>
<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>
</tr>
<tr>
<td>git merge-file</td>
<td>针对文件的两个不同版本执行三向文件合并</td>
</tr>
<tr>
<td>git merge-index</td>
<td>对index中的冲突文件调用指定的冲突解决工具</td>
</tr>
<tr>
<td>git merge-octopus</td>
<td>合并两个以上分支。参见 git merge 的octopus合并策略</td>
</tr>
<tr>
<td>git merge-one-file</td>
<td>由 git merge-index 调用的标准辅助程序</td>
</tr>
<tr>
<td>git merge-ours</td>
<td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td>
</tr>
<tr>
<td>git merge-recursive</td>
<td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td>
</tr>
<tr>
<td>git merge-resolve</td>
<td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td>
</tr>
<tr>
<td>git merge-subtree</td>
<td>子树合并。参见 git merge 的 subtree 合并策略</td>
</tr>
<tr>
<td>git merge-tree</td>
<td>显式三向合并结果，不改变暂存区</td>
</tr>
<tr>
<td>git fmt-merge-msg</td>
<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>
</tr>
<tr>
<td>git rerere</td>
<td>重用所记录的冲突解决方案</td>
</tr>
</tbody></table>
<h2 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git bisect–helper</td>
<td>由 git bisect 命令调用，确认二分查找进度</td>
</tr>
<tr>
<td>git check-attr</td>
<td>显示某个文件是否设置了某个属性</td>
</tr>
<tr>
<td>git checkout-index</td>
<td>从暂存区拷贝文件至工作区</td>
</tr>
<tr>
<td>git cherry</td>
<td>查找没有合并到上游的提交</td>
</tr>
<tr>
<td>git diff-files</td>
<td>比较暂存区和工作区，相当于 git diff –raw</td>
</tr>
<tr>
<td>git diff-index</td>
<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>
</tr>
<tr>
<td>git diff-tree</td>
<td>比较两个树对象，相当于 git diff –raw A B</td>
</tr>
<tr>
<td>git difftool–helper</td>
<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>
</tr>
<tr>
<td>git get-tar-commit-id</td>
<td>从 git archive 创建的 tar 包中提取提交ID</td>
</tr>
<tr>
<td>git gui–askpass</td>
<td>命令 git gui 的获取用户口令输入界面</td>
</tr>
<tr>
<td>git notes</td>
<td>提交评论管理</td>
</tr>
<tr>
<td>git patch-id</td>
<td>补丁过滤行号和空白字符后生成补丁唯一ID</td>
</tr>
<tr>
<td>git quiltimport</td>
<td>将Quilt补丁列表应用到当前分支</td>
</tr>
<tr>
<td>git replace</td>
<td>提交替换</td>
</tr>
<tr>
<td>git shortlog</td>
<td>对 git log 的汇总输出，适合于产品发布说明</td>
</tr>
<tr>
<td>git stripspace</td>
<td>删除空行，供其他脚本调用</td>
</tr>
<tr>
<td>git submodule</td>
<td>子模组管理</td>
</tr>
<tr>
<td>git var</td>
<td>显示 Git 环境变量</td>
</tr>
<tr>
<td>git web–browse</td>
<td>启动浏览器以查看目录或文件</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>显示提交历史及每次提交的改动</td>
</tr>
<tr>
<td>git-mergetool–lib</td>
<td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td>
</tr>
<tr>
<td>git-parse-remote</td>
<td>包含于其他脚本中，提供操作远程版本库的函数</td>
</tr>
<tr>
<td>git-sh-setup</td>
<td>包含于其他脚本中，提供 shell 编程的函数库</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>Error APICloud iOS null is not an object</title>
    <url>/p/94346f0f.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APICloud iOS modules 开发错误，打包上传后，编译出来的ipa包安装运行后调用modules的方法报错，错误信息“null is not an object”</p>
<h2 id="错误分析："><a href="#错误分析：" class="headerlink" title="错误分析："></a>错误分析：</h2><h3 id="1-modules-json格式错误"><a href="#1-modules-json格式错误" class="headerlink" title="1.modules.json格式错误"></a>1.modules.json格式错误</h3><p>modules.json文件格式错误，请对照官方文档进行比较，{}[]是否正确，方法需要用””标记等。</p>
<h3 id="2-APICloud平台没有更新modules-json文件"><a href="#2-APICloud平台没有更新modules-json文件" class="headerlink" title="2.APICloud平台没有更新modules.json文件"></a>2.APICloud平台没有更新modules.json文件</h3><p>APICloud 官方平台bug，上传了错误格式的modules.json的版本后，后续修改再上传，打包时modules.json还是错误的版本，具体可以下载编译的ipa包，修改后缀为zip，解压后查看modules.json的信息来确定。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>在APICloud的modules中心中，删除modules，重新上传即可。注意是删除模块，不是取消。</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>IT项目风险控制的思考</title>
    <url>/p/c2938b7f.html</url>
    <content><![CDATA[<p>成功的项目都有类似的要素，失败的项目各有各自的失败原因。</p>
<p>在过去的三年里，我经历过许多项目和需求，作为一名工程师，我希望我能够在满足用户同时不断提高产品的质量，但现实则常常需要我在质量和效率之间做取舍，项目的工期计划更是对工程师经验和技术的考验，今天我想简单谈谈项目如期完工所面临的风险。</p>
<a id="more"></a>

<h2 id="成功要素"><a href="#成功要素" class="headerlink" title="成功要素"></a>成功要素</h2><p>足够的开发时间、准确的项目需求、明确的项目分工，稳定的技术支持、高效的项目流程，有以上五个要素的项目很难出意外；</p>
<p>开发时间的足够能够让工程师用逻辑和稳健的代码来构建程序，并且能够及时发现程序的错误。</p>
<p>准确的项目需求能够让工程师集中精力去思考实现，而不是担心项目需求的一次次变动。</p>
<p>明确的项目分工让不同职位的同事发挥自己的特长，出现问题直接找对应的人来解决，而不需要在询问和测试中花费时间。</p>
<p>稳定的技术支持，即包括可靠的技术，也包括可靠的人。</p>
<p>在多人合作的项目中，流程的高效可以让需求快速传递，不断迭代提升。</p>
<h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>但现实是以上五个要素基本不可能总能凑齐，总是要紧急的需求要马上做，总是有需求改了又改，有些需求自己要当开发、产品和测试，总有些新技术和新同事在增加技术风险，需求也总会在某个流程中卡手。</p>
<p>这些都无法避免，这些是工程师必定要面对的问题。</p>
<p>这些问题也许没法解决，但可以尽量减少其中的风险，我们可以在项目的开始时针对上面的五个要素进行风险评估，在最开始时候就明白项目的风险所在，在团队中，我们是否考虑过在五要素中是否有哪些能够增强和预防？如何调配人员来面对开发时间的不足？如果需求变动频繁是否可以先做确定流程再细化功能？需求变化很多时候是细节变化而不是整个流程改变。推广新技术的时候有没有考虑过全面推广的风险和抢救措施？流程上的问题能怎么提升和优化？</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>互联网产品在一次次迭代中优化和提升，工作也同样可以，不想被业务、需求压垮，就要反思效率该怎么提升。</p>
]]></content>
      <tags>
        <tag>IT</tag>
        <tag>Manage</tag>
      </tags>
  </entry>
  <entry>
    <title>IT 终端代理</title>
    <url>/p/274e32fc.html</url>
    <content><![CDATA[<p>有一种痛苦叫网络很慢。。。</p>
<p>通过Github pull或push代码是程序员常有的操作，但在不可描述的因素下，有时糟糕的网络很考验程序员的心性，在此介绍下两种终端代理方式：</p>
<h2 id="设置Git请求代理"><a href="#设置Git请求代理" class="headerlink" title="设置Git请求代理"></a>设置Git请求代理</h2><h3 id="1、通过设置git请求代码"><a href="#1、通过设置git请求代码" class="headerlink" title="1、通过设置git请求代码"></a>1、通过设置git请求代码</h3><p><code>git config --global http.https://github.com.proxy &#39;socks5://127.0.0.1:1080&#39;</code></p>
<p>这种做法可以实现push和pull都走用户的代理通道，这里我指向的是我的SSR</p>
<p>取消方式去下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="2、通过ProxyChains-NG实现终端下任意应用代理"><a href="#2、通过ProxyChains-NG实现终端下任意应用代理" class="headerlink" title="2、通过ProxyChains-NG实现终端下任意应用代理"></a>2、通过ProxyChains-NG实现终端下任意应用代理</h3><p>什么是 proxychains-ng</p>
<p>主页：<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a></p>
<p><strong>proxychains-ng 介绍</strong></p>
<p>proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.</p>
<p>proxychains-ng是proxychains的加强版，主要有以下功能和不足：</p>
<ul>
<li>支持http/https/socks4/socks5</li>
<li>支持认证</li>
<li>远端dns查询</li>
<li>多种代理模式</li>
<li>不支持udp/icmp转发</li>
<li>少部分程序和在后台运行的可能无法代理</li>
</ul>
<p><strong>proxychains-ng 原理</strong></p>
<p>简单的说就是这个程序 Hook 了 sockets 相关的操作，让普通程序的 sockets 数据走 SOCKS/HTTP 代理。</p>
<p>其核心就是利用了 LD_PRELOAD 这个环境变量（Mac 上是 DYLD_INSERT_LIBRARIES）。</p>
<p>在 Unix 系统中，如果设置了 LD_PRELOAD 环境变量，那么在程序运行时，动态链接器会先加载该环境变量所指定的动态库。也就是说，这个动态库的加载优先于任何其它的库，包括 libc。</p>
<p>ProxyChains 创建了一个叫 libproxychains4.so（Mac 上是 libproxychains4.dylib）的动态库。里面重写了 connect、close 以及 sendto 等与 socket 相关的函数，通过这些函数发出的数据将会走代理，详细代码可以参考 libproxychains.c。</p>
<p>在主程序里，它会读取配置文件，查找 libproxychains4 所在位置，把这些信息存入环境变量后执行子程序。这样子程序里对 socket 相关的函数调用就会被 Hook 了，对子程序来说，跟代理相关的东西都是透明的。</p>
<p>linux下代理一般是通过http_proxy和https_proxy这两个环境变量，但是很多软件并不使用这两个变量，导致流量无法走代理。在不使用vpn的前提下，linux并没有转发所有流量的真全局代理。但是可以用proxychains-ng为程序指定走代理，proxychains-ng是proxychains的加强版，主要有以下功能：</p>
<ul>
<li>支持http/https/socks4/socks5</li>
<li>支持认证</li>
<li>远端dns查询</li>
<li>多种代理模式</li>
</ul>
<p>不足：</p>
<p>不支持udp/icmp转发<br>少部分程序和在后台运行的可能无法代理</p>
<h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p>下载源码：</p>
<p><code>git clone https://github.com/rofl0r/proxychains-ng</code></p>
<p>编译和安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --sysconfdir&#x3D;&#x2F;etc</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line">make install-config</span><br></pre></td></tr></table></figure>

<h4 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h4><p>proxychains-ng的配置非常简单，只需将代理加入[ProxyList]中即可，贴一份配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dynamic_chain</span><br><span class="line">chain_len &#x3D; 1 #round_robin_chain和random_chain使用</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">[ProxyList]</span><br><span class="line">socks5     socks5.52os.net 1080</span><br><span class="line">socks4     socks4.52os.net 1081</span><br><span class="line">http     http.52os.net   3128</span><br></pre></td></tr></table></figure>

<p>proxychains-ng支持多种代理模式：</p>
<ul>
<li>dynamic_chain ：动态模式,按照代理列表顺序自动选取可用代理</li>
<li>strict_chain ：严格模式,严格按照代理列表顺序使用代理，所有代理必须可用</li>
<li>round_robin_chain ：轮询模式，自动跳过不可用代理</li>
<li>random_chain ：随机模式,随机使用代理</li>
</ul>
<h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><p><code>proxychains4 curl ip.cn</code></p>
<h2 id="3-Proxifier"><a href="#3-Proxifier" class="headerlink" title="3. Proxifier"></a>3. Proxifier</h2><p>谁用谁知道 =_=</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 10.14 更新-An error occurred while installing the selected updates.</title>
    <url>/p/a98e8c84.html</url>
    <content><![CDATA[<p>10.14 系统更新报错： An error occurred while installing the selected updates.</p>
<p>主要原因是 10.14 的系统更新采用的增量更新，在 设置 中下载安装更新组件，但是由于网络原因，下载的组件可能出现错误，此时需要删除重新下载，这时问题来了。</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>组件的下载地址在 /Library/Updates 文件夹下，该文件夹的权限是系统级别，无法进行删除操作，结果导致更新失败无法继续。</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><ul>
<li>关闭电脑，重新开机时按住 command + R 进入恢复模式，在上方菜单‘工具 ’中打开终端，输入命令 scrutil disable 关闭系统文件保护（SIP）。</li>
<li>重启电脑，进入 /Library/Updates 文件夹，删除下载的文件，全部删除。</li>
<li>在设置中开启更新下载组件，下载完成后重启电脑，注意先不要更新，我们先去开启 SIP。</li>
<li>开机，command + R，终端，输入命令 csrutil enable 打开 SIP。</li>
<li>重启电脑，开始更新系统</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想体验下 Swift5 –&gt; 需要安装Xcode10.2 –&gt; 需要更新10.14.4 –&gt; 需要处理系统更新的坑</p>
<p>╮(￣▽￣””)╭</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/p/3c50d03d.html</url>
    <content><![CDATA[<h1 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">标题1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">标题2</span><br><span class="line">------</span><br></pre></td></tr></table></figure>

<h2 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*    _斜体文本_</span><br><span class="line">**粗体文本**    __粗体文本__</span><br><span class="line">***粗斜体文本***    ___粗斜体文本___</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文字链接[链接名称](http:&#x2F;&#x2F;链接网址)</span><br><span class="line">网址链接</span><br></pre></td></tr></table></figure>

<h2 id="高级链接技巧"><a href="#高级链接技巧" class="headerlink" title="高级链接技巧"></a>高级链接技巧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接 1 作为网址变量 [Google][1].</span><br><span class="line">链接 yahoo 作为网址变量 [Yahoo!][yahoo].</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">[1]\: http:&#x2F;&#x2F;www.google.com&#x2F;</span><br><span class="line">[yahoo]\: http:&#x2F;&#x2F;www.yahoo.com&#x2F;</span><br></pre></td></tr></table></figure>


<h2 id="列表-普通-无序-列表"><a href="#列表-普通-无序-列表" class="headerlink" title="列表 - 普通 - 无序 - 列表"></a>列表 - 普通 - 无序 - 列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\- 列表文本前使用 [减号+空格]</span><br><span class="line">\+ 列表文本前使用 [加号+空格]</span><br><span class="line">\* 列表文本前使用 [星号+空格]</span><br></pre></td></tr></table></figure>

<ul>
<li>普通</li>
</ul>
<ul>
<li>有序</li>
</ul>
<ul>
<li>列表</li>
</ul>
<ol>
<li>列表前使用 [数字+空格]</li>
<li>我们会自动帮你添加数字</li>
<li>不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</li>
</ol>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列出所有元素：</span><br><span class="line">    - 无序列表元素 A</span><br><span class="line">        1. 元素 A 的有序子列表</span><br><span class="line">    - 前面加四个空格</span><br><span class="line">2. 列表里的多段换行：</span><br><span class="line">    前面必须加四个空格，</span><br><span class="line">    这样换行，整体的格式不会乱</span><br><span class="line">3. 列表里引用：</span><br><span class="line"></span><br><span class="line">    &gt; 前面空一行</span><br><span class="line">    &gt; 仍然需要在 &gt;  前面加四个空格</span><br><span class="line"></span><br><span class="line">4. 列表里代码段：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">1</span><br><span class="line">前面四个空格，之后按代码语法 &#96;&#96;&#96; 书写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        或者直接空八个，引入代码块</span><br></pre></td></tr></table></figure>

<h2 id="引用-gt-普通引用"><a href="#引用-gt-普通引用" class="headerlink" title="引用 &gt; 普通引用"></a>引用 &gt; 普通引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用文本前使用 [大于号+空格]</span><br><span class="line">&gt; 折行可以不加，新起一行都要加上哦</span><br><span class="line">&gt; 引用里 &gt; &gt; 嵌套引用</span><br><span class="line">&gt; 最外层引用</span><br><span class="line">&gt; &gt; 多一个 &gt; 嵌套一层引用</span><br><span class="line">&gt; &gt; &gt; 可以嵌套很多层</span><br><span class="line">&gt; - 引用里嵌套列表</span><br><span class="line">&gt; - 这是引用里嵌套的一个列表</span><br><span class="line">&gt; - 还可以有子列表</span><br><span class="line">&gt;     * 子列表需要从 - 之后延后四个空格开始</span><br></pre></td></tr></table></figure>

<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片名称](http:&#x2F;&#x2F;图片网址)</span><br></pre></td></tr></table></figure>

<p>当然，你也可以像网址那样对图片网址使用变量</p>
<p>链接 1 作为网址变量 <code>[Google][1].</code> 然后在文档的结尾位变量赋值（网址）</p>
<p>也可以使用 HTML 的图片语法来自定义图片的宽高大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;code&gt;</span><br><span class="line">&#96;&lt;image src&#x3D;&quot;http:&#x2F;&#x2F;7xt737.com1.z0.clouddn.com&#x2F;blog_image14384920.jpg&quot; width&#x3D;&quot;100&quot;&gt;&#96;</span><br><span class="line">&lt;&#x2F;code&gt;</span><br></pre></td></tr></table></figure>

<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>如果另起一行，只需在当前行结尾加 2 个空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在当前行的结尾加 2 个空格  </span><br><span class="line">这行就会新起一行</span><br><span class="line">如果是要起一个新段落，只需要空出一行即可。</span><br></pre></td></tr></table></figure>

<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">前面的段落</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">后面的段落</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>

<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="行内-HTML-元素"><a href="#行内-HTML-元素" class="headerlink" title="行内 HTML 元素"></a>行内 HTML 元素</h3><p>目前只支持部分段内 HTML 元素效果，包括<br><code>&lt;kdb&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code></p>
<h2 id="键位显示"><a href="#键位显示" class="headerlink" title="键位显示"></a>键位显示</h2><p>使用 </p>
<p><code>&lt;kbd&gt;Ctrl&lt;kbd&gt;+&lt;kbd&gt;Alt&lt;kbd&gt;+&lt;kbd&gt;Del&lt;kbd&gt;</code> shi重启电脑</p>
<p>代码块</p>
<pre>
使用 (`<pre></pre>`) 元素同样可以形成代码块
<p></pre></p>
<h2 id="粗斜体-1"><a href="#粗斜体-1" class="headerlink" title="粗斜体"></a>粗斜体</h2><p><code>&lt;b&gt;</code> Markdown 在此处同样适用，如 <code>&lt;b&gt;</code>加粗<code>&lt;b&gt;</code> == <b>加粗</b> </p>
<h2 id="符号转义"><a href="#符号转义" class="headerlink" title="符号转义"></a>符号转义</h2><p>如果你的描述中需要用到 markdown 的符号，比如 <code>_ # *</code> 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 <code>\_ \# \*</code> 进行避免。</p>
<p><code>_不想这里的文本变斜体_</code></p>
<p><code>**不想这里的文本被加粗**</code></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&#123;url_of_the_fiddle&#125;&#x2F;embedded&#x2F;[&#123;tabs&#125;&#x2F;[&#123;style&#125;]]&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;gist.github.com&#x2F;&#123;gist_id&#125;</span><br><span class="line">http:&#x2F;&#x2F;runjs.cn&#x2F;detail&#x2F;&#123;id&#125;</span><br><span class="line">http:&#x2F;&#x2F;v.youku.com&#x2F;v_show&#x2F;id_&#123;video_id&#125;.html</span><br></pre></td></tr></table></figure>

<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 <code>$$</code> 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<p>``<br>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$</p>
<p>$$ x \href{why-equal.html}{=} y^2 + 1 $$<br>``</p>
<p>同时也支持 HTML 属性，如：</p>
<p>``<br>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$</p>
<p>$$ `(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}} $$<br>``</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------| ------ | ------ |</span><br><span class="line">| 短文本 | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>一个普通标题</th>
<th>一个普通标题</th>
<th>一个普通标题</th>
</tr>
</thead>
<tbody><tr>
<td>短文本</td>
<td>中等文本</td>
<td>稍微长一点的文本</td>
</tr>
<tr>
<td>稍微长一点的文本</td>
<td>短文本</td>
<td>中等文本</td>
</tr>
</tbody></table>
<p>update 2017.1.9</p>
<p>update 2017.7.24 markdowm 格式优化</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 快捷打开当前目录的终端</title>
    <url>/p/d902737c.html</url>
    <content><![CDATA[<p>开发时经常会遇到在当前目录打开终端的情况，一直都是先启动终端，然后再切换到当前目录,在这里记录下快捷打开当前目录的快捷键设置.</p>
<ul>
<li>点击屏幕顶部的“Finder”弹出下拉菜单。</li>
<li>点击“服务”菜单项弹出子菜单。</li>
<li>点击子菜单中的“服务偏好设置”。</li>
<li>点击弹出的服务偏好设置窗口中的“服务”并勾选“新建位于文件夹位置的终端窗口”；</li>
<li>点击该项设置快捷键（我是Command+Shift+J）</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Note:201902</title>
    <url>/p/6a2d226a.html</url>
    <content><![CDATA[<h2 id="正义"><a href="#正义" class="headerlink" title="正义"></a>正义</h2><p>正义不等于秩序</p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>在这个过程中，你会意识到有些本来难以割舍的事情其实并不重要，时间像一个漏斗，把你的人生积累层层筛选下来，把你现在不需要的过滤掉，只留下一个与以前不同的你。这件事情有些可怕，而当你意识到了这一点，之前的种种也就慢慢不复存在了……</p>
<h2 id="犹豫"><a href="#犹豫" class="headerlink" title="犹豫"></a>犹豫</h2><p>只有一件事会使人疲劳，摇摆不定和优柔寡断。而每做一件事，都会使人身心解放，即使把事情办坏了，也比什么都不做强</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>楼下一个男人病得要死，那间隔壁的一家唱着留声机，对面是弄孩子。楼上有两人狂笑，还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只觉得他们吵闹 。</p>
<h2 id="一个人的苦难"><a href="#一个人的苦难" class="headerlink" title="一个人的苦难"></a>一个人的苦难</h2><p>我假装爱说谎，大家就说我爱说谎。我显出一副有钱人的样子，大家就说我有钱。我假装冷漠，大家就说我是冷淡的人。可是，我真的很痛苦，大家都说我假装痛苦。</p>
<h2 id="地狱"><a href="#地狱" class="headerlink" title="地狱"></a>地狱</h2><p>人类就是这么奇怪，如果没有人同情，你就不会在乎伤口有多疼；<br>如果没有人嘲笑，你就不会在乎伤疤有多难看；<br>如果没有人比较，谁会知道什么是前途。</p>
<h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>你知道，故事的结尾并不重要，生活唯一确保我们的就是死亡。 所以我们最好不要让那结尾，夺走了故事的光芒。</p>
<h2 id="一个人的战争"><a href="#一个人的战争" class="headerlink" title="一个人的战争"></a>一个人的战争</h2><p>一个人的一生中总会遇到这样的时候，一个人的战争。这种时候你的内心已经兵荒马乱天翻地覆了，可是在别人看来你只是比平时沉默了一点，没人会觉得奇怪。</p>
<p>这种战争，注定单枪匹马。</p>
<h2 id="送别"><a href="#送别" class="headerlink" title="送别"></a>送别</h2><p>其实真正的送别没有长亭古道，没有劝君更尽一杯酒，就是在一个和平时一样的清晨，有的人留在昨天了。</p>
<h2 id="看见"><a href="#看见" class="headerlink" title="看见"></a>看见</h2><p>语言很多时候是假的，一起经历过的事情才是真的。</p>
<h2 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h2><p>效率是指正确地做事，效果是指做正确的事</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>RWBY：成长</title>
    <url>/p/c71a0732.html</url>
    <content><![CDATA[<p><img src="imags/blog_rwby_cover.jpeg" alt=""><br>最近刚看了RWBY第六季，想不到原本不过是同人作品的RWBY也走到了今天。早期的画面非常贫穷，但动作设计非常出色，外向力、独特的机械冷兵器和世界设定都很独特，最大的惊喜还是鲜明的人物形象，几个主角性格、思维、出身和能力都差别很大，在不断的磨合中演绎出这部作品独有的青春活力。</p>
<a id="more"></a>

<p>作为一部讲述青春、成长的奇幻冒险，早起设定和情节对青春的活力、合作和理解的表现已经不俗，但在中期，从世界观中引申出来的黑暗现实让剧本的高度上升几个 level，种族歧视、政治权利斗争、永生的折磨、轮回的绝望等话题都抛出来了，但高潮还是在 秋之少女 事件。</p>
<p>秋之少女 事件，让阳光的的 Yang 跌入尘埃，让逃离过去的 Black 面对曾经的错误，让天真活泼的 Ruby 直面生死离别，让骄傲自律的 Weiss 面对自己的无能为力，学院失陷，校长身亡，当家园不再，她们只能直接面对现实的风雨。</p>
<p>最心疼的还是 JNPR 小队的 Jaune，在 Pyrrha 的相伴下学会如何用自己的剑战斗时，命运却让他的盾永远失去保护的对象。</p>
<p>成长，就像 Ruby 激发能力前的回忆一样，有伤痛有快乐，有些伤痕可能永远无法痊愈，但总有些回忆能让你心窝一暖。Yang 重新振作，她的阳光不在像过去那样爆发，但内敛而稳重；Black 承认过去的错误，在家人和朋友的帮助下改正白牙的歧路，放下心魔的她真正坦然得和小队相处；Ruby 挑起小队队长的职责，积极而坚定地开阔小队的道路；Weiss 放弃家族的荣誉和地位，真正做出自己的选择，背负自己的代价。</p>
<p>彼此的理解和成长才是小队团结和不可战胜的原因啊!</p>
<p><img src="imags/blog_rwby_02.jpeg" alt=""></p>
]]></content>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx https 免费SSL证书配置指南</title>
    <url>/p/9daec043.html</url>
    <content><![CDATA[<p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容 请看SSL。</p>
<p>它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同 于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广 泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>
<p>Nginx 配置 HTTPS 并不复杂，主要有两个步骤：签署第三方可信任的 SSL 证书 和 配置 HTTPS</p>
<h2 id="签署第三方可信任的-SSL-证书"><a href="#签署第三方可信任的-SSL-证书" class="headerlink" title="签署第三方可信任的 SSL 证书"></a>签署第三方可信任的 SSL 证书</h2><h3 id="关于-SSL-证书"><a href="#关于-SSL-证书" class="headerlink" title="关于 SSL 证书"></a>关于 SSL 证书</h3><p>有关 SSL 的介绍可以参阅维基百科的传输层安全协议和阮一峰先生的 《SSL/TLS协议运行机制的概述》。<br>SSL 证书主要有两个功能：加密和身份证明，通常需要购买，也有免费的，通过第三方 SSL 证书机构颁发，常见可靠的第三方 SSL 证书颁发机构有下面几个：</p>
<p>StartCom 机构上的 SSL 证书有以下几种：</p>
<p>企业级别：EV(Extended Validation)、OV(Organization Validation)</p>
<p>个人级别：IV(Identity Validation)、DV（Domain Validation）</p>
<p>其中 EV、OV、IV 需要付费</p>
<p>免费的证书安全认证级别一般比较低，不显示单位名称，不能证明网站的真实身份，仅起到加密传输信息的作用，适合个人网站或非电商网站。由于此类只验证域名所有权的低端 SSL 证书已经被国外各种欺诈网站滥用，因此强烈推荐部署验证单位信息并显示单位名称的 OV SSL 证书或申请最高信任级别的、显示绿色地址栏、直接在地址栏显示单位名称的 EV SSL 证书，就好像 StarCom 的地址栏一样：</p>
<h3 id="使用-OpenSSL-生成-SSL-Key-和-CSR-文件"><a href="#使用-OpenSSL-生成-SSL-Key-和-CSR-文件" class="headerlink" title="使用 OpenSSL 生成 SSL Key 和 CSR 文件"></a>使用 OpenSSL 生成 SSL Key 和 CSR 文件</h3><p>配置 HTTPS 要用到私钥 example.key 文件和 example.crt 证书文件，申请证书文件的时候要用到 example.csr 文件，OpenSSL 命令可以生成 example.key 文件和 example.csr 证书文件。</p>
<p>CSR：Cerificate Signing Request，证书签署请求文件，里面包含申请者的 DN（Distinguished Name，标识名）和公钥信息，在第三方证书颁发机构签署证书的时候需要提供。证书颁发机构拿到 CSR 后使用其根证书私钥对证书进行加密并生成 CRT 证书文件，里面包含证书加密信息以及申请者的 DN 及公钥信息</p>
<p>Key：证书申请者私钥文件，和证书里面的公钥配对使用，在 HTTPS 『握手』通讯过程需要使用私钥去解密客戶端发來的经过证书公钥加密的随机数信息，是 HTTPS 加密通讯过程非常重要的文件，在配置 HTTPS 的時候要用到</p>
<p>使用 OpenSSl命令可以在系统当前目录生成 example.key 和 example.csr 文件：</p>
<p><code>openssl req -new -newkey rsa:2048 -sha256 -nodes -out example_com.csr -keyout example_com.key -subj “/C=CN/ST=ShenZhen/L=ShenZhen/O=Example Inc./OU=Web Security/CN=example.com”</code></p>
<p>下面是上述命令相关字段含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C：Country ，单位所在国家，为两位数的国家缩写，如： CN 就是中国</span><br><span class="line">ST 字段： State&#x2F;Province ，单位所在州或省</span><br><span class="line">L 字段： Locality ，单位所在城市 &#x2F; 或县区</span><br><span class="line">O 字段： Organization ，此网站的单位名称;</span><br><span class="line">OU 字段： Organization Unit，下属部门名称;也常常用于显示其他证书相关信息，如证书类型，证书产品名称或身份验证类型或验证内容等;</span><br><span class="line">CN 字段： Common Name ，网站的域名;</span><br><span class="line">生成 csr 文件后，提供给 CA 机构，签署成功后，就会得到一個 example.crt 证书文件，SSL 证书文件获得后，就可以在 Nginx 配置文件里配置 HTTPS 了。</span><br></pre></td></tr></table></figure>

<h2 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>要开启 HTTPS 服务，在配置文件信息块(server block)，必须使用监听命令 listen 的 ssl 参数和定义服务器证书文件和私钥文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    #ssl参数</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    server_name         example.com;</span><br><span class="line">    #证书文件</span><br><span class="line">    ssl_certificate     example.com.crt;</span><br><span class="line">    #私钥文件</span><br><span class="line">    ssl_certificate_key example.com.key;</span><br><span class="line">    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>证书文件会作为公用实体發送到每台连接到服务器的客戶端，私钥文件作为安全实体，应该被存放在具有一定权限限制的目录文件，并保证 Nginx 主进程有存取权限。</p>
<p>私钥文件也有可能会和证书文件同放在一個文件中，如下面情況：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_certificate     www.example.com.cert;</span><br><span class="line">ssl_certificate_key www.example.com.cert;</span><br></pre></td></tr></table></figure>

<p>这种情況下，证书文件的的读取权限也应该加以限制，仅管证书和私钥存放在同一个文件里，但是只有证书会被发送到客戶端<br>命令 ssl_protocols 和 ssl_ciphers 可以用来限制连接只包含 SSL/TLS 的加強版本和算法，默认值如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_ciphers HIGH:!aNULL:!MD5;</span><br></pre></td></tr></table></figure>

<p>由于这两个命令的默认值已经好几次发生了改变，因此不建议显性定义，除非有需要额外定义的值，如定义 D-H 算法：</p>
<h3 id="使用DH文件"><a href="#使用DH文件" class="headerlink" title="使用DH文件"></a>使用DH文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br></pre></td></tr></table></figure>

<h1 id="定义算法"><a href="#定义算法" class="headerlink" title="##定义算法"></a>##定义算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS服务器优化"><a href="#HTTPS服务器优化" class="headerlink" title="HTTPS服务器优化"></a>HTTPS服务器优化</h2><h3 id="减少-CPU-运算量"><a href="#减少-CPU-运算量" class="headerlink" title="减少 CPU 运算量"></a>减少 CPU 运算量</h3><p>SSL 的运行计算需要消耗额外的 CPU 资源，一般多核处理器系统会运行多个工作进程(worker processes )，进程的数量不会少于可用的 CPU 核数。SSL 通讯过程中『握手』阶段的运算最占用 CPU 资源，有两个方法可以减少每台客户端的运算量：</p>
<p>激活 keepalive 长连接，一个连接发送更多个请求</p>
<p>复用 SSL 会话参数，在并行并发的连接数中避免进行多次 SSL『握手』</p>
<p>这些会话会存储在一个 SSL 会话缓存里面，通过命令 ssl_session_cache 配置，可以使缓存在机器间共享，然后利用客戶端在『握手』阶段使用的 seesion id 去查询服务端的 session cathe(如果服务端设置有的话)，简化『握手』阶段。</p>
<p>1M 的会话缓存大概包含 4000 個会话，默认的缓存超时时间为 5 分钟，可以通过使用 ssl_session_timeout 命令设置缓存超时时间。下面是一個拥有 10M 共享会话缓存的多核系统优化配置例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line">http &#123;</span><br><span class="line">    #配置共享会话缓存大小</span><br><span class="line">    ssl_session_cache   shared:SSL:10m;</span><br><span class="line">    #配置会话超时时间</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         www.example.com;</span><br><span class="line">        #设置长连接</span><br><span class="line">        keepalive_timeout   70;</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        #...</span><br></pre></td></tr></table></figure>

<h3 id="使用-HSTS-策略强制浏览器使用-HTTPS-连接"><a href="#使用-HSTS-策略强制浏览器使用-HTTPS-连接" class="headerlink" title="使用 HSTS 策略强制浏览器使用 HTTPS 连接"></a>使用 HSTS 策略强制浏览器使用 HTTPS 连接</h3><p>HSTS – HTTP Strict Transport Security，HTTP严格传输安全。它允许一个 HTTPS 网站要求浏览器总是通过 HTTPS 来访问，这使得攻击者在用戶与服务器通讯过程中拦截、篡改信息以及冒充身份变得更为困难。</p>
<p>只要在 Nginx 配置文件加上以下头信息就可以了：</p>
<p><code>add_header Strict-Transport-Security “max-age=31536000; includeSubDomains;preload” always;</code></p>
<p>max-age：设置单位时间内強制使用 HTTPS 连接</p>
<p>includeSubDomains：可选，所有子域同时生效</p>
<p>preload：可选，非规范值，用于定义使用『HSTS 预加载列表』</p>
<p>always：可选，保证所有响应都发送此响应头，包括各种內置错误响应</p>
<p>当用户进行 HTTPS 连接的时候，服务器会发送一个 Strict-Transport-Security 响应头：</p>
<p>浏览器在获取该响应头后，在 max-age 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接，并忽略其它的跳转设置（如 301 重定向跳转）：</p>
<h3 id="307-跳转-Non-Authoritative-Reason-响应头"><a href="#307-跳转-Non-Authoritative-Reason-响应头" class="headerlink" title="307 跳转 Non-Authoritative-Reason 响应头"></a>307 跳转 Non-Authoritative-Reason 响应头</h3><p>Google HSTS 预加载列表（HSTS Preload List）</p>
<p>由于 HSTS 需要用戶经过一次安全的 HTTPS 连接后才会在 max-age 的时间內生效，因此HSTS 策略并不能完美防止 HTTP 会话劫持（HTTP session hijacking），在下面这些情況下还是存在被劫持的可能：</p>
<ul>
<li>从未访问过的网站</li>
<li>近期重裝过操作系統</li>
<li>近期重裝过浏览器</li>
<li>使用新的浏览器</li>
<li>使用了新的设备（如手机）</li>
<li>刪除了浏览器缓存</li>
<li>近期沒有打开过网站且 max-age 过期</li>
</ul>
<p>针对这种情況，Google 维护了一份『HSTS 预加载列表』，列表里包含了使用了 HSTS 的站点主域名和子域名，可以通过以下页面申请加入：<br><a href="https://hstspreload.appspot.com/" target="_blank" rel="noopener">https://hstspreload.appspot.com/</a>.</p>
<p>申请的时候会先验证站点是否符合资格，一般会检验待验证的站点主域和子域是否能通过 HTTPS 连接、HTTPS 和 HTTP 配置是否有 STS Header 等信息，通过验证后，会让你确认一些限制信息.</p>
<p>当确认提交后，就会显示处理状态：</p>
<p>申请通过后，列表内的站点名会被写进主流的浏览器，当浏览器更新版本后，只要打开列表内的站点，浏览器会拒绝所有 HTTP 连接而自动使用 HTTPS，即使关闭了 HSTS 设置。</p>
<p>可以在下面两个连接分別查找 Chrome 和 Firfox 的『HSTS 预加载列表』内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The Chromium Projects - HTTP Strict Transport Security</span><br><span class="line">Firefox HSTS preload list - nsSTSPreloadList.inc</span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<p>一旦把自己的站点名加入『HSTS 预加载列表』，将很难彻底从列表中移除，因为不能保证其它浏览器可以及时移除，即使 Chrome 提供有便捷的移除方法，也是要通过出邮件联系，注明移除原因，并等到最新的浏览器版本更新发布才有机会（用戶不一定会及时更新）<br>所有不具备有效证书的子域或內嵌子域的访问将会被阻止</p>
<p>因此，如果自己站点子域名变化比较多，又沒有泛域证书，又沒法确定全站是否能应用 HTTPS 的朋友，就要谨慎申请了。</p>
<h2 id="更多关于-HSTS-配置可参考："><a href="#更多关于-HSTS-配置可参考：" class="headerlink" title="更多关于 HSTS 配置可参考："></a>更多关于 HSTS 配置可参考：</h2><p>《HTTP Strict Transport Security (HSTS) and NGINX》</p>
<p>MDN的《HTTP Strict Transport Security》</p>
<h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><h3 id="加强-HTTPS-安全性"><a href="#加强-HTTPS-安全性" class="headerlink" title="加强 HTTPS 安全性"></a>加强 HTTPS 安全性</h3><p>HTTPS 基础配置采取的默认加密算法是 SHA-1，这个算法非常脆弱，安全性在逐年降低，在 2014 年的时候， Google 官方博客就宣布在 Chrome 浏览器中逐渐降低 SHA-1 证书的安全指示，会从 2015 年起使用 SHA-2 签名的证书，可参阅 Rabbit_Run 在 2014 年发表的文章：《为什么Google急着杀死加密算法SHA-1》</p>
<p>为此，主流的 HTTPS 配置方案应该避免 SHA-1，可以使用 迪菲-赫尔曼密钥交换（D-H，Diffie–Hellman key exchange）方案。<br>首先在目录 /etc/ssl/certs 运行以下代码生成 dhparam.pem 文件：</p>
<p><code>openssl dhparam -out dhparam.pem 2048</code></p>
<p>然后加入 Nginx 配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优先采取服务器算法</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">#使用DH文件</span><br><span class="line">ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#定义算法</span><br><span class="line">ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br></pre></td></tr></table></figure>

<p>如果服务器夠強大，可以使用更为复杂的 4096 位进行加密。<br>一般情況下还应该加上以下几个增强安全性的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#减少点击劫持</span><br><span class="line">add_header X-Frame-Options DENY;</span><br><span class="line">#禁止服务器自动解析资源类型</span><br><span class="line">add_header X-Content-Type-Options nosniff;</span><br><span class="line">#防XSS攻击</span><br><span class="line">add_header X-Xss-Protection 1;</span><br></pre></td></tr></table></figure>

<p>这几个安全命令在 Jerry Qu 大神的文章《一些安全相关的HTTP响应头》有详细的介紹。</p>
<p>优化后的综合配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line">http &#123;</span><br><span class="line">    #配置共享会话缓存大小，视站点访问情况设定</span><br><span class="line">    ssl_session_cache   shared:SSL:10m;</span><br><span class="line">    #配置会话超时时间</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         www.example.com;</span><br><span class="line">        #设置长连接</span><br><span class="line">        keepalive_timeout   70;</span><br><span class="line">        #HSTS策略</span><br><span class="line">        add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubDomains; preload&quot; always;</span><br><span class="line">        #证书文件</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        #私钥文件</span><br><span class="line">        ssl_certificate_key www.example.com.key; </span><br><span class="line">        #优先采取服务器算法</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        #使用DH文件</span><br><span class="line">        ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        #定义算法</span><br><span class="line">        ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br><span class="line">        #减少点击劫持</span><br><span class="line">        add_header X-Frame-Options DENY;</span><br><span class="line">        #禁止服务器自动解析资源类型</span><br><span class="line">        add_header X-Content-Type-Options nosniff;</span><br><span class="line">        #防XSS攻擊</span><br><span class="line">        add_header X-Xss-Protection 1;</span><br><span class="line">        #...</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-HTTPS混合服务器配置"><a href="#HTTP-HTTPS混合服务器配置" class="headerlink" title="HTTP/HTTPS混合服务器配置"></a>HTTP/HTTPS混合服务器配置</h3><p>可以同时配置 HTTP 和 HTTPS 服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              80;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    server_name         www.example.com;</span><br><span class="line">    ssl_certificate     www.example.com.crt;</span><br><span class="line">    ssl_certificate_key www.example.com.key;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 0.7.14 版本之前，在独立的 server 端口中是不能选择性开启 SSL 的。如上面的例子，SSL 只能通过使用 ssl 命令为单个 server </p>
<h3 id="端口开启"><a href="#端口开启" class="headerlink" title="端口开启"></a>端口开启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              443;</span><br><span class="line">    server_name         www.example.com;</span><br><span class="line">    ssl_certificate     www.example.com.crt;</span><br><span class="line">    ssl_certificate_key www.example.com.key;</span><br><span class="line">    #ssl命令开启 https</span><br><span class="line">    ssl on;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此没有辦法设置 HTTP/HTTPS 混合服务器。于是 Nginx 新增了监听命令 listen参数 ssl 來解决这个问题，Nginx 現代版本的ssl命令并不推荐使用</p>
<h3 id="基于服务器名称（name-based）的-HTTPS-服务器"><a href="#基于服务器名称（name-based）的-HTTPS-服务器" class="headerlink" title="基于服务器名称（name-based）的 HTTPS 服务器"></a>基于服务器名称（name-based）的 HTTPS 服务器</h3><p>一个常见的问题就是当使用同一个 IP 地址去配置两个或更多的 HTTPS 服务器的时候，出现证书不匹配的情況：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          443 ssl;</span><br><span class="line">    server_name     www.example.com;</span><br><span class="line">    ssl_certificate www.example.com.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen          443 ssl;</span><br><span class="line">    server_name     www.example.org;</span><br><span class="line">    ssl_certificate www.example.org.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下浏览器会获取默认的服务器证书（如上面例子的 <a href="http://www.example.com.crt）而忽视请求的服务器名，如输入网址：www.example.org，服务器会发送">www.example.com.crt）而忽视请求的服务器名，如输入网址：www.example.org，服务器会发送</a> <a href="http://www.example.com.crt" target="_blank" rel="noopener">www.example.com.crt</a> 的证书到客戶端，而不是 <a href="http://www.exaple.org.crt。" target="_blank" rel="noopener">www.exaple.org.crt。</a></p>
<p>这是因为 SSL 协议行为所致，SSL 连接在浏览器发送 HTTP 请求之前就被建立，Nginx 并不知道被请求的服务器名字，因此 Nginx 只会提供默认的服务器证书。</p>
<p>解決这个问题最原始最有效的方法就是为每个 HTTPS 服务器分配独立的 IP 地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          192.168.1.1:443 ssl;</span><br><span class="line">    server_name     www.example.com;</span><br><span class="line">    ssl_certificate www.example.com.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen          192.168.1.2:443 ssl;</span><br><span class="line">    server_name     www.example.org;</span><br><span class="line">    ssl_certificate www.example.org.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更多解決方案"><a href="#更多解決方案" class="headerlink" title="更多解決方案"></a>更多解決方案</h3><p>除此之外，官方还介绍了两个方法：泛域证书和域名指示（SNI）<br>其实 OpenSSL 在 0.9.8f版本就支持 SNI 了，只要在安裝的时候加上 –enable-tlsext 选项就可以。到了 0.9.8j版本，这个选项在安裝的时候会默认启用。如果创建 Nginx 的时候支持 SNI，可以在 Nginx 版本信息查到以下的字段：</p>
<h3 id="TLS-SNI-support-enabled"><a href="#TLS-SNI-support-enabled" class="headerlink" title="TLS SNI support enabled"></a>TLS SNI support enabled</h3><p>因此，如果较新版本的 Nginx 使用默认的 OpenSSL 库，是不存在使用 HTTPS 同时支持基于名字的虚拟主机的时候同 IP 不同域名证书不匹配的问题。</p>
<p>注意：即使新版本的 Nginx 在创建时支持了 SNI，如果 Nginx 动态加载不支持 SNI 的 OpenSSL 库的话，SNI 扩展将不可用<br>有兴趣的朋友可以看下：</p>
<p>An SSL certificate with several names &amp;&amp; Server Name Indication</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，我们简单总结一下在 Nginx 下配置 HTTPS 的关键要点：</p>
<ul>
<li>获得 SSL 证书</li>
<li>通过 OpenSSL 命令获得 example.key 和 example.csr 文件</li>
<li>提供 example.csr 文件给第三方可靠证书颁发机构，选择适合的安全级别证书并签署，获得 example.crt 文件</li>
<li>通过 listen 命令 SSL 参数以及引用 example.key 和 example.crt 文件完成 HTTPS 基础配置</li>
<li>HTTPS优化</li>
<li>减少 CPU 运算量</li>
<li>使用 keepalive 长连接</li>
<li>复用 SSL 会话参数</li>
<li>使用 HSTS 策略强制浏览器使用 HTTPS 连接</li>
<li>添加 Strict-Transport-Security 头部信息</li>
<li>使用 HSTS 预加载列表（HSTS Preload List）</li>
<li>加强 HTTPS 安全性</li>
<li>使用迪菲-赫尔曼密钥交换（D-H，Diffie–Hellman key exchange）方案</li>
<li>添加 X-Frame-Options 头部信息，减少点击劫持</li>
<li>添加 X-Content-Type-Options 头部信息，禁止服务器自动解析资源类型</li>
<li>添加 X-Xss-Protection 头部信息，防XSS攻击</li>
<li>HTTP/HTTPS混合服务器配置</li>
<li>基于服务器名称（name-based）的 HTTPS 服务器</li>
<li>为每个 HTTPS 服务器分配独立的 IP 地址</li>
<li>泛域证书</li>
<li>域名标识（SNI）</li>
</ul>
<h2 id="全站ssl"><a href="#全站ssl" class="headerlink" title="全站ssl"></a>全站ssl</h2><p>全站做ssl是最常见的一个使用场景，默认端口443，而且一般是单向认证。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        root &#x2F;apps&#x2F;www;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate ..&#x2F;SSL&#x2F;ittest.pem;</span><br><span class="line">        ssl_certificate_key ..&#x2F;SSL&#x2F;ittest.key;</span><br><span class="line">#        ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#        ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span><br><span class="line">#        ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想把http的请求强制转到https的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen      80;</span><br><span class="line">  server_name example.me;</span><br><span class="line">  rewrite     ^   https:&#x2F;&#x2F;$server_name$request_uri? permanent;</span><br><span class="line">### 使用return的效率会更高 </span><br><span class="line">#  return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ssl_certificate证书其实是个公钥，它会被发送到连接服务器的每个客户端，ssl_certificate_key私钥是用来解密的，所以它的权限要得到保护但nginx的主进程能够读取。当然私钥和证书可以放在一个证书文件中，这种方式也只有公钥证书才发送到client。</p>
<p>ssl_protocols指令用于启动特定的加密协议，nginx在1.1.13和1.0.12版本后默认是ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2，TLSv1.1与TLSv1.2要确保OpenSSL &gt;= 1.0.1 ，SSLv3 现在还有很多地方在用但有不少被攻击的漏洞。</p>
<p>ssl_ciphers选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher ‘RC4:HIGH:!aNULL:!MD5’（后面是你所指定的套件加密算法） 来看所支持算法。</p>
<p>ssl_prefer_server_ciphers on设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。</p>
<h2 id="https优化参数"><a href="#https优化参数" class="headerlink" title="https优化参数"></a>https优化参数</h2><p>ssl_session_cache shared:SSL:10m; : 设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，和off差不多，停用缓存。如shared:SSL:10m表示我所有的nginx工作进程共享ssl会话缓存，官网介绍说1M可以存放约4000个sessions。</p>
<p>ssl_session_cache。</p>
<p>ssl_session_timeout ： 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。<br>设置较长的keepalive_timeout也可以减少请求ssl会话协商的开销，但同时得考虑线程的并发数了。<br>提示：在生成证书请求csr文件时，如果输入了密码，nginx每次启动时都会提示输入这个密码，可以使用私钥来生成解密后的key来代替，效果是一样的，达到免密码重启的效果：</p>
<p><code>openssl rsa -in ittest.key -out ittest_unsecure.key</code></p>
<h2 id="部分页面ssl"><a href="#部分页面ssl" class="headerlink" title="部分页面ssl"></a>部分页面ssl</h2><p>一个站点并不是所有信息都是非常机密的，如网上商城，一般的商品浏览可以不通过https，而用户登录以及支付的时候就强制经过https传输，这样用户访问速度和安全性都得到兼顾。</p>
<p>但是请注意不要理解错了，是对页面加密而不能针对某个请求加密，一个页面或地址栏的URL一般会发起许多请求的，包括css/png/js等静态文件和动态的java或php请求，所以要加密的内容包含页面内的其它资源文件，否则就会出现http与https内容混合的问题。在http页面混有https内容时，页面排版不会发生乱排现象；在https页面中包含以http方式引入的图片、js等资源时，浏览器为了安全起见会阻止加载。</p>
<p>下面是只对example.com/account/login登录页面进行加密的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x2F;apps&#x2F;www;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    location ^~ &#x2F;account&#x2F;login &#123;</span><br><span class="line">        rewrite ^ https:&#x2F;&#x2F;$server_name:443$request_uri? permanent;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">        ### Set headers ####</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_redirect     off; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ..&#x2F;SSL&#x2F;ittest.pem;</span><br><span class="line">    ssl_certificate_key ..&#x2F;SSL&#x2F;ittest.key;</span><br><span class="line">    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location ^~ &#x2F;account&#x2F;login &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_redirect     off; </span><br><span class="line">        ### Most PHP, Python, Rails, Java App can use this header -&gt; https ###</span><br><span class="line">        proxy_set_header X-Forwarded-Proto  $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        rewrite  ^  http:&#x2F;&#x2F;$server_name$request_uri? permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面配置中使用了proxy_set_header X-Forwarded-Proto $scheme，在jsp页面使用request.getScheme()得到的是https 。如果不把请求的$scheme协议设置在header里，后端jsp页面会一直认为是http，将导致响应异常。</p>
<p>ssl配置块还有个与不加密的80端口类似的location /，它的作用是当用户直接通过https访问首页时，自动跳转到不加密端口，你可以去掉它允许用户这样做。</p>
<h2 id="实现双向ssl认证"><a href="#实现双向ssl认证" class="headerlink" title="实现双向ssl认证"></a>实现双向ssl认证</h2><p>上面的两种配置都是去认证被访问的站点域名是否真实可信，并对传输过程加密，但服务器端并没有认证客户端是否可信。（实际上除非特别重要的场景，也没必要去认证访问者，除非像银行U盾这样的情况）</p>
<p>要实现双向认证HTTPS，nginx服务器上必须导入CA证书（根证书/中间级证书），因为现在是由服务器端通过CA去验证客户端的信息。还有必须在申请服务器证书的同时，用同样的方法生成客户证书。取得客户证书后，还要将它转换成浏览器识别的格式（大部分浏览器都认识PKCS12格式）：</p>
<p><code>openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out client.p12</code></p>
<p>然后把这个client.p12发给你相信的人，让它导入到浏览器中，访问站点建立连接的时候nginx会要求客户端把这个证书发给自己验证，如果没有这个证书就拒绝访问。</p>
<p>同时别忘了在 nginx.conf 里配置信任的CA：（如果是二级CA，请把根CA放在后面，形成CA证书链）</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C-Coding-Guidelines-In-Chinese</title>
    <url>/p/ccdf824a.html</url>
    <content><![CDATA[<p>很不错的Objective-C编码规范中文版，转载于<a href="https://github.com/QianKaiLu/Objective-C-Coding-Guidelines-In-Chinese" target="_blank" rel="noopener">https://github.com/QianKaiLu/Objective-C-Coding-Guidelines-In-Chinese</a>，感谢QianKaiLu的分享</p>
<h2 id="Objective-C-Coding-Guidelines-In-Chinese"><a href="#Objective-C-Coding-Guidelines-In-Chinese" class="headerlink" title="Objective-C-Coding-Guidelines-In-Chinese"></a>Objective-C-Coding-Guidelines-In-Chinese</h2><p>Objective-C编码规范，内容来自苹果、谷歌的文档翻译，自己的编码经验和对其它资料的总结。</p>
<p>转载请注明出处。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Objective-C是一门面向对象的动态编程语言，主要用于编写iOS和Mac应用程序。关于Objective-C的编码规范，苹果和谷歌都已经有很好的</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Apple Coding Guidelines for Cocoa</p>
<p>Google Objective-C Style Guide</p>
<p>本文主要整合了对上述文档的翻译、作者自己的编程经验和其他的相关资料，为公司总结出一份通用的编码规范。</p>
<a id="more"></a>

<h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>使用空格而不是制表符Tab</p>
<p>不要在工程里使用Tab键，使用空格来进行缩进。在Xcode &gt; Preferences &gt; Text Editing将Tab和自动缩进都设置为4个空格。（Google的标准是使用两个空格来缩进，但这里还是推荐使用Xcode默认的设置。）</p>
<p>每一行的最大长度</p>
<p>同样的，在Xcode &gt; Preferences &gt; Text Editing &gt; Page guide at column:中将最大行长设置为80，过长的一行代码将会导致可读性问题。</p>
<h2 id="函数的书写"><a href="#函数的书写" class="headerlink" title="函数的书写"></a>函数的书写</h2><p>一个典型的Objective-C函数应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在-和(void)之间应该有一个空格，第一个大括号{的位置在函数所在行的末尾，同样应该有一个空格。（我司的C语言规范要求是第一个大括号单独占一行，但考虑到OC较长的函数名和苹果SDK代码的风格，还是将大括号放在行末。）</p>
<p>如果一个函数有特别多的参数或者名称很长，应该将其按照:来对齐分行显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(id)initWithModel:(IPCModle)model</span><br><span class="line">       ConnectType:(IPCConnectType)connectType</span><br><span class="line">        Resolution:(IPCResolution)resolution</span><br><span class="line">          AuthName:(NSString *)authName</span><br><span class="line">          Password:(NSString *)password</span><br><span class="line">               MAC:(NSString *)mac</span><br><span class="line">              AzIp:(NSString *)az_ip</span><br><span class="line">             AzDns:(NSString *)az_dns</span><br><span class="line">             Token:(NSString *)token</span><br><span class="line">             Email:(NSString *)email</span><br><span class="line">          Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate;</span><br></pre></td></tr></table></figure>

<p>在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)short:(GTMFoo *)theFoo</span><br><span class="line">        longKeyword:(NSRect)theRect</span><br><span class="line">  evenLongerKeyword:(float)theInterval</span><br><span class="line">              error:(NSError **)theError &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>函数调用的格式和书写差不多，可以按照函数的长短来选择写在一行或者分成多行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;写在一行</span><br><span class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分行写，按照&#39;:&#39;对齐</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">               name:arg2</span><br><span class="line">              error:arg3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第一段名称过短的话后续可以进行缩进</span><br><span class="line">[myObj short:arg1</span><br><span class="line">          longKeyword:arg2</span><br><span class="line">    evenLongerKeyword:arg3</span><br><span class="line">                error:arg4];</span><br></pre></td></tr></table></figure>

<p>以下写法是错误的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;错误，要么写在一行，要么全部分行</span><br><span class="line">[myObject doFooWith:arg1 name:arg2</span><br><span class="line">              error:arg3];</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">               name:arg2 error:arg3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，按照&#39;:&#39;来对齐，而不是关键字</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">          name:arg2</span><br><span class="line">          error:arg3];</span><br></pre></td></tr></table></figure>

<h2 id="public和-private标记符"><a href="#public和-private标记符" class="headerlink" title="@public和@private标记符"></a>@public和@private标记符</h2><p>@public和@private标记符应该以一个空格来进行缩进：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject &#123;</span><br><span class="line"> @public</span><br><span class="line">  ...</span><br><span class="line"> @private</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="协议（Protocols）"><a href="#协议（Protocols）" class="headerlink" title="协议（Protocols）"></a>协议（Protocols）</h3><p>在书写协议的时候注意用&lt;&gt;括起来的协议和类型名之间是没有空格的，比如IPCConnectHandler()<IPCPreconnectorDelegate>,这个规则适用所有书写协议的地方，包括函数声明、类声明、实例变量等等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MyProtocoledClass : NSObject&lt;NSWindowDelegate&gt; &#123;</span><br><span class="line"> @private</span><br><span class="line">    id&lt;MyFancyDelegate&gt; _delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)setDelegate:(id&lt;MyFancyDelegate&gt;)aDelegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="闭包（Blocks）"><a href="#闭包（Blocks）" class="headerlink" title="闭包（Blocks）"></a>闭包（Blocks）</h3><p>根据block的长度，有不同的书写规则：</p>
<p>较短的block可以写在一行内。</p>
<p>如果分行显示的话，block的右括号}应该和调用block那行代码的第一个非空字符对齐。</p>
<p>block内的代码采用4个空格的缩进。</p>
<p>如果block过于庞大，应该单独声明成一个变量来使用。</p>
<p>^和(之间，^和{之间都没有空格，参数列表的右括号)和{之间有一个空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;较短的block写在一行内</span><br><span class="line">[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;分行书写的block，内部使用4空格缩进</span><br><span class="line">[operation setCompletionBlock:^&#123;</span><br><span class="line">    [self.delegate newDataAvailable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用C语言API调用的block遵循同样的书写规则</span><br><span class="line">dispatch_async(_fileIOQueue, ^&#123;</span><br><span class="line">    NSString* path &#x3D; [self sessionFilePath];</span><br><span class="line">    if (path) &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;较长的block关键字可以缩进后在新行书写，注意block的右括号&#39;&#125;&#39;和调用block那行代码的第一个非空字符对齐</span><br><span class="line">[[SessionService sharedService]</span><br><span class="line">    loadWindowWithCompletionBlock:^(SessionWindow *window) &#123;</span><br><span class="line">        if (window) &#123;</span><br><span class="line">          [self windowDidLoad:window];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          [self errorLoadingWindow];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;较长的block参数列表同样可以缩进后在新行书写</span><br><span class="line">[[SessionService sharedService]</span><br><span class="line">    loadWindowWithCompletionBlock:</span><br><span class="line">        ^(SessionWindow *window) &#123;</span><br><span class="line">            if (window) &#123;</span><br><span class="line">              [self windowDidLoad:window];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              [self errorLoadingWindow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;庞大的block应该单独定义成变量使用</span><br><span class="line">void (^largeBlock)(void) &#x3D; ^&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line">[_operationQueue addOperationWithBlock:largeBlock];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在一个调用中使用多个block，注意到他们不是像函数那样通过&#39;:&#39;对齐的，而是同时进行了4个空格的缩进</span><br><span class="line">[myObject doSomethingWith:arg1</span><br><span class="line">    firstBlock:^(Foo *a) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">    secondBlock:^(Bar *b) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="数据结构的语法糖"><a href="#数据结构的语法糖" class="headerlink" title="数据结构的语法糖"></a>数据结构的语法糖</h3><p>应该使用可读性更好的语法糖来构造NSArray，NSDictionary等数据结构，避免使用冗长的alloc,init方法。</p>
<p>如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，在语法糖的&quot;[]&quot;或者&quot;&#123;&#125;&quot;两端留有空格</span><br><span class="line">NSArray *array &#x3D; @[ [foo description], @&quot;Another String&quot;, [bar description] ];</span><br><span class="line">NSDictionary *dict &#x3D; @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不正确，不留有空格降低了可读性</span><br><span class="line">NSArray* array &#x3D; @[[foo description], [bar description]];</span><br><span class="line">NSDictionary* dict &#x3D; @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;;</span><br></pre></td></tr></table></figure>

<p>如果构造代码不写在一行内，构造元素需要使用两个空格来进行缩进，右括号]或者}写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *array &#x3D; @[</span><br><span class="line">  @&quot;This&quot;,</span><br><span class="line">  @&quot;is&quot;,</span><br><span class="line">  @&quot;an&quot;,</span><br><span class="line">  @&quot;array&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">NSDictionary *dictionary &#x3D; @&#123;</span><br><span class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造字典时，字典的Key和Value与中间的冒号:都要留有一个空格，多行书写时，也可以将Value对齐：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，冒号&#39;:&#39;前后留有一个空格</span><br><span class="line">NSDictionary *option1 &#x3D; @&#123;</span><br><span class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确，按照Value来对齐</span><br><span class="line">NSDictionary *option2 &#x3D; @&#123;</span><br><span class="line">  NSFontAttributeName :            [NSFont fontWithName:@&quot;Arial&quot; size:12],</span><br><span class="line">  NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，冒号前应该有一个空格</span><br><span class="line">NSDictionary *wrong &#x3D; @&#123;</span><br><span class="line">  AKey:       @&quot;b&quot;,</span><br><span class="line">  BLongerKey: @&quot;c&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，每一个元素要么单独成为一行，要么全部写在一行内</span><br><span class="line">NSDictionary *alsoWrong&#x3D; @&#123; AKey : @&quot;a&quot;,</span><br><span class="line">                            BLongerKey : @&quot;b&quot; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐</span><br><span class="line">NSDictionary *stillWrong &#x3D; @&#123;</span><br><span class="line">  AKey       : @&quot;b&quot;,</span><br><span class="line">  BLongerKey : @&quot;c&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>清晰</p>
<p>命名应该尽可能的清晰和简洁，但在Objective-C中，清晰比简洁更重要。由于Xcode强大的自动补全功能，我们不必担心名称过长的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;清晰</span><br><span class="line">insertObject:atIndex:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不清晰，insert的对象类型和at的位置属性没有说明</span><br><span class="line">insert:at:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清晰</span><br><span class="line">removeObjectAtIndex:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不清晰，remove的对象类型没有说明，参数的作用没有说明</span><br><span class="line">remove:</span><br></pre></td></tr></table></figure>

<p>不要使用单词的简写，拼写出完整的单词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;清晰</span><br><span class="line">destinationSelection</span><br><span class="line">setBackgroundColor:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不清晰，不要使用简写</span><br><span class="line">destSel</span><br><span class="line">setBkgdColor:</span><br></pre></td></tr></table></figure>

<p>然而，有部分单词简写在Objective-C编码过程中是非常常用的，以至于成为了一种规范，这些简写可以在代码中直接使用，下面列举了部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alloc   &#x3D;&#x3D; Allocate					max    &#x3D;&#x3D; Maximum</span><br><span class="line">alt     &#x3D;&#x3D; Alternate				min    &#x3D;&#x3D; Minimum</span><br><span class="line">app     &#x3D;&#x3D; Application				msg    &#x3D;&#x3D; Message</span><br><span class="line">calc    &#x3D;&#x3D; Calculate				nib    &#x3D;&#x3D; Interface Builder archive</span><br><span class="line">dealloc &#x3D;&#x3D; Deallocate				pboard &#x3D;&#x3D; Pasteboard</span><br><span class="line">func    &#x3D;&#x3D; Function					rect   &#x3D;&#x3D; Rectangle</span><br><span class="line">horiz   &#x3D;&#x3D; Horizontal				Rep    &#x3D;&#x3D; Representation (used in class name such as NSBitmapImageRep).</span><br><span class="line">info    &#x3D;&#x3D; Information				temp   &#x3D;&#x3D; Temporary</span><br><span class="line">init    &#x3D;&#x3D; Initialize				vert   &#x3D;&#x3D; Vertical</span><br><span class="line">int     &#x3D;&#x3D; Integer</span><br></pre></td></tr></table></figure>

<p>命名方法或者函数时要避免歧义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;有歧义，是返回sendPort还是send一个Port？</span><br><span class="line">sendPort</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有歧义，是返回一个名字属性的值还是display一个name的动作？</span><br><span class="line">displayName</span><br></pre></td></tr></table></figure>

<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>整个工程的命名风格要保持一致性，最好和苹果SDK的代码保持统一。不同类中完成相似功能的方法应该叫一样的名字，比如我们总是用count来返回集合的个数，不能在A类中使用count而在B类中使用getNumber。</p>
<h3 id="使用前缀"><a href="#使用前缀" class="headerlink" title="使用前缀"></a>使用前缀</h3><p>如果代码需要打包成Framework给别的工程使用，或者工程项目非常庞大，需要拆分成不同的模块，使用命名前缀是非常有用的。</p>
<p>前缀由大写的字母缩写组成，比如Cocoa中NS前缀代表Founation框架中的类，IB则代表Interface Builder框架。</p>
<p>可以在为类、协议、函数、常量以及typedef宏命名的时候使用前缀，但注意不要为成员变量或者方法使用前缀，因为他们本身就包含在类的命名空间内。</p>
<p>命名前缀的时候不要和苹果SDK框架冲突。</p>
<h3 id="命名类和协议（Class-amp-Protocol）"><a href="#命名类和协议（Class-amp-Protocol）" class="headerlink" title="命名类和协议（Class&amp;Protocol）"></a>命名类和协议（Class&amp;Protocol）</h3><p>类名以大写字母开头，应该包含一个名词来表示它代表的对象类型，同时可以加上必要的前缀，比如NSString, NSDate, NSScanner, NSApplication等等。</p>
<p>而协议名称应该清晰地表示它所执行的行为，而且要和类名区别开来，所以通常使用ing词尾来命名一个协议，比如NSCopying,NSLocking。</p>
<p>有些协议本身包含了很多不相关的功能，主要用来为某一特定类服务，这时候可以直接用类名来命名这个协议，比如NSObject协议，它包含了id对象在生存周期内的一系列方法。</p>
<h3 id="命名头文件（Headers）"><a href="#命名头文件（Headers）" class="headerlink" title="命名头文件（Headers）"></a>命名头文件（Headers）</h3><p>源码的头文件名应该清晰地暗示它的功能和包含的内容：</p>
<p>如果头文件内只定义了单个类或者协议，直接用类名或者协议名来命名头文件，比如NSLocale.h定义了NSLocale类。</p>
<p>如果头文件内定义了一系列的类、协议、类别，使用其中最主要的类名来命名头文件，比如NSString.h定义了NSString和NSMutableString。</p>
<p>每一个Framework都应该有一个和框架同名的头文件，包含了框架中所有公共类头文件的引用，比如Foundation.h</p>
<p>Framework中有时候会实现在别的框架中类的类别扩展，这样的文件通常使用被扩展的框架名+Additions的方式来命名，比如NSBundleAdditions.h。</p>
<h3 id="命名方法（Methods）"><a href="#命名方法（Methods）" class="headerlink" title="命名方法（Methods）"></a>命名方法（Methods）</h3><p>Objective-C的方法名通常都比较长，这是为了让程序有更好地可读性，按苹果的说法“好的方法名应当可以以一个句子的形式朗读出来”。</p>
<p>方法一般以小写字母打头，每一个后续的单词首字母大写，方法名中不应该有标点符号（包括下划线），有两个例外：</p>
<p>可以用一些通用的大写字母缩写打头方法，比如PDF,TIFF等。<br>可以用带下划线的前缀来命名私有方法或者类别中的方法。<br>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用do，does这种多余的关键字，动词本身的暗示就足够了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;动词打头的方法表示让对象执行一个动作</span><br><span class="line">- (void)invokeWithTarget:(id)target;</span><br><span class="line">- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem;</span><br></pre></td></tr></table></figure>

<p>如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加get或者其他的动词前缀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，使用属性名来命名方法</span><br><span class="line">- (NSSize)cellSize;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，添加了多余的动词前缀</span><br><span class="line">- (NSSize)calcCellSize;</span><br><span class="line">- (NSSize)getCellSize;</span><br></pre></td></tr></table></figure>

<p>对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，保证每个参数都有关键词修饰</span><br><span class="line">- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，遗漏关键词</span><br><span class="line">- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确</span><br><span class="line">- (id)viewWithTag:(NSInteger)aTag;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，关键词的作用不清晰</span><br><span class="line">- (id)taggedView:(int)aTag;</span><br></pre></td></tr></table></figure>

<p>不要用and来连接两个参数，通常and用来表示方法执行了两个相对独立的操作（从设计上来说，这时候应该拆分成两个独立的方法）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;错误，不要使用&quot;and&quot;来连接参数</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确，使用&quot;and&quot;来表示两个相对独立的操作</span><br><span class="line">- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</span><br></pre></td></tr></table></figure>

<p>方法的参数命名也有一些需要注意的地方:</p>
<p>和方法名类似，参数的第一个字母小写，后面的每一个单词首字母大写</p>
<p>不要再方法名中使用类似pointer,ptr这样的字眼去表示指针，参数本身的类型足以说明</p>
<p>不要使用只有一两个字母的参数名</p>
<p>不要使用简写，拼出完整的单词</p>
<p>下面列举了一些常用参数名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...action:(SEL)aSelector</span><br><span class="line">...alignment:(int)mode</span><br><span class="line">...atIndex:(int)index</span><br><span class="line">...content:(NSRect)aRect</span><br><span class="line">...doubleValue:(double)aDouble</span><br><span class="line">...floatValue:(float)aFloat</span><br><span class="line">...font:(NSFont *)fontObj</span><br><span class="line">...frame:(NSRect)frameRect</span><br><span class="line">...intValue:(int)anInt</span><br><span class="line">...keyEquivalent:(NSString *)charCode</span><br><span class="line">...length:(int)numBytes</span><br><span class="line">...point:(NSPoint)aPoint</span><br><span class="line">...stringValue:(NSString *)aString</span><br><span class="line">...tag:(int)anInt</span><br><span class="line">...target:(id)anObject</span><br><span class="line">...title:(NSString *)aString</span><br></pre></td></tr></table></figure>

<h3 id="存取方法（Accessor-Methods）"><a href="#存取方法（Accessor-Methods）" class="headerlink" title="存取方法（Accessor Methods）"></a>存取方法（Accessor Methods）</h3><p>存取方法是指用来获取和设置类属性值的方法，属性的不同类型，对应着不同的存取方法规范：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;属性是一个名词时的存取方法范式</span><br><span class="line">- (type)noun;</span><br><span class="line">- (void)setNoun:(type)aNoun;</span><br><span class="line">&#x2F;&#x2F;栗子</span><br><span class="line">- (NSString *)title;</span><br><span class="line">- (void)setTitle:(NSString *)aTitle;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;属性是一个形容词时存取方法的范式</span><br><span class="line">- (BOOL)isAdjective;</span><br><span class="line">- (void)setAdjective:(BOOL)flag;</span><br><span class="line">&#x2F;&#x2F;栗子</span><br><span class="line">- (BOOL)isEditable;</span><br><span class="line">- (void)setEditable:(BOOL)flag;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;属性是一个动词时存取方法的范式</span><br><span class="line">- (BOOL)verbObject;</span><br><span class="line">- (void)setVerbObject:(BOOL)flag;</span><br><span class="line">&#x2F;&#x2F;栗子</span><br><span class="line">- (BOOL)showsAlpha;</span><br><span class="line">- (void)setShowsAlpha:(BOOL)flag;</span><br></pre></td></tr></table></figure>

<p>命名存取方法时不要将动词转化为被动形式来使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确</span><br><span class="line">- (void)setAcceptsGlyphInfo:(BOOL)flag;</span><br><span class="line">- (BOOL)acceptsGlyphInfo;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不要使用动词的被动形式</span><br><span class="line">- (void)setGlyphInfoAccepted:(BOOL)flag;</span><br><span class="line">- (BOOL)glyphInfoAccepted;</span><br></pre></td></tr></table></figure>

<p>可以使用can,should,will等词来协助表达存取方法的意思，但不要使用do,和does：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确</span><br><span class="line">- (void)setCanHide:(BOOL)flag;</span><br><span class="line">- (BOOL)canHide;</span><br><span class="line">- (void)setShouldCloseDocument:(BOOL)flag;</span><br><span class="line">- (BOOL)shouldCloseDocument;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不要使用&quot;do&quot;或者&quot;does&quot;</span><br><span class="line">- (void)setDoesAcceptGlyphInfo:(BOOL)flag;</span><br><span class="line">- (BOOL)doesAcceptGlyphInfo;</span><br></pre></td></tr></table></figure>

<p>为什么Objective-C中不适用get前缀来表示属性获取方法？因为get在Objective-C中通常只用来表示从函数指针返回值的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;三个参数都是作为函数的返回值来使用的，这样的函数名可以使用&quot;get&quot;前缀</span><br><span class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br></pre></td></tr></table></figure>

<h3 id="命名委托（Delegate）"><a href="#命名委托（Delegate）" class="headerlink" title="命名委托（Delegate）"></a>命名委托（Delegate）</h3><p>当特定的事件发生时，对象会触发它注册的委托方法。委托是Objective-C中常用的传递消息的方式。委托有它固定的命名范式。</p>
<p>一个委托方法的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为sender的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个关键词为触发委托的类名</span><br><span class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当只有一个&quot;sender&quot;参数时可以省略类名</span><br><span class="line">- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</span><br></pre></td></tr></table></figure>

<p>根据委托方法触发的时机和目的，使用should,will,did等关键词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)browserDidScroll:(NSBrowser *)sender;</span><br><span class="line"></span><br><span class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;、</span><br><span class="line"></span><br><span class="line">- (BOOL)windowShouldClose:(id)sender;</span><br></pre></td></tr></table></figure>

<h3 id="集合操作类方法（Collection-Methods）"><a href="#集合操作类方法（Collection-Methods）" class="headerlink" title="集合操作类方法（Collection Methods）"></a>集合操作类方法（Collection Methods）</h3><p>有些对象管理着一系列其它对象或者元素的集合，需要使用类似“增删查改”的方法来对集合进行操作，这些方法的命名范式一般为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;集合操作范式</span><br><span class="line">- (void)addElement:(elementType)anObj;</span><br><span class="line">- (void)removeElement:(elementType)anObj;</span><br><span class="line">- (NSArray *)elements;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;栗子</span><br><span class="line">- (void)addLayoutManager:(NSLayoutManager *)obj;</span><br><span class="line">- (void)removeLayoutManager:(NSLayoutManager *)obj;</span><br><span class="line">- (NSArray *)layoutManagers;</span><br></pre></td></tr></table></figure>

<p>注意，如果返回的集合是无序的，使用NSSet来代替NSArray。如果需要将元素插入到特定的位置，使用类似于这样的命名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)insertLayoutManager:(NSLayoutManager *)obj atIndex:(int)index;</span><br><span class="line">- (void)removeLayoutManagerAtIndex:(int)index;</span><br></pre></td></tr></table></figure>

<p>如果管理的集合元素中有指向管理对象的指针，要设置成weak类型以防止引用循环。</p>
<p>下面是SDK中NSWindow类的集合操作方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;</span><br><span class="line">- (void)removeChildWindow:(NSWindow *)childWin;</span><br><span class="line">- (NSArray *)childWindows;</span><br><span class="line">- (NSWindow *)parentWindow;</span><br><span class="line">- (void)setParentWindow:(NSWindow *)window;</span><br></pre></td></tr></table></figure>

<h3 id="命名函数（Functions）"><a href="#命名函数（Functions）" class="headerlink" title="命名函数（Functions）"></a>命名函数（Functions）</h3><p>在很多场合仍然需要用到函数，比如说如果一个对象是一个单例，那么应该使用函数来代替类方法执行相关操作。</p>
<p>函数的命名和方法有一些不同，主要是：</p>
<p>函数名称一般带有缩写前缀，表示方法所在的框架。<br>前缀后的单词以“驼峰”表示法显示，第一个单词首字母大写。<br>函数名的第一个单词通常是一个动词，表示方法执行的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSHighlightRect</span><br><span class="line">NSDeallocateObject</span><br></pre></td></tr></table></figure>

<p>如果函数返回其参数的某个属性，省略动词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int NSEventMaskFromType(NSEventType type)</span><br><span class="line">float NSHeight(NSRect aRect)</span><br></pre></td></tr></table></figure>

<p>如果函数通过指针参数来返回值，需要在函数名中使用Get：</p>
<p><code>const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)</code></p>
<p>函数的返回类型是BOOL时的命名：</p>
<p><code>BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)</code></p>
<p>命名属性和实例变量（Properties&amp;Instance Variables）</p>
<p>属性和对象的存取方法相关联，属性的第一个字母小写，后续单词首字母大写，不必添加前缀。属性按功能命名成名词或者动词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;名词属性</span><br><span class="line">@property (strong) NSString *title;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动词属性</span><br><span class="line">@property (assign) BOOL showsAlpha;</span><br></pre></td></tr></table></figure>

<p>属性也可以命名成形容词，这时候通常会指定一个带有is前缀的get方法来提高可读性：</p>
<p><code>@property (assign, getter=isEditable) BOOL editable;</code></p>
<p>命名实例变量，在变量名前加上_前缀（有些有历史的代码会将_放在后面），其它和命名属性一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation MyClass &#123;</span><br><span class="line">    BOOL _showsTitle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，类需要对使用者隐藏数据存储的细节，所以不要将实例方法定义成公共可访问的接口，可以使用@private，@protected前缀。</p>
<p>按苹果的说法，不建议在除了init和dealloc方法以外的地方直接访问实例变量，但很多人认为直接访问会让代码更加清晰可读，只在需要计算或者执行操作的时候才使用存取方法访问，我就是这种习惯，所以这里不作要求。</p>
<h3 id="命名常量（Constants）"><a href="#命名常量（Constants）" class="headerlink" title="命名常量（Constants）"></a>命名常量（Constants）</h3><p>如果要定义一组相关的常量，尽量使用枚举类型（enumerations），枚举类型的命名规则和函数的命名规则相同。<br>建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，参见官方的 Adopting Modern Objective-C 一文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个枚举</span><br><span class="line">typedef NS_ENUM(NSInteger, NSMatrixMode) &#123;</span><br><span class="line">    NSRadioModeMatrix,</span><br><span class="line">    NSHighlightModeMatrix,</span><br><span class="line">    NSListModeMatrix,</span><br><span class="line">    NSTrackModeMatrix</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义bit map：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSWindowMask) &#123;</span><br><span class="line">    NSBorderlessWindowMask      &#x3D; 0,</span><br><span class="line">    NSTitledWindowMask          &#x3D; 1 &lt;&lt; 0,</span><br><span class="line">    NSClosableWindowMask        &#x3D; 1 &lt;&lt; 1,</span><br><span class="line">    NSMiniaturizableWindowMask  &#x3D; 1 &lt;&lt; 2,</span><br><span class="line">    NSResizableWindowMask       &#x3D; 1 &lt;&lt; 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用const定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举。常量的命名规范和函数相同：</p>
<p><code>const float NSLightGray;</code></p>
<p>不要使用#define宏来定义常量，如果是整型常量，尽量使用枚举，浮点型常量，使用const定义。#define通常用来给编译器决定是否编译某块代码，比如常用的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef DEBUG</span><br></pre></td></tr></table></figure>

<p>注意到一般由编译器定义的宏会在前后都有一个<strong>，比如</strong>MACH__。</p>
<h3 id="命名通知（Notifications）"><a href="#命名通知（Notifications）" class="headerlink" title="命名通知（Notifications）"></a>命名通知（Notifications）</h3><p>通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，通知的命名范式是：</p>
<p>[触发通知的类名] + [Did | Will] + [动作] + Notification<br>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSApplicationDidBecomeActiveNotification</span><br><span class="line">NSWindowDidMiniaturizeNotification</span><br><span class="line">NSTextViewDidChangeSelectionNotification</span><br><span class="line">NSColorPanelColorDidChangeNotification</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>读没有注释代码的痛苦你我都体会过，好的注释不仅能让人轻松读懂你的程序，还能提升代码的逼格。注意注释是为了让别人看懂，而不是仅仅你自己。</p>
<p>文件注释</p>
<p>每一个文件都必须写文件注释，文件注释通常包含</p>
<p>文件所在模块</p>
<p>作者信息</p>
<p>历史版本信息</p>
<p>版权信息</p>
<p>文件包含的内容，作用</p>
<p>一段良好文件注释的栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*******************************************************************************</span><br><span class="line">	Copyright (C), 2011-2013, Andrew Min Chang</span><br><span class="line"></span><br><span class="line">	File name: 	AMCCommonLib.h</span><br><span class="line">	Author:		Andrew Chang (Zhang Min) </span><br><span class="line">	E-mail:		LaplaceZhang@126.com</span><br><span class="line">	</span><br><span class="line">	Description: 	</span><br><span class="line">			This file provide some covenient tool in calling library tools. One can easily include </span><br><span class="line">		library headers he wants by declaring the corresponding macros. </span><br><span class="line">			I hope this file is not only a header, but also a useful Linux library note.</span><br><span class="line">			</span><br><span class="line">	History:</span><br><span class="line">		2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot;</span><br><span class="line">		2012-08-20: Add shared memory library; add message queue.</span><br><span class="line">		2012-08-21: Add socket library (local)</span><br><span class="line">		2012-08-22: Add math library</span><br><span class="line">		2012-08-23: Add socket library (internet)</span><br><span class="line">		2012-08-24: Add daemon function</span><br><span class="line">		2012-10-10: Change file name as &quot;AMCCommonLib.h&quot;</span><br><span class="line">		2012-12-04: Add UDP support in AMC socket library</span><br><span class="line">		2013-01-07: Add basic data type such as &quot;sint8_t&quot;</span><br><span class="line">		2013-01-18: Add CFG_LIB_STR_NUM.</span><br><span class="line">		2013-01-22: Add CFG_LIB_TIMER.</span><br><span class="line">		2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h</span><br><span class="line"></span><br><span class="line">	Copyright information: </span><br><span class="line">			This file was intended to be under GPL protocol. However, I may use this library</span><br><span class="line">		in my work as I am an employee. And my company may require me to keep it secret. </span><br><span class="line">		Therefore, this file is neither open source nor under GPL control. </span><br><span class="line">		</span><br><span class="line">********************************************************************************&#x2F;</span><br></pre></td></tr></table></figure>

<p>文件注释的格式通常不作要求，能清晰易读就可以了，但在整个工程中风格要统一。</p>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>好的代码应该是“自解释”（self-documenting）的，但仍然需要详细的注释来说明参数的意义、返回值、功能以及可能的副作用。</p>
<p>方法、函数、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，好处是可以在引用的地方alt+点击自动弹出注释，非常方便。</p>
<p>有很多可以自动生成注释格式的插件，推荐使用VVDocumenter：</p>
<p>Screenshot</p>
<p>一些良好的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  Create a new preconnector to replace the old one with given mac address.</span><br><span class="line"> *  NOTICE: We DO NOT stop the old preconnector, so handle it by yourself.</span><br><span class="line"> *</span><br><span class="line"> *  @param type       Connect type the preconnector use.</span><br><span class="line"> *  @param macAddress Preconnector&#39;s mac address.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)refreshConnectorWithConnectType:(IPCConnectType)type  Mac:(NSString *)macAddress;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Stop current preconnecting when application is going to background.</span><br><span class="line"> *&#x2F;</span><br><span class="line">-(void)stopRunning;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Get the COPY of cloud device with a given mac address.</span><br><span class="line"> *</span><br><span class="line"> *  @param macAddress Mac address of the device.</span><br><span class="line"> *</span><br><span class="line"> *  @return Instance of IPCCloudDevice.</span><br><span class="line"> *&#x2F;</span><br><span class="line">-(IPCCloudDevice *)getCloudDeviceWithMac:(NSString *)macAddress;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A delegate for NSApplication to handle notifications about app</span><br><span class="line">&#x2F;&#x2F; launch and shutdown. Owned by the main app controller.</span><br><span class="line">@interface MyAppDelegate : NSObject &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>协议、委托的注释要明确说明其被触发的条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Delegate - Sent when failed to init connection, like p2p failed. *&#x2F;</span><br><span class="line">-(void)initConnectionDidFailed:(IPCConnectHandler *)handler;</span><br></pre></td></tr></table></figure>

<p>如果在注释中要引用参数名或者方法函数名，使用||将参数或者方法括起来以避免歧义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Sometimes we need |count| to be less than zero.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</span><br></pre></td></tr></table></figure>

<p>定义在头文件里的接口方法、属性必须要有注释！</p>
<h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>每个人都有自己的编码风格，这里总结了一些比较好的Cocoa编程风格和注意点。</p>
<p>不要使用new方法</p>
<p>尽管很多时候能用new代替alloc init方法，但这可能会导致调试内存时出现不可预料的问题。Cocoa的规范就是使用alloc init方法，使用new会让一些读者困惑。</p>
<p>Public API要尽量简洁</p>
<p>共有接口要设计的简洁，满足核心的功能需求就可以了。不要设计很少会被用到，但是参数极其复杂的API。如果要定义复杂的方法，使用类别或者类扩展。</p>
<h3 id="import和-include"><a href="#import和-include" class="headerlink" title="#import和#include"></a>#import和#include</h3><p>#import是Cocoa中常用的引用头文件的方式，它能自动防止重复引用文件，什么时候使用#import，什么时候使用#include呢？</p>
<p>当引用的是一个Objective-C或者Objective-C++的头文件时，使用#import<br>当引用的是一个C或者C++的头文件时，使用#include，这时必须要保证被引用的文件提供了保护域（#define guard）。<br>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Cocoa&#x2F;Cocoa.h&gt;</span><br><span class="line">#include &lt;CoreFoundation&#x2F;CoreFoundation.h&gt;</span><br><span class="line">#import &quot;GTMFoo.h&quot;</span><br><span class="line">#include &quot;base&#x2F;basictypes.h&quot;</span><br></pre></td></tr></table></figure>

<p>为什么不全部使用#import呢？主要是为了保证代码在不同平台间共享时不出现问题。</p>
<h4 id="引用框架的根头文件"><a href="#引用框架的根头文件" class="headerlink" title="引用框架的根头文件"></a>引用框架的根头文件</h4><p>上面提到过，每一个框架都会有一个和框架同名的头文件，它包含了框架内接口的所有引用，在使用框架的时候，应该直接引用这个根头文件，而不是其它子模块的头文件，即使是你只用到了其中的一小部分，编译器会自动完成优化的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，引用根头文件</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不要单独引用框架内的其它头文件</span><br><span class="line">#import &lt;Foundation&#x2F;NSArray.h&gt;</span><br><span class="line">#import &lt;Foundation&#x2F;NSString.h&gt;</span><br></pre></td></tr></table></figure>

<h3 id="BOOL的使用"><a href="#BOOL的使用" class="headerlink" title="BOOL的使用"></a>BOOL的使用</h3><p>BOOL在Objective-C中被定义为signed char类型，这意味着一个BOOL类型的变量不仅仅可以表示YES(1)和NO(0)两个值，所以永远不要将BOOL类型变量直接和YES比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较</span><br><span class="line">BOOL great &#x3D; [foo isGreat];</span><br><span class="line">if (great &#x3D;&#x3D; YES)</span><br><span class="line">  &#x2F;&#x2F; ...be great!</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确</span><br><span class="line">BOOL great &#x3D; [foo isGreat];</span><br><span class="line">if (great)</span><br><span class="line">  &#x2F;&#x2F; ...be great!</span><br></pre></td></tr></table></figure>

<p>同样的，也不要将其它类型的值作为BOOL来返回，这种情况下，BOOL变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如&amp;&amp;,||,!的返回是可以直接赋给BOOL的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;错误，不要将其它类型转化为BOOL返回</span><br><span class="line">- (BOOL)isBold &#123;</span><br><span class="line">  return [self fontTraits] &amp; NSFontBoldTrait;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isValid &#123;</span><br><span class="line">  return [self stringValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确</span><br><span class="line">- (BOOL)isBold &#123;</span><br><span class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确，逻辑操作符可以直接转化为BOOL</span><br><span class="line">- (BOOL)isValid &#123;</span><br><span class="line">  return [self stringValue] !&#x3D; nil;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isEnabled &#123;</span><br><span class="line">  return [self isValid] &amp;&amp; [self isBold];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外BOOL类型可以和_Bool,bool相互转化，但是不能和Boolean转化。</p>
<h3 id="使用ARC"><a href="#使用ARC" class="headerlink" title="使用ARC"></a>使用ARC</h3><p>除非想要兼容一些古董级的机器和操作系统，我们没有理由放弃使用ARC。在最新版的Xcode(6.2)中，ARC是自动打开的，所以直接使用就好了。</p>
<p>在init和dealloc中不要用存取方法访问实例变量</p>
<p>当init<code>dealloc</code>方法被执行时，类的运行时环境不是处于正常状态的，使用存取方法访问变量可能会导致不可预料的结果，因此应当在这两个方法内直接访问实例变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，直接访问实例变量</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  if (self) &#123;</span><br><span class="line">    _bar &#x3D; [[NSMutableString alloc] init];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">  [_bar release];</span><br><span class="line">  [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不要通过存取方法访问</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">  self &#x3D; [super init];</span><br><span class="line">  if (self) &#123;</span><br><span class="line">    self.bar &#x3D; [NSMutableString string];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">  self.bar &#x3D; nil;</span><br><span class="line">  [super dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照定义的顺序释放资源</p>
<p>在类或者Controller的生命周期结束时，往往需要做一些扫尾工作，比如释放资源，停止线程等，这些扫尾工作的释放顺序应当与它们的初始化或者定义的顺序保持一致。这样做是为了方便调试时寻找错误，也能防止遗漏。</p>
<p>保证NSString在赋值时被复制</p>
<p>NSString非常常用，在它被传递或者赋值时应当保证是以复制（copy）的方式进行的，这样可以防止在不知情的情况下String的值被其它对象修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setFoo:(NSString *)aFoo &#123;</span><br><span class="line">  _foo &#x3D; [aFoo copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用NSNumber的语法糖"><a href="#使用NSNumber的语法糖" class="headerlink" title="使用NSNumber的语法糖"></a>使用NSNumber的语法糖</h3><p>使用带有@符号的语法糖来生成NSNumber对象能使代码更简洁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSNumber *fortyTwo &#x3D; @42;</span><br><span class="line">NSNumber *piOverTwo &#x3D; @(M_PI &#x2F; 2);</span><br><span class="line">enum &#123;</span><br><span class="line">  kMyEnum &#x3D; 2;</span><br><span class="line">&#125;;</span><br><span class="line">NSNumber *myEnum &#x3D; @(kMyEnum);</span><br></pre></td></tr></table></figure>

<h3 id="nil检查"><a href="#nil检查" class="headerlink" title="nil检查"></a>nil检查</h3><p>因为在Objective-C中向nil对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用nil来做逻辑上的检查。</p>
<p>另外，不要使用诸如nil == Object或者Object == nil的形式来判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，直接判断</span><br><span class="line">if (!objc) &#123;</span><br><span class="line">	...	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不要使用nil &#x3D;&#x3D; Object的形式</span><br><span class="line">if (nil &#x3D;&#x3D; objc) &#123;</span><br><span class="line">	...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性的线程安全"><a href="#属性的线程安全" class="headerlink" title="属性的线程安全"></a>属性的线程安全</h3><p>定义一个属性时，编译器会自动生成线程安全的存取方法（Atomic），但这样会大大降低性能，特别是对于那些需要频繁存取的属性来说，是极大的浪费。所以如果定义的属性不需要线程保护，记得手动添加属性关键字nonatomic来取消编译器的优化。</p>
<h3 id="点分语法的使用"><a href="#点分语法的使用" class="headerlink" title="点分语法的使用"></a>点分语法的使用</h3><p>不要用点分语法来调用方法，只用来访问属性。这样是为了防止代码可读性问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正确，使用点分语法访问属性</span><br><span class="line">NSString *oldName &#x3D; myObject.name;</span><br><span class="line">myObject.name &#x3D; @&quot;Alice&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不要用点分语法调用方法</span><br><span class="line">NSArray *array &#x3D; [NSArray arrayWithObject:@&quot;hello&quot;];</span><br><span class="line">NSUInteger numberOfItems &#x3D; array.count;</span><br><span class="line">array.release;</span><br></pre></td></tr></table></figure>

<h3 id="Delegate要使用弱引用"><a href="#Delegate要使用弱引用" class="headerlink" title="Delegate要使用弱引用"></a>Delegate要使用弱引用</h3><p>一个类的Delegate对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的Delegate属性要设置为弱引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** delegate *&#x2F;</span><br><span class="line">@property (nonatomic, weak) id &lt;IPCConnectHandlerDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Realm-Swift使用入门</title>
    <url>/p/45fd89a7.html</url>
    <content><![CDATA[<p>Realm适用iOS和Android平台，本身相比sqlite、CoreData操作简单，在这里记录下使用方式；<br>（Swift4.2）</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pod ‘RealmSwift’</code></p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>打开 Realm 数据库</p>
<p>要打开一个 Realm 数据库，首先需要初始化一个新的 Realm 对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let realm &#x3D; try! Realm()</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(myDog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将会初始化出一个默认 Realm 数据库。</p>
<h3 id="配置-Realm-数据库"><a href="#配置-Realm-数据库" class="headerlink" title="配置 Realm 数据库"></a>配置 Realm 数据库</h3><p>可配置本地 Realm 数据库在磁盘上的路径；</p>
<p>对于可同步 Realm 数据库而言，可以配置管理用户，以及服务器上的远程路径；</p>
<h3 id="配置版本迁移"><a href="#配置版本迁移" class="headerlink" title="配置版本迁移"></a>配置版本迁移</h3><p>压缩功能，高效地利用磁盘空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setDefaultRealmForUser(username: String) &#123;</span><br><span class="line">    var config &#x3D; Realm.Configuration()</span><br><span class="line">    &#x2F;&#x2F; 使用默认的目录，但是请将文件名替换为用户名</span><br><span class="line">    config.fileURL &#x3D; config.fileURL!.deletingLastPathComponent().appendingPathComponent(&quot;\(username).realm&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将该配置设置为默认 Realm 配置</span><br><span class="line">    Realm.Configuration.defaultConfiguration &#x3D; config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作-Realm-对象"><a href="#操作-Realm-对象" class="headerlink" title="操作 Realm 对象"></a>操作 Realm 对象</h3><p>对象的自更新</p>
<p>Object 实例是底层数据的动态体现，会自动进行更新；因此这意味着无需去刷新对象的当前状态。修改某个对象的属性，会立即影响到所有指向该对象的其他实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myDog &#x3D; Dog()</span><br><span class="line">myDog.name &#x3D; &quot;Fido&quot;</span><br><span class="line">myDog.age &#x3D; 1</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(myDog)</span><br><span class="line">&#125;</span><br><span class="line">let myPuppy &#x3D; realm.objects(Dog.self).filter(&quot;age &#x3D;&#x3D; 1&quot;).first</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    myPuppy!.age &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;age of my dog: \(myDog.age)&quot;) &#x2F;&#x2F; &#x3D;&gt; 2</span><br></pre></td></tr></table></figure>

<p>这不仅使得 Realm 保证高速和高效，同时还让代码更为简洁、更为灵活。如果您的 UI 代码基于某个特定的 Realm 对象来实现，那么在触发 UI 重绘以前，您根本无需进行数据刷新或者重新检索。</p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>对象的所有更改（添加、修改和删除）都必须在写入事务内完成。</p>
<p>Realm 对象可以被实例化，还可作为未管理对象使用（例如，还未添加到 Realm 数据库），并且使用方式与其它正常 Swift 对象无异。然而，如果要在线程之间共享对象，或者在应用启动后反复使用，那么您必须将这些对象添加到 Realm 数据库中。向 Realm 数据库中添加对象必须在写入事务内完成。由于写入事务将会产生无法忽略的性能消耗，因此您应当检视您的代码，以确保尽可能减少写入事务的数量。</p>
<p>warning：Realm 的写入操作是同步以及阻塞进行的，它并不会异步执行。如果线程 A 开始进行写入操作，然后线程 B 在线程 A 结束之前，对相同的 Realm 数据库也执行了写入操作，那么线程 A 必须要在线程 B 的写入操作发生之前，结束并提交其事务。写入事务会在 beginWrite() 执行时自动刷新，因此重复写入并不会产生竞争条件。</p>
<h3 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h3><p>Realm 提供了一系列更新对象的方法，根据使用场景的不同， 每个方法都有各自的优缺点。</p>
<h4 id="直接更新"><a href="#直接更新" class="headerlink" title="直接更新"></a>直接更新</h4><p>您可以在写入事务中，通过设置对象的属性从而完成更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在事务中更新对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    author.name &#x3D; &quot;Thomas Pynchon&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键值编码"><a href="#键值编码" class="headerlink" title="键值编码"></a>键值编码</h4><p>Object、Result 和 List 均允许使用 键值编码(KVC)。 当您需要在运行时决定何种属性需要进行更新的时候， 这个方法就非常有用了。<br>批量更新对象时，为集合实现 KVC 是一个很好的做法， 这样就不用承受遍历集合时为每个项目创建访问器 所带来的性能损耗。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let persons &#x3D; realm.objects(Person.self)</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    persons.first?.setValue(true, forKeyPath: &quot;isFirst&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将每个 person 对象的 planet 属性设置为 &quot;Earth&quot;</span><br><span class="line">    persons.setValue(&quot;Earth&quot;, forKeyPath: &quot;planet&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过主键更新"><a href="#通过主键更新" class="headerlink" title="通过主键更新"></a>通过主键更新</h4><p>如果数据模型类中包含了主键，那么 可以使用 Realm().add(_:update:)，从而让 Realm 基于主键来自动更新或者添加对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 book 对象，其主键与之前存储的 book 对象相同</span><br><span class="line">let cheeseBook &#x3D; Book()</span><br><span class="line">cheeseBook.title &#x3D; &quot;Cheese recipes&quot;</span><br><span class="line">cheeseBook.price &#x3D; 9000</span><br><span class="line">cheeseBook.id &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; 更新这个 id &#x3D; 1 的 book</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(cheeseBook, update: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个主键值为 “1” 的 Book 对象已经存在于数据库当中 ，那么该对象只会进行更新。如果不存在的话， 那么一个全新的 Book 对象就会被创建出来，并被添加到数据库当中。</p>
<p>您可以通过传递一个子集，其中只包含打算更新的值， 从而对带有主键的对象进行部分更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设主键为 &#96;1&#96; 的 &quot;Book&quot; 对象已经存在</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Book.self, value: [&quot;id&quot;: 1, &quot;price&quot;: 9000.0], update: true)</span><br><span class="line">    &#x2F;&#x2F; book 对象的 &#96;title&#96; 属性仍旧保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有定义主键，那么最好不要对这类对象传递 update: true 参数。</p>
<p>请注意，对于可空属性 而言， 在更新对象的时候，nil 仍会被视为有效值。如果您提供了一个属性值存在 nil 的字典，那么这个设定会被应用到应用当中，并且这些属性值也会被清空。 为了确保不会出现意外的数据丢失， 在使用此方法之前请再三确认， 只提供了想要进行更新的属性值。</p>
<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><p>在写入事务中，将要删除的对象传递给 Realm().delete(_:) 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cheeseBook 存储在 Realm 数据库中</span><br><span class="line">&#x2F;&#x2F; 在事务中删除对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.delete(cheeseBook)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您同样也可以删除存储在 Realm 数据库当中的所有数据。请注意，Realm 文件会保留在磁盘上所占用的空间，从而为以后的对象预留足够的空间，从而实现快速存储。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从 Realm 数据库中删除所有对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.deleteAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询将会返回一个 Results 实例，其中包含了一组 Object 对象。Results 的接口与 Array 基本相同，并且可以使用索引下标来访问包含在 Results 当中的对象。与 Array 所不同的是，Results 只能持有一个 Object 子类类型。</p>
<p>所有的查询操作（包括检索和属性访问）在 Realm 中都是延迟加载的。只有当属性被访问时，数据才会被读取。</p>
<p>查询结果并不是数据的拷贝：（在写入事务中）修改查询结果会直接修改磁盘上的数据。与之类似，您可以从 Results 当中的 Object 来直接遍历关系图。</p>
<p>除非对结果进行了访问，否则查询的执行将会被推迟（Lazy）。这意味着 将多个临时 Results 关联在一起，然后对数据进行排序和条件检索的操作， 并不会执行中间状态处理之类的额外工作。</p>
<p>一旦执行了查询，或者添加了通知模块， 那么 Results 将时刻与 Realm 数据库当中的数据保持一致， 如有可能，会在后台线程中执行再一次查询操作。</p>
<p>从 Realm 数据库中检索对象的最基本方法是 Realm().objects(_:)，这个方法将会返回 Object 子类类型在默认 Realm 数据库当中的查询到的所有数据，并以 Results 实例的形式返回。</p>
<p><code>let dogs = realm.objects(Dog.self) // 从默认的 Realm 数据库中遍历所有 Dog 对象</code></p>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>如果您对 NSPredicate 有所了解的话，那么您就已经掌握了在 Realm 中进行查询的方法了。Objects、Realm、List 和 Results 均提供了相关的方法，从而只需传递 NSPredicate 实例、断言字符串、或者断言格式化字符串来查询特定的 Object 实例，这与对 NSArray 进行查询所类似。</p>
<p>例如，下面这个例子通过调用 Results().filter(_:…) 方法，从默认 Realm 数据库中遍历出所有棕黄色、名字以 “B” 开头的狗狗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用断言字符串来查询</span><br><span class="line">var tanDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39; AND name BEGINSWITH &#39;B&#39;&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 NSPredicate 来查询</span><br><span class="line">let predicate &#x3D; NSPredicate(format: &quot;color &#x3D; %@ AND name BEGINSWITH %@&quot;, &quot;tan&quot;, &quot;B&quot;)</span><br><span class="line">tanDogs &#x3D; realm.objects(Dog.self).filter(predicate)</span><br></pre></td></tr></table></figure>

<p>参见 Apple 的断言编程指南来获取更多关于构建断言的信息，此外还可以使用我们的 NSPredicate Cheatsheet。Realm 支持大多数常见的断言：</p>
<p>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</p>
<p>比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!= 和 BETWEEN 支持 Int、Int8、Int16、Int32、Int64、Float、Double 以及 Date 这几种属性类型，例如 age == 45；</p>
<p>比较是否相同：== 和 !=，例如，Results().filter(“company == %@”, company)；</p>
<p>比较操作符 == 和 != 支持布尔属性；</p>
<p>对于 String 和 Data 属性而言，支持使用 ==、!=、BEGINSWITH、CONTAINS 和 ENDSWITH 操作符，例如 name CONTAINS ‘Ja’；</p>
<p>对于 String 属性而言，LIKE 操作符可以用来比较左端属性和右端表达式：? 和 可用作通配符，其中 ? 可以匹配任意一个字符， 匹配 0 个及其以上的字符。例如：value LIKE ‘?bc*’ 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</p>
<p>字符串的比较忽略大小写，例如 name CONTAINS[c] ‘Ja’。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。[c] 修饰符可以与 [d] 修饰符结合使用；</p>
<p>字符串的比较忽略变音符号，例如 name BEGINSWITH[d] ‘e’ 能够匹配到 étoile。这个修饰符可以与 [c] 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见当前的限制一节来了解详细信息。）</p>
<p>Realm 支持以下组合操作符：“AND”、“OR” 和 “NOT”，例如 name BEGINSWITH ‘J’ AND age &gt;= 32；</p>
<p>包含操作符：IN，例如 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</p>
<p>空值比较：==、!=，例如 Results().filter(“ceo == nil”)。请注意，Realm 将 nil 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，nil 等同于自身；</p>
<p>ANY 比较，例如 ANY student.age &lt; 21；</p>
<p>List 和 Results 属性支持聚集表达式：@count、@min、@max、@sum 和 @avg，例如 realm.objects(Company.self).filter(“employees.@count &gt; 5”) 可用以检索所有拥有 5 名以上雇员的公司。</p>
<p>支持子查询，不过存在以下限制：</p>
<p>@count 是唯一一个能在 SUBQUERY 表达式当中使用的操作符；</p>
<p>SUBQUERY(…).@count 表达式只能与常量相比较；</p>
<p>目前仍不支持关联子查询。</p>
<p>参见 Results().filter(_:…)。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Results 允许您指定一个排序标准，然后基于关键路径、属性或者多个排序描述符来进行排序。例如，下列代码让上述示例中返回的 Dog 对象按名字进行升序排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对颜色为棕黄色、名字以 &quot;B&quot; 开头的狗狗进行排序</span><br><span class="line">let sortedDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39; AND name BEGINSWITH &#39;B&#39;&quot;).sorted(byKeyPath: &quot;name&quot;)</span><br></pre></td></tr></table></figure>

<p>关键路径同样也可以是某个多对一关系属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var name &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var dog: Dog?</span><br><span class="line">&#125;</span><br><span class="line">class Dog: Object &#123;</span><br><span class="line">    @objc dynamic var name &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var age &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dogOwners &#x3D; realm.objects(Person.self)</span><br><span class="line">let ownersByDogAge &#x3D; dogOwners.sorted(byKeyPath: &quot;dog.age&quot;)</span><br></pre></td></tr></table></figure>

<p>请注意，sorted(byKeyPath:) 和 sorted(byProperty:) 不支持 将多个属性用作排序基准，此外也无法链式排序（只有最后一个 sorted 调用会被使用）。 如果要对多个属性进行排序，请使用 sorted(by:)方法，然后向其中输入多个 SortDescriptor 对象。</p>
<p>欲了解更多信息，参见：</p>
<p>Results().sorted(_:)</p>
<p>Results().sorted(byKeyPath:ascending:)</p>
<p>注意，在对查询进行排序的时候，只能保证 Results 的次序不变。 出于性能考量，插入次序将无法保证。 如果您希望维护插入次序， 那么可以在这里查看解决方案。</p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。</p>
<p>如果您需要获取一个棕黄色狗狗的结果集，然后在此基础上再获取名字以 ‘B’ 开头的棕黄色狗狗，那么您可以像这样将这两个查询连接起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let tanDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39;&quot;)</span><br><span class="line">let tanDogsWithBNames &#x3D; tanDogs.filter(&quot;name BEGINSWITH &#39;B&#39;&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="结果的自更新"><a href="#结果的自更新" class="headerlink" title="结果的自更新"></a>结果的自更新</h3><p>Object 实例是底层数据的动态体现，其会自动进行更新，这意味着您无需去重新检索结果。它们会直接映射出 Realm 数据库在当前线程中的状态，包括当前线程上的写入事务。唯一的例外是，在使用 for…in 枚举时，它会将刚开始遍历时满足匹配条件的所有对象给遍历完，即使在遍历过程中有对象被过滤器修改或者删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let puppies &#x3D; realm.objects(Dog.self).filter(&quot;age &lt; 2&quot;)</span><br><span class="line">puppies.count &#x2F;&#x2F; &#x3D;&gt; 0</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Dog.self, value: [&quot;name&quot;: &quot;Fido&quot;, &quot;age&quot;: 1])</span><br><span class="line">&#125;</span><br><span class="line">puppies.count &#x2F;&#x2F; &#x3D;&gt; 1</span><br></pre></td></tr></table></figure>

<p>所有的 Results 对象均有此特性，无论是匹配查询出来的还是链式查询出来的。</p>
<p>Results 属性不仅让 Realm 数据库保证高速和高效，同时还让代码更为简洁、更加灵活。例如，如果视图控制器基于查询结果来实现，那么您可以将 Results 存储在属性当中，这样每次访问就不需要刷新以确保数据最新了。</p>
<p>您可以订阅 Realm 通知，以了解 Realm 数据何时发生了更新，比如说可以决定应用 UI 何时进行刷新，而无需重新检索 Results。<br>由于结果是自动更新的，因此不要迷信下标索引和总数会保持不变。Results 不变的唯一情况是在快速枚举的时候，这样就可以在枚举过程中，对匹配条件的对象进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try! realm.write &#123;</span><br><span class="line">    for person in realm.objects(Person.self).filter(&quot;age &#x3D;&#x3D; 10&quot;) &#123;</span><br><span class="line">        person.age +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以使用键值编码 来对 Results 执行相关操作。</p>
<h3 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h3><p>大多数其他数据库技术都提供了从检索中对结果进行“分页”的能力（例如 SQLite 中的 “LIMIT” 关键字）。这通常是很有必要的，可以避免一次性从硬盘中读取太多的数据，或者将太多查询结果加载到内存当中。</p>
<p>由于 Realm 中的检索是惰性的，因此这行这种分页行为是没有必要的。因为 Realm 只会在检索到的结果被明确访问时，才会从其中加载对象。</p>
<p>如果由于 UI 相关或者其他代码实现相关的原因导致您需要从检索中获取一个特定的对象子集，这和获取 Results 对象一样简单，只需要读出您所需要的对象即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 循环读取出前 5 个 Dog 对象</span><br><span class="line">&#x2F;&#x2F; 从而限制从磁盘中读取的对象数量</span><br><span class="line">let dogs &#x3D; try! Realm().objects(Dog.self)</span><br><span class="line">for i in 0..&lt;5 &#123;&#x3D;&quot;&quot; let&#x3D;&quot;&quot; dog&#x3D;&quot;dogs[i]&quot; ...&#x3D;&quot;&quot; &#125;&#x3D;&quot;&quot; &lt;&#x3D;&quot;&quot; code&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="本地迁移"><a href="#本地迁移" class="headerlink" title="本地迁移"></a>本地迁移</h3><p>通过设置 Realm.Configuration.schemaVersion 以及 Realm.Configuration.migrationBlock 可以定义本地迁移。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">let config &#x3D; Realm.Configuration(</span><br><span class="line">    &#x2F;&#x2F; 设置新的架构版本。必须大于之前所使用的</span><br><span class="line">    &#x2F;&#x2F; （如果之前从未设置过架构版本，那么当前的架构版本为 0）</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置模块，如果 Realm 的架构版本低于上面所定义的版本，</span><br><span class="line">    &#x2F;&#x2F; 那么这段代码就会自动调用</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        &#x2F;&#x2F; 我们目前还未执行过迁移，因此 oldSchemaVersion &#x3D;&#x3D; 0</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有什么要做的！</span><br><span class="line">            &#x2F;&#x2F; Realm 会自行检测新增和被移除的属性</span><br><span class="line">            &#x2F;&#x2F; 然后会自动更新磁盘上的架构</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通知 Realm 为默认的 Realm 数据库使用这个新的配置对象</span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; config</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 现在我们已经通知了 Realm 如何处理架构变化，</span><br><span class="line">&#x2F;&#x2F; 打开文件将会自动执行迁移</span><br><span class="line">let realm &#x3D; try! Realm()</span><br></pre></td></tr></table></figure>

<h2 id="值的更新"><a href="#值的更新" class="headerlink" title="值的更新"></a>值的更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; Realm.Configuration(</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; enumerateObjects(ofType:_:) 方法将会遍历</span><br><span class="line">            &#x2F;&#x2F; 所有存储在 Realm 文件当中的 &#96;Person&#96; 对象</span><br><span class="line">            migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in</span><br><span class="line">                &#x2F;&#x2F; 将两个 name 合并到 fullName 当中</span><br><span class="line">                let firstName &#x3D; oldObject![&quot;firstName&quot;] as! String</span><br><span class="line">                let lastName &#x3D; oldObject![&quot;lastName&quot;] as! String</span><br><span class="line">                newObject![&quot;fullName&quot;] &#x3D; &quot;\(firstName) \(lastName)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; Realm.Configuration(</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        &#x2F;&#x2F; 我们目前还未执行过迁移，因此 oldSchemaVersion &#x3D;&#x3D; 0</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 重命名操作必须要在 &#96;enumerateObjects(ofType: _:)&#96; 调用之外进行</span><br><span class="line">            migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>当整个 Realm 数据库发生变化时，就会发送 Realm 通知；如果只有个别对象被修改、添加或者删除，那么就会发送集合通知。</p>
<p>通知只会在最初所注册的注册的线程中传递，并且该线程必须拥有一个正在运行的 Run Loop</p>
<p>Realm 通知</p>
<p>通知处理模块可以对整个 Realm 数据库进行注册。每次涉及到 Realm 的写入事务提交之后，无论写入事务发生在哪个线程还是进程中，通知处理模块都会被激活：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 Realm 通知</span><br><span class="line">let token &#x3D; realm.observe &#123; notification, realm in</span><br><span class="line">    viewController.updateUI()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 随后</span><br><span class="line">token.invalidate()</span><br></pre></td></tr></table></figure>

<h3 id="集合通知"><a href="#集合通知" class="headerlink" title="集合通知"></a>集合通知</h3><p>可以通过传递到通知模块当中的 RealmCollectionChange 参数来访问这些变更。该对象存放了受删除 (deletions)、插入 (insertions) 以及修改 (modifications) 所影响的索引信息。</p>
<h3 id="对象通知"><a href="#对象通知" class="headerlink" title="对象通知"></a>对象通知</h3><p>Realm 支持对象级别的通知。可以在特定的 Realm 对象上进行通知的注册，对象被删除、修改时获取相应的通知。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class StepCounter: Object &#123;</span><br><span class="line">    @objc dynamic var steps &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stepCounter &#x3D; StepCounter()</span><br><span class="line">let realm &#x3D; try! Realm()</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(stepCounter)</span><br><span class="line">&#125;</span><br><span class="line">var token : NotificationToken?</span><br><span class="line">token &#x3D; stepCounter.observe &#123; change in</span><br><span class="line">    switch change &#123;</span><br><span class="line">    case .change(let properties):</span><br><span class="line">        for property in properties &#123;</span><br><span class="line">            if property.name &#x3D;&#x3D; &quot;steps&quot; &amp;&amp; property.newValue as! Int &gt; 1000 &#123;</span><br><span class="line">                print(&quot;Congratulations, you&#39;ve exceeded 1000 steps.&quot;)</span><br><span class="line">                token &#x3D; nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;An error occurred: \(error)&quot;)</span><br><span class="line">    case .deleted:</span><br><span class="line">        print(&quot;The object was deleted.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨线程使用-Realm-数据库"><a href="#跨线程使用-Realm-数据库" class="headerlink" title="跨线程使用 Realm 数据库"></a>跨线程使用 Realm 数据库</h2><p>在不同的线程中使用同一个 Realm 文件，必须每一个线程初始化一个新的Realm 实例。</p>
<p>不支持跨线程共享Realm 实例。Realm 实例要访问相同的 Realm 文件还必须使用相同的 Realm.Configuration。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Realm 没有提供对 JSON 的直接支持，可以使用 NSJSONSerialization.JSONObjectWithData(_:options:) 的输出</p>
<h2 id="常见限制"><a href="#常见限制" class="headerlink" title="常见限制"></a>常见限制</h2><p>Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如：</p>
<p>类名称的长度最大只能存储 57 个 UTF8 字符。</p>
<p>属性名称的长度最大只能支持 63 个 UTF8 字符。</p>
<p>Data 和 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。</p>
<p>每个单独的 Realm 文件大小无法超过应用在 iOS 系统中所被允许使用的内存量——这个量对于每个设备而言都是不同的，并且还取决于当时内存空间的碎片化情况(关于此问题有一个相关的 Radar：rdar://17119975)。如果您需要存储海量数据的话，那么可以选择使用多个 Realm 文件并进行映射。</p>
<p>对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>尽管 Realm 文件可以被多个线程同时访问，但是您不能直接跨线程传递 Realms、Realm 对象、查询和查询结果。如果您需要跨线程传递 Realm 对象的话，您可以使用 ThreadSafeReference API。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Setter 和 Getter：因为 Realm 在底层数据库中重写了 setters 和 getters 方法，所以您不可以在您的对象上再对其进行重写。一个简单的替代方法就是：创建一个新的 Realm 忽略属性，该属性的访问起可以被重写， 并且可以调用其他的 getter 和 setter 方法。</p>
<p>自动增长属性：Realm 没有线程且进程安全的自动增长属性机制，而这在其他数据库中常常用来产生主键。然而，在绝大多数情况下，对于主键来说，我们需要的是一个唯一的、自动生成的值，因此没有必要使用顺序的、连续的、整数的 ID 作为主键，因此一个独一无二的字符串主键通常就能满足需求了。一个常见的模式是将默认的属性值设置为 NSUUID().UUIDString 以产生一个唯一的字符串 ID。</p>
<p>自动增长属性另一种常见的动机是为了维持插入之后的顺序。在某些情况下，这可以通过向某个 List中添加对象，或者使用 NSDate() 默认值的 createdAt 属性。</p>
<p>Objective-C 中的属性：如果您需要在 Objective‑C 中访问 Realm Swift 模型的话，那么注意所有 List以及 RealmOptional 属性都不可用（就像其他 Swift 独有的数据类型一样）——如果有必要的话，您可以添加封装的 getter 和 setter 方法，将其在 NSNumber 或者 NSArray 之间进行转化。此外，早于 Xcode 7 Beta 5 之前的版本有一个 已知的Swift bug，它会导致自动生成的 Objective‑C 头文件（-Swift.h）无法通过编译。您就必须将 List 类型的属性设置为 private 或者 internal。请前往 GitHub issue #1925了解更多信息。</p>
<p>Object 子类的自定义构造器：当您创建 Object 子类模型的时候，您或许会想要添加自己的构造器方法，以便增加便利性。</p>
<p>由于 Swift 内省机制中现有的一些限制，我们不能给这个类中添加指定构造器(designated initializer)。相反，它们需要被标记为便利构造器(convenience initializer)，使用相同名字的 Swift 关键词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyModel: Object &#123;</span><br><span class="line">    @objc dynamic var myValue &#x3D; &quot;&quot;</span><br><span class="line">    convenience init(myValue: String) &#123;</span><br><span class="line">        self.init() &#x2F;&#x2F; 请注意这里使用的是 &#39;self&#39; 而不是 &#39;super&#39;</span><br><span class="line">        self.myValue &#x3D; myValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift：KVO监听对象属性</title>
    <url>/p/4dd31b3.html</url>
    <content><![CDATA[<p>刚接触 RAC 时，非常喜欢它的键值监听方式，简单两个宏就能实现对属性的监听，但在 Swift 环境下 RxSwift 有没有这样的“瑞士军刀”呢？在这里记录下 RxSwift 实现 KVO 的方式。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假设有对象 JDPersonModel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;必须是 NSObject 的子类，结构体不能使用 KVO</span><br><span class="line">class JDPersonModel: NSObject &#123;</span><br><span class="line">	&#x2F;&#x2F;必须用 @objc dynamic 修饰</span><br><span class="line">    @objc dynamic var name: String &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var age: Int &#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用下面的方式实现 KVO</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">	&#x2F;&#x2F;RxSwift 的相关方法生命周期 dispose 管理</span><br><span class="line">    let disposeBag &#x3D; DisposeBag()</span><br><span class="line">    var age: Int &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        let person:JDPersonModel &#x3D; JDPersonModel()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;observe(&#39;监听属性的类型&#39;,‘属性的名称’)，监听的属性必须是 @objc dynamic 修饰</span><br><span class="line">        person.rx.observe(String.self, &quot;name&quot;).subscribe(onNext: &#123; (name) in</span><br><span class="line">            print(&quot;name did change \(String(describing: name ?? &quot;nil&quot;))&quot;)</span><br><span class="line">        &#125;).disposed(by: self.disposeBag)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;循环引用的解决方法[weak self]</span><br><span class="line">        person.rx.observe(Int.self, &quot;age&quot;).subscribe(onNext: &#123;[weak self] (age) in</span><br><span class="line">            self?.age &#x3D; age ?? 0</span><br><span class="line">            print(&quot;age did change \(String(describing: age))&quot;)</span><br><span class="line">        &#125;).disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RxSwift 下，由于 Swift 更注重安全性，并没有 OC 强大的动态性，而 OC 的 KVO 是基于运行时的扩展，在 Swift 环境下使用并不方便。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift应用 UITextField相关</title>
    <url>/p/d914857b.html</url>
    <content><![CDATA[<p>简单记录下RxSwift在UITextField中的常用操作</p>
<ul>
<li>监听输入+节流</li>
<li>绑定输入到其它对象</li>
<li>输入监听判断</li>
<li>同时监听多个输入</li>
<li>监听controlEvent变化</li>
</ul>
<a id="more"></a>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line">public class JDBaseViewController: UIViewController &#123;</span><br><span class="line">    let disposeBag &#x3D; DisposeBag()</span><br><span class="line">@IBOutlet weak var textField: UITextField!</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var textField2: UITextField!</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    @IBOutlet weak var btn: UIButton!</span><br><span class="line">    </span><br><span class="line">    override public func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    &#x2F;&#x2F; MARK: - Navigation</span><br><span class="line">    &#x2F;&#x2F; In a storyboard-based application, you will often want to do a little preparation before navigation</span><br><span class="line">    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">        &#x2F;&#x2F; Get the new view controller using segue.destination.</span><br><span class="line">        &#x2F;&#x2F; Pass the selected object to the new view controller.</span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听输入-节流"><a href="#监听输入-节流" class="headerlink" title="监听输入+节流"></a>监听输入+节流</h2><p><code>let input = self.textField.rx.text.orEmpty.asDriver().throttle(0.3)</code></p>
<h2 id="绑定输入到其它对象"><a href="#绑定输入到其它对象" class="headerlink" title="绑定输入到其它对象"></a>绑定输入到其它对象</h2><p><code>input.drive(self.textField2.rx.text).disposed(by: self.disposeBag)</code></p>
<h2 id="输入监听判断"><a href="#输入监听判断" class="headerlink" title="输入监听判断"></a>输入监听判断</h2><p><code>input.map{ $0.count &gt; 5 }.drive(self.btn.rx.isEnabled).disposed(by: self.disposeBag)</code></p>
<h2 id="同时监听多个输入"><a href="#同时监听多个输入" class="headerlink" title="同时监听多个输入"></a>同时监听多个输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.combineLatest(self.textField01.rx.text.orEmpty, self.textField02.rx.text.orEmpty) &#123;</span><br><span class="line">            textValue1, textValue2 -&gt; String in</span><br><span class="line">            return &quot;input is: \(textValue1) -- \(textValue2)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            .map&#123;$0&#125;</span><br><span class="line">            .bind(to: self.label.rx.text)</span><br><span class="line">            .disposed(by: self.disposeBag)</span><br></pre></td></tr></table></figure>

<h2 id="监听controlEvent变化"><a href="#监听controlEvent变化" class="headerlink" title="监听controlEvent变化"></a>监听controlEvent变化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.textField02.rx.controlEvent([UIControlEvents.editingDidBegin])</span><br><span class="line">            .asObservable()</span><br><span class="line">            .subscribe(onNext: &#123; _ in</span><br><span class="line">            print(&quot;begin edit&quot;)</span><br><span class="line">        &#125;).disposed(by: self.disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwfit 基础概论</title>
    <url>/p/32a5f54b.html</url>
    <content><![CDATA[<p>RxSwif是ReactiveX的Swift版本，也就是一个函数式响应编程的框架。</p>
<h1 id="函数式响应编程-面向异步数据流编程，关键是对函数和状态的理解。"><a href="#函数式响应编程-面向异步数据流编程，关键是对函数和状态的理解。" class="headerlink" title="函数式响应编程:面向异步数据流编程，关键是对函数和状态的理解。"></a>函数式响应编程:面向异步数据流编程，关键是对函数和状态的理解。</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>可观察序列 (Observables aka Sequences)</li>
<li>事件 next\error\completed</li>
<li>Observer 观察者</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="可观察序列-Observables-aka-Sequences"><a href="#可观察序列-Observables-aka-Sequences" class="headerlink" title="可观察序列 (Observables aka Sequences)"></a>可观察序列 (Observables aka Sequences)</h3><p>事件 next\error\completed</p>
<p>Observer 观察者</p>
<h3 id="序列Sequence"><a href="#序列Sequence" class="headerlink" title="序列Sequence"></a>序列Sequence</h3><p>第一，它的容量可以有限也可无限；</p>
<p>第二，只可以迭代 (iterate) 一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">associatedtype Iterator: IteratorProtocol</span><br><span class="line">func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察序列的创建"><a href="#观察序列的创建" class="headerlink" title="观察序列的创建"></a>观察序列的创建</h3><h3 id="Observable订阅"><a href="#Observable订阅" class="headerlink" title="Observable订阅"></a>Observable订阅</h3><h3 id="监听事件的生命周期"><a href="#监听事件的生命周期" class="headerlink" title="监听事件的生命周期"></a>监听事件的生命周期</h3><h3 id="Observable的销毁"><a href="#Observable的销毁" class="headerlink" title="Observable的销毁"></a>Observable的销毁</h3><p>DisposeBag</p>
<p>AnyObserver、Binder</p>
<p>Subject</p>
<ul>
<li>PublishSubject</li>
<li>BehaviorSubject</li>
<li>ReplaySubject</li>
<li>Variable</li>
<li>Transforming Observables</li>
</ul>
<p>buffer:</p>
<p>buffer 方法作用是缓冲组合，第一个参数是缓冲时间，第二个参数是缓冲个数，第三个参数是线程。<br>该方法简单来说就是缓存 Observable 中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。</p>
<p>window:</p>
<p>window 操作符和 buffer 十分相似。不过 buffer 是周期性的将缓存的元素集合发送出来，而 window 周期性的将元素集合以 Observable 的形态发送出来。</p>
<p>同时 buffer 要等到元素搜集完毕后，才会发出元素序列。而 window 可以实时发出元素序列</p>
<p>map</p>
<p>该操作符通过传入一个函数闭包把原来的 Observable 序列转变为一个新的 Observable 序列。</p>
<p>flatMap??</p>
<p>map 在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</p>
<p>而 flatMap 操作符会对源 Observable 的每一个元素应用一个转换方法，将他们转换成 Observables。 然后将这些 Observables 的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个 Observable 序列。</p>
<p>这个操作符是非常有用的。比如当 Observable 的元素拥有其他的 Observable 时，我们可以将所有子 Observables 的元素发送出来。</p>
<p>flatMapLatest</p>
<p>flatMapLatest 与 flatMap 的唯一区别是：flatMapLatest 只会接收最新的 value 事件。</p>
<p>flatMapFirst</p>
<p>flatMapFirst 与 flatMapLatest 正好相反：flatMapFirst 只会接收最初的 value 事件。</p>
<p>concatMap</p>
<p>concatMap 与 flatMap 的唯一区别是：当前一个 Observable 元素发送完毕后，后一个Observable 才可以开始发出元素。或者说等待前一个 Observable 产生完成事件后，才对后一个 Observable 进行订阅。</p>
<p>scan</p>
<p>scan 就是先给一个初始化的数，然后不断的拿前一个结果和最新的值进行处理操作。</p>
<p>groupBy</p>
<p>groupBy 操作符将源 Observable 分解为多个子 Observable，然后将这些子 Observable 发送出来。</p>
<p>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以 Observable 的形态发送出来。</p>
<p>过滤操作符（Filtering Observables）</p>
<p>filter</p>
<p>规则过滤</p>
<p>distinctUntilChanged</p>
<p>重复事件过滤</p>
<p>single</p>
<p>限制发送一次事件或满足条件的第一个事件</p>
<p>elementAt</p>
<p>只处理特定位置的事件</p>
<p>ignoreElements</p>
<p>忽略所有元素、只发出error或completed</p>
<p>take</p>
<p>只发送前n个事件</p>
<p>takeLast</p>
<p>只发送后n个事件</p>
<p>skip</p>
<p>忽略前n个事件</p>
<p>Sample</p>
<p>Sample 除了订阅源Observable 外，还可以监视另外一个 Observable， 即 notifier 。<br>每当收到 notifier 事件，就会从源序列取一个最新的事件并发送。而如果两次 notifier 事件之间没有源序列的事件，则不发送值。</p>
<p>debounce</p>
<p>节流，限制高频产生数据，要求元素和下个元素的间隔小于指定的时间间隔</p>
<p>条件和布尔操作符（Conditional and Boolean Operators）</p>
<p>amb</p>
<p>当传入多个 Observables 到 amb 操作符时，它将取第一个发出元素或产生事件的 Observable，然后只发出它的元素。并忽略掉其他的 Observables</p>
<p>takeWhile</p>
<p>该方法依次判断 Observable 序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。</p>
<p>takeUntil</p>
<p>同时监视notifier。</p>
<p>如果 notifier 发出值或 complete 通知，那么源 Observable 便自动完成，停止发送事件。</p>
<p>skipWhile</p>
<p>跳过前面所有满足条件的事件</p>
<p>skipUntil</p>
<p>同时监听notifier</p>
<p>源 Observable 序列事件默认会一直跳过，直到 notifier 发出值或 complete 通知。</p>
<p>结合操作（Combining Observables）</p>
<p>startWith</p>
<p>发送事件消息之前，先发出预先插入的消息</p>
<p>merge</p>
<p>该方法可以将多个（两个或两个以上的）Observable 序列合并成一个 Observable序列</p>
<p>zip</p>
<p>将两个或两个以上Observable序列压缩成一个Observable序列，并且等到每个Observable事件一一凑齐后再合并</p>
<p>combineLastest</p>
<p>将多个Observable合并，每当任意Observable有新事件发出，它会将每个 Observable 序列的最新的一个事件元素进行合并。</p>
<p>withLatesFrom</p>
<p>将两个Observable序列合并，每当 self 队列发射一个元素时，便从第二个序列中取出最新的一个值。</p>
<p>switchLatest</p>
<p>switchLatest 有点像其他语言的switch 方法，可以对事件流进行转换。<br>比如本来监听的 subject1，我可以通过更改 variable 里面的 value 更换事件源。变成监听 subject2。</p>
<p>算数、以及聚合操作（Mathematical and Aggregate Operators）</p>
<p>toArray</p>
<p>把序列转成一个数组，并作为一个单一的事件发送，然后结束</p>
<p>reduce</p>
<p>接收一个初始值和一个操作符号，将给定的初始值，与序列里的每个值进行累计运算。得到一个最终结果，并将其作为单个值发送出去。</p>
<p>concat</p>
<p>顺序化</p>
<p>把多个 Observable 序列合并（串联）为一个 Observable 序列。</p>
<p>并且只有当前面一个 Observable 序列发出了 completed 事件，才会开始发送下一个 Observable 序列事件。</p>
<p>连接操作（Connectable Observable Operators）</p>
<p>可连接的序列（Connectable Observable）：</p>
<p>（1）可连接的序列和一般序列不同在于：有订阅时不会立刻开始发送事件消息，只有当调用 connect()之后才会开始发送值。</p>
<p>（2）可连接的序列可以让所有的订阅者订阅后，才开始发出事件消息，从而保证我们想要的所有订阅者都能接收到事件消息。</p>
<p>publish</p>
<p>publish 方法会将一个正常的序列转换成一个可连接的序列。同时该序列不会立刻发送事件，只有在调用 connect 之后才会开始。</p>
<p>replay</p>
<p>replay 与 publish 不同在于：新的订阅者还能接收到订阅之前的事件消息（数量由设置的 bufferSize 决定）。</p>
<p>multicast</p>
<p>同样是将一个正常的序列转换成一个可连接的序列。<br>同时还可以传入一个 Subject，每当序列发送事件时都会触发这个 Subject 的发送。</p>
<p>refCount</p>
<p>将可被连接的 Observable 转换为普通 Observable</p>
<p>可以自动连接和断开可连接的 Observable。当第一个观察者对可连接的Observable 订阅时，那么底层的 Observable 将被自动连接。当最后一个观察者离开时，那么底层的 Observable 将被自动断开连接。</p>
<p>share(relay:)</p>
<p>使得观察者共享源 Observable，并且缓存最新的 n 个元素，将这些元素直接发送给新的观察者。<br>简单来说 shareReplay 就是 replay 和 refCount 的组合。</p>
<p>其他一些实用的操作符（Observable Utility Operators）</p>
<p>delay</p>
<p>延迟发送Observable的元素</p>
<p>delaySubscription</p>
<p>延迟订阅</p>
<p>materialize</p>
<p>事件转换成元素</p>
<p>dematerialize</p>
<p>元素还原成事件</p>
<p>timeout</p>
<p>设置超时时间</p>
<p>using</p>
<p>创建 Observable 时，同时会创建一个可被清除的资源，一旦 Observable终止了，那么这个资源就会被清除掉了。</p>
<p>错误处理操作（Error Handling Operators）</p>
<p>catchErrorJustReturn</p>
<p>当遇到 error 事件的时候，就返回指定的值，然后结束。</p>
<p>catchError</p>
<p>捕获 error，并对其进行处理。</p>
<p>同时还能返回另一个 Observable 序列进行订阅（切换到新的序列）。</p>
<p>retry</p>
<p>使用该方法当遇到错误的时候，会重新订阅该序列。</p>
<p>调试操作</p>
<p>debug</p>
<p>将 debug 调试操作符添加到一个链式步骤当中，这样系统就能将所有的订阅者、事件、和处理等详细信息打印出来，方便我们开发调试。</p>
<p>RxSwift.Resources.total</p>
<p>将 RxSwift.Resources.total 打印出来，我们可以查看当前 RxSwift 申请的所有资源数量。这个在检查内存泄露的时候非常有用。</p>
<h3 id="特征序列（Traits）"><a href="#特征序列（Traits）" class="headerlink" title="特征序列（Traits）"></a>特征序列（Traits）</h3><p>Observable 是能够用于任何上下文环境的通用序列。</p>
<p>而 Traits 可以帮助我们更准确的描述序列。同时它们还为我们提供上下文含义、语法糖，让我们能够用更加优雅的方式书写代码。</p>
<p>Single</p>
<p>发出一个元素，或一个 error 事件<br>不会共享状态变化<br>SingleEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class="line">    case success(Element)</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>asSingle()</p>
<p>调用 Observable 序列的.asSingle()方法，将它转换为 Single。</p>
<p>Completable</p>
<p>不会发出任何元素<br>只会发出一个 completed 事件或者一个 error 事件<br>不会共享状态变化<br>CompletableEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum CompletableEvent &#123;</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Maybe</p>
<p>发出一个元素、或者一个 completed 事件、或者一个 error 事件<br>不会共享状态变化<br>适合那种可能需要发出一个元素，又可能不需要发出的情况。<br>MaybeEvent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class="line">    case success(Element)</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>asMaybe()</p>
<p>调用 Observable 序列的 .asMaybe()方法，将它转换为 Maybe。</p>
<p>Driver</p>
<p>不会产生 error 事件<br>一定在主线程监听（MainScheduler）<br>共享状态变化（shareReplayLatestWhileConnected）<br>ControlProperty</p>
<p>专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（Observable）<br>不会产生 error 事件<br>一定在 MainScheduler 订阅（主线程订阅）<br>一定在 MainScheduler 监听（主线程监听）</p>
<h2 id="共享状态变化"><a href="#共享状态变化" class="headerlink" title="共享状态变化"></a>共享状态变化</h2><h3 id="调度器（Schedulers）"><a href="#调度器（Schedulers）" class="headerlink" title="调度器（Schedulers）"></a>调度器（Schedulers）</h3><p>调度器（Schedulers）是 RxSwift 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。</p>
<p>CurrentThreadScheduler：表示当前线程 Scheduler。（默认使用这个）<br>MainScheduler：表示主线程。如果我们需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler运行。<br>SerialDispatchQueueScheduler：封装了 GCD 的串行队列。如果我们需要执行一些串行任务，可以切换到这个 Scheduler 运行。<br>ConcurrentDispatchQueueScheduler：封装了 GCD 的并行队列。如果我们需要执行一些并发任务，可以切换到这个 Scheduler 运行。<br>OperationQueueScheduler：封装了 NSOperationQueue。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL证书相关介绍</title>
    <url>/p/d6b5f353.html</url>
    <content><![CDATA[<h1 id="SSL证书相关介绍"><a href="#SSL证书相关介绍" class="headerlink" title="SSL证书相关介绍"></a>SSL证书相关介绍</h1><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>SSL - Secure Sockets Layer,现在应该叫”TLS”,但由于习惯问题,我们还是叫”SSL”比较多.HTTP协议默认情况下是不加密内容的,这样就很可能在内容传播的时候被别人监听到,对于安全性要求较高的场合,必须要加密,HTTPS就是带加密的HTTP协议,而HTTPS的加密是基于SSL的,它执行的是一个比较下层的加密,也就是说,在加密前,你的服务器程序在干嘛,加密后也一样在干嘛,不用动,这个加密对用户和开发者来说都是透明的.More:[Transport_Layer_Security]:<a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Transport_Layer_Security</a></p>
<p>OpenSSL - 简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到.</p>
<a id="more"></a>
<h2 id="证书标准"><a href="#证书标准" class="headerlink" title="证书标准"></a>证书标准</h2><p>X.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准.</p>
<h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p>同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式.</p>
<p>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x509 -in certificate.pem -text -noout</span><br></pre></td></tr></table></figure>

<p>Apache和*NIX服务器偏向于使用这种编码格式.</p>
<p><strong>DER - Distinguished Encoding Rules</strong>,打开看是二进制格式,不可读.  </p>
<p>查看DER格式证书的信息:</p>
<figure class="highlight plain"><figcaption><span>x509 -in certificate.der -inform der -text -noout```  </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Java和Windows服务器偏向于使用这种编码格式.</span><br><span class="line"></span><br><span class="line">## 相关的文件扩展名</span><br><span class="line"></span><br><span class="line">这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫&quot;PEM&quot;或者&quot;DER&quot;,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.</span><br><span class="line"></span><br><span class="line">**CRT** - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.</span><br><span class="line"></span><br><span class="line">**CER** - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</span><br><span class="line"></span><br><span class="line">**KEY** - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.  </span><br><span class="line"></span><br><span class="line">查看KEY的办法: </span><br><span class="line"></span><br><span class="line">&#96;openssl rsa -in mykey.key -text -noout&#96;</span><br><span class="line"></span><br><span class="line">如果是DER格式的话,同理应该这样了:</span><br><span class="line"></span><br><span class="line">&#96;openssl rsa -in mykey.key -text -noout -inform der&#96;</span><br><span class="line"></span><br><span class="line">CSR - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.</span><br><span class="line">查看的办法:</span><br><span class="line"></span><br><span class="line">&#96;req -noout -text -in my.csr&#96; (如果是DER格式的话照旧加上-inform der,这里不写了)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**PFX&#x2F;P12** </span><br><span class="line"></span><br><span class="line">- predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个&quot;提取密码&quot;,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？  </span><br><span class="line"></span><br><span class="line">&#96;openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes&#96;</span><br><span class="line"></span><br><span class="line">这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.</span><br><span class="line">生成pfx的命令类似这样:</span><br><span class="line"></span><br><span class="line">&#96;pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt&#96;</span><br><span class="line"></span><br><span class="line">其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</span><br><span class="line"></span><br><span class="line">**JKS** - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫&quot;keytool&quot;的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了.</span><br><span class="line"></span><br><span class="line">## 获得证书</span><br><span class="line"></span><br><span class="line">### 向权威证书颁发机构申请证书</span><br><span class="line"></span><br><span class="line">用这命令生成一个csr: &#96;&#96;&#96;openssl req -newkey rsa:2048 -new -nodes -keyout my.key -out my.csr&#96;&#96;&#96;  </span><br><span class="line">把csr交给权威证书颁发机构,权威证书颁发机构对此进行签名,完成.保留好csr,当权威证书颁发机构颁发的证书过期的时候,你还可以用同样的csr来申请新的证书,key保持不变.</span><br><span class="line"></span><br><span class="line">### 或者生成自签名的证书</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">在生成证书的过程中会要你填一堆的东西,其实真正要填的只有Common Name,通常填写你服务器的域名,如&quot;yourcompany.com&quot;,或者你服务器的IP地址,其它都可以留空的.</span><br><span class="line">  </span><br><span class="line">生产环境中还是不要使用自签的证书,否则浏览器会不认,或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的,但现在也有免费的,仅仅需要一个简单的域名验证即可.国内BAT都有相关免费业务。  </span><br><span class="line"></span><br><span class="line">## 证书转换</span><br><span class="line"></span><br><span class="line">**PKCS** 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。   </span><br><span class="line">常用的有：  </span><br><span class="line">**PKCS#7** Cryptographic Message Syntax Standard  </span><br><span class="line">**PKCS#10** Certification Request Standard  </span><br><span class="line">**PKCS#12** Personal Information Exchange Syntax Standard  </span><br><span class="line">***X.509是常见通用的证书格式。所有的证书都符合为Public Key   Infrastructure (PKI) 制定的 ITU-T X509 国际标准。***  </span><br><span class="line">**PKCS#7** 常用的后缀是： .P7B .P7C .SPC  </span><br><span class="line">**PKCS#12** 常用的后缀有： .P12 .PFX  </span><br><span class="line">**X.509** DER 编码(ASCII)的后缀是： .DER .CER .CRT  </span><br><span class="line">**X.509** PAM 编码(Base64)的后缀是： .PEM .CER .CRT  </span><br><span class="line">**.cer&#x2F;.crt**是用于存放证书，它是2进制形式存放的，不含私钥。  </span><br><span class="line">**.pem**跟crt&#x2F;cer的区别是它以Ascii来表示。  </span><br><span class="line">**pfx&#x2F;p12**用于存放个人证书&#x2F;私钥，他通常包含保护密码，2进制方式  </span><br><span class="line">**p10**是证书请求  </span><br><span class="line">**p7r**是CA对证书请求的回复，只用于导入  </span><br><span class="line">**p7b**以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。  </span><br><span class="line"></span><br><span class="line">## CA证书</span><br><span class="line"></span><br><span class="line">用openssl创建CA证书的RSA密钥(PEM格式)：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;openssl genrsa -des3 -out ca.key 1024</span><br></pre></td></tr></table></figure>

<p>创建CA证书有效期为一年</p>
<p>用openssl创建CA证书(PEM格式,假如有效期为一年)：</p>
<figure class="highlight plain"><figcaption><span>-new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">			</span><br><span class="line">openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。</span><br><span class="line"></span><br><span class="line">## x509转换为pfx</span><br><span class="line"></span><br><span class="line">&#96;openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt&#96;</span><br><span class="line">PEM格式的ca.key转换为Microsoft可以识别的pvk格式</span><br><span class="line"></span><br><span class="line">&#96;-in ca.key -out ca.pvk -nocrypt -topvk&#96;</span><br><span class="line">			</span><br><span class="line">## PKCS#12 到 PEM 的转换</span><br><span class="line"></span><br><span class="line">&#96;openssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem&#96;</span><br><span class="line"></span><br><span class="line">验证</span><br><span class="line"></span><br><span class="line">&#96;pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem&#96;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">## 从 PFX 格式文件中提取私钥格式文件 (.key)</span><br><span class="line"></span><br><span class="line">&#96;openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key&#96;</span><br><span class="line"></span><br><span class="line">转换 pem 到到 spc</span><br><span class="line"></span><br><span class="line">&#96;crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc&#96;</span><br><span class="line">			</span><br><span class="line">用 -outform -inform 指定 DER 还是 PAM 格式。例如：</span><br><span class="line"></span><br><span class="line">&#96;openssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER&#96;</span><br><span class="line"></span><br><span class="line">PEM 到 PKCS#12 的转换</span><br><span class="line"></span><br><span class="line">&#96;pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem&#96;</span><br><span class="line">			</span><br><span class="line">## IIS 证书</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">cd c:\openssl </span><br><span class="line">set OPENSSL_CONF&#x3D;openssl.cnf</span><br><span class="line">openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br><span class="line">			</span><br><span class="line">server.key和server.crt文件是Apache的证书文件，生成的server.pfx用于导入IIS</span><br><span class="line"></span><br><span class="line">## 转换PFX 到 PEM</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">openssl pkcs12 -in test.pfx -out client.pem</span><br><span class="line">Enter Import Password:</span><br><span class="line">MAC verified OK</span><br><span class="line">Enter PEM pass phrase:</span><br><span class="line">Verifying - Enter PEM pass phrase:</span><br><span class="line"></span><br><span class="line">DER文件（.crt .cer .der）转为PEM格式文件</span><br><span class="line"></span><br><span class="line">转换DER文件(一般后缀名是.crt .cer .der的文件)到PEM文件</span><br><span class="line"></span><br><span class="line">x509 -inform der -in certificate.cer -out certificate.pem</span><br></pre></td></tr></table></figure>

<p>转换PEM文件到DER文件</p>
<p><code>openssl x509 -outform der -in certificate.pem -out certificate.der</code></p>
<p>命令集</p>
<p>Convert a DER file (.crt .cer .der) to PEM</p>
<p><code>x509 -inform der -in certificate.cer -out certificate.pem</code></p>
<p>Convert a PEM file to DER</p>
<p><code>openssl x509 -outform der -in certificate.pem -out certificate.der</code></p>
<p>Convert a PKCS#12 file (.pfx .p12) containing a private key and certificates to PEM</p>
<p><code>pkcs12 -in keyStore.pfx -out keyStore.pem -nodes</code></p>
<p>You can add -nocerts to only output the private key or add -nokeys to only output the certificates.</p>
<p>Convert a PEM certificate file and a private key to PKCS#12 (.pfx .p12)</p>
<p><code>openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt -certfile CACert.crt</code></p>
<p>Convert PEM to CRT (.CRT file)</p>
<p><code>x509 -outform der -in certificate.pem -out certificate.crt</code></p>
<h3 id="OpenSSL-Convert-PEM"><a href="#OpenSSL-Convert-PEM" class="headerlink" title="OpenSSL Convert PEM"></a>OpenSSL Convert PEM</h3><p>Convert PEM to DER</p>
<p><code>openssl x509 -outform der -in certificate.pem -out certificate.der</code></p>
<p>Convert PEM to P7B</p>
<p><code>crl2pkcs7 -nocrl -certfile certificate.cer -out certificate.p7b -certfile CACert.cer</code></p>
<p>Convert PEM to PFX</p>
<p><code>openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt -certfile CACert.crt</code></p>
<h3 id="OpenSSL-Convert-DER"><a href="#OpenSSL-Convert-DER" class="headerlink" title="OpenSSL Convert DER"></a>OpenSSL Convert DER</h3><p>Convert DER to PEM</p>
<p><code>x509 -inform der -in certificate.cer -out certificate.pem</code></p>
<h3 id="OpenSSL-Convert-P7B"><a href="#OpenSSL-Convert-P7B" class="headerlink" title="OpenSSL Convert P7B"></a>OpenSSL Convert P7B</h3><p>Convert P7B to PEM<br><code>openssl pkcs7 -print_certs -in certificate.p7b -out certificate.cer</code></p>
<p>Convert P7B to PFX</p>
<p><code>pkcs7 -print_certs -in certificate.p7b -out certificate.cer</code></p>
<p><code>openssl pkcs12 -export -in certificate.cer -inkey privateKey.key -out certificate.pfx -certfile CACert.cer</code></p>
<h3 id="OpenSSL-Convert-PFX"><a href="#OpenSSL-Convert-PFX" class="headerlink" title="OpenSSL Convert PFX"></a>OpenSSL Convert PFX</h3><p>Convert PFX to PEM</p>
<p><code>openssl pkcs12 -in certificate.pfx -out certificate.cer -nodes</code></p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift:UIButton</title>
    <url>/p/ff60840f.html</url>
    <content><![CDATA[<h1 id="RxSwift在UIButton上应用的"><a href="#RxSwift在UIButton上应用的" class="headerlink" title="RxSwift在UIButton上应用的"></a>RxSwift在UIButton上应用的</h1><ul>
<li>observe tap</li>
<li>bind btn.title</li>
<li>bind btn.image</li>
<li>bind isEnable</li>
</ul>
<a id="more"></a>
<h2 id="observe-tap"><a href="#observe-tap" class="headerlink" title="observe tap"></a>observe tap</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button.rx.tap.subscribe(onNext: &#123; [weak self] in</span><br><span class="line">                print(&quot;按钮被点击&quot;)</span><br><span class="line">            &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h2 id="bind-btn-title"><a href="#bind-btn-title" class="headerlink" title="bind btn.title"></a>bind btn.title</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个计时器（每1秒发送一个索引数）</span><br><span class="line">let timer &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;根据索引数拼接最新的标题，并绑定到button上</span><br><span class="line">timer.map&#123;&quot;计数\($0)&quot;&#125;</span><br><span class="line">    .bind(to: button.rx.title(for: .normal))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h2 id="bind-btn-image"><a href="#bind-btn-image" class="headerlink" title="bind btn.image"></a>bind btn.image</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个计时器（每1秒发送一个索引数）</span><br><span class="line">let timer &#x3D; Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;根据索引数选择对应的按钮图标，并绑定到button上</span><br><span class="line">timer.map(&#123;</span><br><span class="line">    let name &#x3D; $0%2 &#x3D;&#x3D; 0 ? &quot;one&quot; : &quot;two&quot;</span><br><span class="line">    return UIImage(named: name)!</span><br><span class="line">&#125;)</span><br><span class="line">.bind(to: button.rx.image())</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h2 id="bind-isEnable"><a href="#bind-isEnable" class="headerlink" title="bind isEnable"></a>bind isEnable</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch1.rx.isOn</span><br><span class="line">    .bind(to: button1.rx.isEnabled)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift symbol(s) not found for architecture xxx 解决办法</title>
    <url>/p/c4b0129.html</url>
    <content><![CDATA[<p>对与Objective-C环境下，如果出现‘Undefined symbols for architecture xxx:’问题可以按照一下步骤排查</p>
<a id="more"></a>

<ul>
<li>未导入框架</li>
<li>库路径 头文件路径不对 删除</li>
<li>Other Linker Flags 改为 -lz或－ObjC</li>
<li>找不到库 删除重新导入静态库</li>
<li>是否支持armv7 armv64 i386</li>
</ul>
<p>在Swift环境下却有些变化，我遇到在Swift环境下导入静态库，通过添加桥接文件成功调用API，但在编译阶段报‘symbol(s) not found for architecture xxx’错误，记录下排查思路：</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>Xcode 10.1,Swift 4.2</p>
<p>创建新项目JDSwiftTestAlib，接入微博SDK：libWeiboSDK，新建桥接文件JDSwiftTestAlib-Bridging-Header.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef JDSwiftTestAlib_Bridging_Header_h</span><br><span class="line">#define JDSwiftTestAlib_Bridging_Header_h</span><br><span class="line"></span><br><span class="line">#import &quot;Test.h&quot;</span><br><span class="line"></span><br><span class="line">#import &quot;libWeiBoSDK&#x2F;WeiboSDK.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="成功链接OC文件"><a href="#成功链接OC文件" class="headerlink" title="成功链接OC文件"></a>成功链接OC文件</h3><p><img src="/images/swift_error_a_001.png" alt=""></p>
<h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p><img src="/images/swift_error_a_002.png" alt=""></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>symbol(s) not found for architecture xxx，优先考虑上文的5种情况，猜测可能是Build Setting中没有配置正确的link路径</p>
<p><img src="/images/swift_error_a_003.png" alt=""></p>
<p>但经过多次修改排除这个可能行，疑惑之下回归Log 分析</p>
<p><img src="/images/swift_error_a_002.png" alt=""></p>
<p>缺少某个库，log显示可能是Photo相关的库，对比了OC环境下正常的项目，并没有Phtot相关库，考虑到Swift环境由于API不稳定，并没有集成到iOS系统上，猜测可能是需要显式添加某些在OC环境下默认加载的framwork</p>
<p><img src="/images/swift_error_a_004.png" alt=""></p>
<p>添加Photo.framework</p>
<p><img src="/images/swift_error_a_005.png" alt=""></p>
<p>运行成功</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Swift环境和OC环境的差异需要区分，排查思路不够清晰，应该更注重log的分析，应该多了解下库的链接</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift:闭包Closures简析</title>
    <url>/p/25133bb2.html</url>
    <content><![CDATA[<blockquote>
<p>相对于OC的block有很多差异</p>
</blockquote>
<h2 id="Nonescaping-逃逸闭包"><a href="#Nonescaping-逃逸闭包" class="headerlink" title="Nonescaping 逃逸闭包"></a>Nonescaping 逃逸闭包</h2><p>Swift闭包Closure的概念类似于OC中的Block，但使用上有很多差异，首先，Swift3.x中，传递闭包到函数中的时候，系统会默认为非逃逸闭包类型 (Nonescaping Closures)，有非逃逸闭包类型必然就有逃逸闭包(Escaping Closures)，两种类型主要差别在于生命周期。</p>
<h2 id="lifeCycle-生命周期"><a href="#lifeCycle-生命周期" class="headerlink" title="lifeCycle 生命周期"></a>lifeCycle 生命周期</h2><p>非逃逸闭包指把闭包作为参数传递给函数–&gt;函数中运行该闭包–&gt;退出函数–&gt;release</p>
<p>逃逸闭包其生命周期可能长于相关函数，当函数退出的时候，逃逸闭包的引用仍然被其他对象持有，不会在相关函数结束后释放，可用于异步回调等场景。</p>
<p>从中我们可以看到Swift在对内存管理上与OC的差异，更严格的内存管理也是Swift比OC高效的原因。</p>
<h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>逃逸闭包需要用@escaping标记：</p>
<p><code>func doSomething(callback: @escaping (_ responseObject: String)-&gt;()){}</code></p>
<h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>了解一下Closures的便捷写法，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [“a&quot;, “b&quot;, &quot;c&quot;, &quot;d”]</span><br><span class="line">let sortedList &#x3D; list.sort &#123; (one: String, two: String) -&gt; Bool inreturnone &lt; two &#125;</span><br></pre></td></tr></table></figure>

<p>可以这么简化：</p>
<p><code>let sortedList = list.sort { (one, two) -&gt; Bool in return one &lt; two }</code></p>
<p>返回类型也可以推算出来，所以可以去掉闭包的返回类型：</p>
<p><code>let sortedList = list.sort { (one, two) in return one &lt; two }</code></p>
<p>可以用<code>$i</code>符号替换掉参数的名字，代码然后就变成这样：</p>
<p><code>let sortedList = list.sort { return $0 &lt; $1 }</code></p>
<p>在单语句的闭包中，关键字return也可以省略。最后一条语句的返回值就变成闭包的返回值：</p>
<p><code>let sortedList = list.sort { $0 &lt; $1 }</code></p>
<p>到目前已经变得非常简单了，但还可以继续优化。</p>
<p>对字符串来说，有一个字符串比较函数，定义如下：</p>
<p><code>func &lt;(lhs: String, rhs: String) -&gt; Bool</code></p>
<p>使用这个函数可以让你的Code更加简洁, 如下：</p>
<p><code>let sortedList = list.sort(&lt;)</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift学习了一段时间后，通过了解其对内存的管理明显感觉到一种与OC不同的编程思想，这才是Swift的魅力所在。</p>
<p>##参考</p>
<p><a href="docs.swift.org">docs.swift.org</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>The data couldn’t be read because it isn’t in the correct format错误</title>
    <url>/p/22942e95.html</url>
    <content><![CDATA[<h1 id="打包导出（Export）失败"><a href="#打包导出（Export）失败" class="headerlink" title="打包导出（Export）失败"></a>打包导出（Export）失败</h1><h2 id="可能1-Xcode配置错误"><a href="#可能1-Xcode配置错误" class="headerlink" title="可能1:Xcode配置错误"></a>可能1:Xcode配置错误</h2><p>点击Xcode的导出（Export）时提示The data couldn’t be read because it isn’t in the correct format.或者使用Jenkins等</p>
<p>用脚本打包提示如下错误：</p>
<p>原因是Xcode9帮你添加了一个Code Signing Style的配置字段，该字段需要和Automatically manage signing对应，使用Automatically manage signing时该字段的值需要为Automatic，不使用Automatically manage signing时该字段的值需要为Manual，上述错误就是因为配置不对应导致的，修改对应即可。</p>
<h2 id="可能2-Ruby环境错误"><a href="#可能2-Ruby环境错误" class="headerlink" title="可能2:Ruby环境错误"></a>可能2:Ruby环境错误</h2><p>另一中可能是电脑的Ruby环境错误，如没有指定Ruby版本等，可以通过nvm –help命令检查下</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableView滚动优化</title>
    <url>/p/undefined.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>What Remains of Edith Finch - Home</title>
    <url>/p/fa3fafc.html</url>
    <content><![CDATA[<h1 id="伊迪丝·芬奇的记忆"><a href="#伊迪丝·芬奇的记忆" class="headerlink" title="伊迪丝·芬奇的记忆"></a>伊迪丝·芬奇的记忆</h1><p><img src="/imags/blog_edith_finch_home.png" alt=""></p>
<p>死亡并不是逝者一个人的事，它还会给活下来的人心中留下些东西，是阴影还是阳光，则取决于我们如何看它。</p>
<a id="more"></a>

<p>如何去了解一个已经离开的人，在Edith的故事中，从一座老房子开始，在浓郁鲜艳的画面中，展示每一个故人的房间中的痕迹，风格、装饰、玩具、书记、手工、照片，在时光的长河中，这一点点的水滴刚好让我们一窥他们的人生，在这一过程中，通过无与伦比的叙事表现力，过去的人生栩栩如生地展示出来，用如此美丽的方式来纪念死亡。</p>
<p>家人的死亡是残酷的，但是怎么去面对这些残酷的事情；芬奇家族用着梦幻童话般的故事来告诉着自己的孩子，他们家族也许真的存在诅咒，无论是身体或者精神他们都有先天的问题，运气也差到了极点，但是他们家族的人并没有每天被死亡的恐惧包围，而是积极的面对生活，也用这些故事来让自己的孩子更积极；他们都是家人，不会因为死亡就被忘却掉，就像寻梦环游记里说的那样，真正的死亡不是肉体的消失，真正的死是所有的亲人都忘记的你时候，亲情不会随着生命的消逝而消失不见。</p>
<p>有什么是比坦然接受悲伤的现实更悲伤的呢？ 感受一幕幕的悲剧后，只能看着尘封已久的房屋，想起命运，想起死亡，想的最多的还是这种面对诅咒的态度。逃避，迎接，惊讶，平静……一个家族沉淀下来的悲伤，厚重而毫无锐利。它只会用一个个回忆感染你，慢慢渗透进你的内心，吸引你走进Finch家族的世界。它用它独特的手法和音乐让你内心慢慢与这个家族一起经历时间。它像一本日记，古老，无言，但是打动人心的力量永不消失。</p>
<p>要知道，人生的最后也就只剩一座墓碑而已。</p>
]]></content>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>VLC:各种模块说明</title>
    <url>/p/bb26fcf3.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>visual    可视化过滤器</td>
<td></td>
</tr>
<tr>
<td>projectm    libprojectM 特效</td>
<td></td>
</tr>
<tr>
<td>goom    Goom 效果</td>
<td></td>
</tr>
<tr>
<td>glspectrum    3D OpenGL spectrum visualization</td>
<td></td>
</tr>
<tr>
<td>wall    显示墙滤镜</td>
<td></td>
</tr>
<tr>
<td>panoramix    摄像头: 覆盖视频滤镜的墙</td>
<td></td>
</tr>
<tr>
<td>clone    克隆视频滤镜</td>
<td></td>
</tr>
<tr>
<td>yuv    YUV 视频输出</td>
<td></td>
</tr>
<tr>
<td>wingdi    Windows GDI 视频输出</td>
<td></td>
</tr>
<tr>
<td>vmem    显存输出</td>
<td></td>
</tr>
<tr>
<td>vdummy    dummy 视频输出</td>
<td></td>
</tr>
<tr>
<td>vdummy    统计视频输出</td>
<td></td>
</tr>
<tr>
<td>gl    OpenGL 视频输出 (实验性)</td>
<td></td>
</tr>
<tr>
<td>glwin32    OpenGL 视频输出</td>
<td></td>
</tr>
<tr>
<td>drawable    嵌入窗口视频</td>
<td></td>
</tr>
<tr>
<td>directdraw    DirectX (DirectDraw) 视频输出</td>
<td></td>
</tr>
<tr>
<td>direct3d    Direct3D 视频输出</td>
<td></td>
</tr>
<tr>
<td>direct2d    Direct2D 视频输出</td>
<td></td>
</tr>
<tr>
<td>caca    彩色字符艺术视频输出</td>
<td></td>
</tr>
<tr>
<td>yuvp    YUVP 转换器</td>
<td></td>
</tr>
<tr>
<td>wave    波形视频滤镜</td>
<td></td>
</tr>
<tr>
<td>vhs    VHS 影片效果视频滤镜</td>
<td></td>
</tr>
<tr>
<td>transform    视频转换滤镜</td>
<td></td>
</tr>
<tr>
<td>subsdelay    字幕延迟</td>
<td></td>
</tr>
<tr>
<td>sharpen    锐化视频滤镜</td>
<td></td>
</tr>
<tr>
<td>sepia    深褐视频滤镜</td>
<td></td>
</tr>
<tr>
<td>scene    场景视频滤镜</td>
<td></td>
</tr>
<tr>
<td>scale    视频比例滤镜</td>
<td></td>
</tr>
<tr>
<td>rss    RSS 与 Atom feed 显示</td>
<td></td>
</tr>
<tr>
<td>rotate    旋转视频滤镜</td>
<td></td>
</tr>
<tr>
<td>ripple    脉动视频滤镜</td>
<td></td>
</tr>
<tr>
<td>remoteosd    通过 VNC 的远程 OSD</td>
<td></td>
</tr>
<tr>
<td>puzzle    智力交互游戏视频滤镜</td>
<td></td>
</tr>
<tr>
<td>psychedelic    迷幻视频滤镜</td>
<td></td>
</tr>
<tr>
<td>postproc    视频预处理滤镜</td>
<td></td>
</tr>
<tr>
<td>posterize    色调分离视频滤镜</td>
<td></td>
</tr>
<tr>
<td>oldmovie    老电影效果视频滤镜</td>
<td></td>
</tr>
<tr>
<td>motiondetect    运动检测视频滤镜</td>
<td></td>
</tr>
<tr>
<td>motionblur    动态模糊滤镜</td>
<td></td>
</tr>
<tr>
<td>mosaic    Mosaic 视频子源</td>
<td></td>
</tr>
<tr>
<td>mirror    镜像视频滤镜</td>
<td></td>
</tr>
<tr>
<td>marq    Marquee 显示</td>
<td></td>
</tr>
<tr>
<td>magnify    放大/变焦交互视频滤镜</td>
<td></td>
</tr>
<tr>
<td>logo    标志子源滤镜</td>
<td></td>
</tr>
<tr>
<td>logo    标志视频滤镜</td>
<td></td>
</tr>
<tr>
<td>invert    倒转视频滤镜</td>
<td></td>
</tr>
<tr>
<td>hqdn3d    高质量 3D 降噪滤镜</td>
<td></td>
</tr>
<tr>
<td>grain    纹理视频滤镜</td>
<td></td>
</tr>
<tr>
<td>gradient    高斯视频滤镜</td>
<td></td>
</tr>
<tr>
<td>gradfun    Gradfun 视频滤镜</td>
<td></td>
</tr>
<tr>
<td>gaussianblur    高斯模糊滤镜</td>
<td></td>
</tr>
<tr>
<td>freeze    交互区域静止视频滤镜</td>
<td></td>
</tr>
<tr>
<td>extract    释放 RGB 组件视频滤镜</td>
<td></td>
</tr>
<tr>
<td>erase    擦除视频滤镜</td>
<td></td>
</tr>
<tr>
<td>deinterlace    反交错视频滤镜</td>
<td></td>
</tr>
<tr>
<td>croppadd    视频裁剪滤镜</td>
<td></td>
</tr>
<tr>
<td>colorthres    色彩阈值滤镜</td>
<td></td>
</tr>
<tr>
<td>canvas    Canvas 视频滤镜</td>
<td></td>
</tr>
<tr>
<td>bluescreen    蓝屏视频滤镜</td>
<td></td>
</tr>
<tr>
<td>blend    视频图片混合</td>
<td></td>
</tr>
<tr>
<td>blendbench    混合基准滤镜</td>
<td></td>
</tr>
<tr>
<td>ball    球视频滤镜</td>
<td></td>
</tr>
<tr>
<td>audiobargraph_v    音频直方图视频子滤镜</td>
<td></td>
</tr>
<tr>
<td>audiobargraph_v    音频直方图视频子滤镜</td>
<td></td>
</tr>
<tr>
<td>atmo    AtmoLight 滤镜</td>
<td></td>
</tr>
<tr>
<td>antiflicker    antiflicker 视频滤镜</td>
<td></td>
</tr>
<tr>
<td>anaglyph    将 3D 画面转换为立体图像的视频滤镜</td>
<td></td>
</tr>
<tr>
<td>alphamask    Alpha 掩码视频滤镜</td>
<td></td>
</tr>
<tr>
<td>adjust    图像属性滤镜</td>
<td></td>
</tr>
<tr>
<td>yuy2_i422    Conversions from YUY2,YUNV,YVYU,UYVY,UYNV,Y422,cyuv to I422</td>
<td></td>
</tr>
<tr>
<td>yuy2_i420    Conversions from YUY2,YUNV,YVYU,UYVY,UYNV,Y422,cyuv to I420</td>
<td></td>
</tr>
<tr>
<td>swscale    视频比例滤镜</td>
<td></td>
</tr>
<tr>
<td>rv32    RV32 转换滤镜</td>
<td></td>
</tr>
<tr>
<td>i422_yuy2_sse2    SSE2 conversions from I422 to YUY2,YUNV,YVYU,UYVY,UYNV,Y422,IUYV,cyuv</td>
<td></td>
</tr>
<tr>
<td>i422_yuy2    Conversions from I422 to YUY2,YUNV,YVYU,UYVY,UYNV,Y422,IUYV,cyuv,Y211</td>
<td></td>
</tr>
<tr>
<td>i422_yuy2_mmx    MMX conversions from I422 to YUY2,YUNV,YVYU,UYVY,UYNV,Y422,IUYV,cyuv</td>
<td></td>
</tr>
<tr>
<td>i422_i420    Conversions from I422,J422 to I420,IYUV,J420,YV12,YUVA</td>
<td></td>
</tr>
<tr>
<td>i420_yuy2_sse2    SSE2 conversions from I420,IYUV,YV12 to YUY2,YUNV,YVYU,UYVY,UYNV,Y422,IUYV,cyuv</td>
<td></td>
</tr>
<tr>
<td>i420_yuy2    Conversions from I420,IYUV,YV12 to YUY2,YUNV,YVYU,UYVY,UYNV,Y422,IUYV,cyuv,Y211</td>
<td></td>
</tr>
<tr>
<td>i420_yuy2_mmx    MMX conversions from I420,IYUV,YV12 to YUY2,YUNV,YVYU,UYVY,UYNV,Y422,IUYV,cyuv</td>
<td></td>
</tr>
<tr>
<td>i420_rgb_sse2    SSE2 I420,IYUV,YV12 到 RV15,RV16,RV24,RV32 转换</td>
<td></td>
</tr>
<tr>
<td>i420_rgb    I420,IYUV,YV12 到 RGB2,RV15,RV16,RV24,RV32 转换</td>
<td></td>
</tr>
<tr>
<td>i420_rgb_mmx    MMX I420,IYUV,YV12 到 RV15,RV16,RV24,RV32 转换</td>
<td></td>
</tr>
<tr>
<td>grey_yuv    Conversions from GREY to I420,YUY2</td>
<td></td>
</tr>
<tr>
<td>chain    使用一个链式视频滤镜模块过滤视频</td>
<td></td>
</tr>
<tr>
<td>tdummy    dummy 字体渲染器</td>
<td></td>
</tr>
<tr>
<td>freetype    Freetype2 字体渲染器</td>
<td></td>
</tr>
<tr>
<td>stream_out_transc    ode 转码流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_stats    写入串流的统计信息</td>
<td></td>
</tr>
<tr>
<td>stream_out_standa    rd 标准流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_smem    输出到内存缓冲器的流</td>
<td></td>
</tr>
<tr>
<td>stream_out_setid    更改通量流的 id</td>
<td></td>
</tr>
<tr>
<td>stream_out_setid    更改通量流的语言</td>
<td></td>
</tr>
<tr>
<td>stream_out_rtp    RTP 流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_rtp    RTSP VoD 服务器</td>
<td></td>
</tr>
<tr>
<td>stream_out_record    录制串流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_raop    远程音频输出协议 (RAOP) 串流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_mosaic    _bridge Mosaic 桥流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_langfr    omtelx teletext 动态语言设置</td>
<td></td>
</tr>
<tr>
<td>stream_out_gather    正在收集流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_es    通量流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_duplic    ate 复制流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_dummy    dummy 串流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_displa    y 显示流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_descri    ption 描述流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_delay    延迟流</td>
<td></td>
</tr>
<tr>
<td>stream_out_chroma    print Chromaprint stream output</td>
<td></td>
</tr>
<tr>
<td>stream_out_bridge    桥接流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_bridge    桥接流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_bridge    桥接流输出</td>
<td></td>
</tr>
<tr>
<td>stream_out_autode    l 自动添加/删除输入流</td>
<td></td>
</tr>
<tr>
<td>smooth    平滑</td>
<td></td>
</tr>
<tr>
<td>record    内部串流录制</td>
<td></td>
</tr>
<tr>
<td>httplive    Http 直播串流流滤镜</td>
<td></td>
</tr>
<tr>
<td>dash    HTTP 动态自适应串流</td>
<td></td>
</tr>
<tr>
<td>windrive    windrive</td>
<td></td>
</tr>
<tr>
<td>windrive    windrive</td>
<td></td>
</tr>
<tr>
<td>windrive    光盘</td>
<td></td>
</tr>
<tr>
<td>upnp    通用即插即播</td>
<td></td>
</tr>
<tr>
<td>upnp    通用即插即播</td>
<td></td>
</tr>
<tr>
<td>sap    网络流 (SAP)</td>
<td></td>
</tr>
<tr>
<td>sap    SDP 描述解析器</td>
<td></td>
</tr>
<tr>
<td>sap    网络流 (SAP)</td>
<td></td>
</tr>
<tr>
<td>podcast    Podcast</td>
<td></td>
</tr>
<tr>
<td>podcast    Podcast</td>
<td></td>
</tr>
<tr>
<td>mediadirs    我的视频</td>
<td></td>
</tr>
<tr>
<td>mediadirs    我的视频</td>
<td></td>
</tr>
<tr>
<td>mediadirs    我的图片</td>
<td></td>
</tr>
<tr>
<td>mediadirs    我的音乐</td>
<td></td>
</tr>
<tr>
<td>packetizer_vc1    VC-1 封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_mpegvi    deo MPEG-I/II 视频封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_mpeg4v    ideo MPEG4 视频封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_mpeg4a    udio MPEG4 音频封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_mlp    MLP/TrueHD 解析器</td>
<td></td>
</tr>
<tr>
<td>packetizer_hevc    HEVC/H.265 视频封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_h264    H.264 视频封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_flac    Flac 音频封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_dirac    Dirac 封包器</td>
<td></td>
</tr>
<tr>
<td>packetizer_copy    复制封包器</td>
<td></td>
</tr>
<tr>
<td>mux_wav    WAV 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_ts    TS 复用器 (libdvbpsi)</td>
<td></td>
</tr>
<tr>
<td>mux_ps    PS 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_ogg    Ogg/OGM 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_mpjpeg    多帧 JPEG 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_mp4    MP4/MOV 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_dummy    dummy/raw 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_avi    AVI 复用器</td>
<td></td>
</tr>
<tr>
<td>mux_asf    ASF 复用器</td>
<td></td>
</tr>
<tr>
<td>xml    XML 解析器 (使用 libxml2)</td>
<td></td>
</tr>
<tr>
<td>xml    XML 解析器 (使用 libxml2)</td>
<td></td>
</tr>
<tr>
<td>vod_rtsp    传统 RTSP VoD 服务器</td>
<td></td>
</tr>
<tr>
<td>stats    统计数据编码器函数</td>
<td></td>
</tr>
<tr>
<td>stats    统计数据去复用函数</td>
<td></td>
</tr>
<tr>
<td>stats    统计数据解码器函数</td>
<td></td>
</tr>
<tr>
<td>logger    文件日志</td>
<td></td>
</tr>
<tr>
<td>gnutls    GNU TLS 传输层安全</td>
<td></td>
</tr>
<tr>
<td>gnutls    GNU TLS 服务器</td>
<td></td>
</tr>
<tr>
<td>fingerprinter    Track fingerprinter (based on Acoustid)</td>
<td></td>
</tr>
<tr>
<td>export    export</td>
<td></td>
</tr>
<tr>
<td>export    M3U 播放列表导出</td>
<td></td>
</tr>
<tr>
<td>export    XSPF 播放列表导出器</td>
<td></td>
</tr>
<tr>
<td>export    M3U8 播放列表导出</td>
<td></td>
</tr>
<tr>
<td>export    M3U 播放列表导出</td>
<td></td>
</tr>
<tr>
<td>audioscrobbler    提交已播放的歌曲给 last.fm</td>
<td></td>
</tr>
<tr>
<td>vorepository    addons.videolan.org addons finder</td>
<td></td>
</tr>
<tr>
<td>vorepository    single .vlp archive addons finder</td>
<td></td>
</tr>
<tr>
<td>fsstorage    Addons local storage installer</td>
<td></td>
</tr>
<tr>
<td>fsstorage    Addons local storage lister</td>
<td></td>
</tr>
<tr>
<td>taglib    taglib</td>
<td></td>
</tr>
<tr>
<td>taglib    taglib</td>
<td></td>
</tr>
<tr>
<td>folder    文件夹元数据</td>
<td></td>
</tr>
<tr>
<td>lua    Lua 解析器</td>
<td></td>
</tr>
<tr>
<td>lua    Lua 解析器</td>
<td></td>
</tr>
<tr>
<td>lua    Lua SD 模块</td>
<td></td>
</tr>
<tr>
<td>lua    Lua 扩展</td>
<td></td>
</tr>
<tr>
<td>lua    使用 lua 脚本装取封面</td>
<td></td>
</tr>
<tr>
<td>lua    Lua 播放列表解析器界面</td>
<td></td>
</tr>
<tr>
<td>lua    使用 lua 脚本读取元数据</td>
<td></td>
</tr>
<tr>
<td>lua    使用 lua 脚本装取元数据</td>
<td></td>
</tr>
<tr>
<td>lua    Lua Telnet</td>
<td></td>
</tr>
<tr>
<td>lua    命令行界面</td>
<td></td>
</tr>
<tr>
<td>lua    Lua HTTP</td>
<td></td>
</tr>
<tr>
<td>skins2    定制界面</td>
<td></td>
</tr>
<tr>
<td>skins2    定制界面</td>
<td></td>
</tr>
<tr>
<td>qt4    Qt 界面</td>
<td></td>
</tr>
<tr>
<td>qt4    Qt 界面</td>
<td></td>
</tr>
<tr>
<td>qt4    Dialogs provider</td>
<td></td>
</tr>
<tr>
<td>xa    XA 去复用器</td>
<td></td>
</tr>
<tr>
<td>wav    WAV 去复用器</td>
<td></td>
</tr>
<tr>
<td>voc    VOC 去复用器</td>
<td></td>
</tr>
<tr>
<td>vobsub    Vobsub 字幕解释器</td>
<td></td>
</tr>
<tr>
<td>vc1    VC1 视频去复用器</td>
<td></td>
</tr>
<tr>
<td>ty    TY 流音频/视频去复用</td>
<td></td>
</tr>
<tr>
<td>tta    TTA 去复用器</td>
<td></td>
</tr>
<tr>
<td>ts    MPEG 传输流去复用器</td>
<td></td>
</tr>
<tr>
<td>subtitle    文本字幕解析器</td>
<td></td>
</tr>
<tr>
<td>smf    SMF 去复用器</td>
<td></td>
</tr>
<tr>
<td>sid    C64 sid 去复用器</td>
<td></td>
</tr>
<tr>
<td>real    Real 去复用器</td>
<td></td>
</tr>
<tr>
<td>rawvid    raw 视频去复用器</td>
<td></td>
</tr>
<tr>
<td>rawdv    DV (数字视频) 去复用器</td>
<td></td>
</tr>
<tr>
<td>rawaud    raw 音频去复用器</td>
<td></td>
</tr>
<tr>
<td>pva    PVA 去复用器</td>
<td></td>
</tr>
<tr>
<td>ps    MPEG-PS 去复用器</td>
<td></td>
</tr>
<tr>
<td>ps    MPEG-PS 去复用器</td>
<td></td>
</tr>
<tr>
<td>playlist    播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 ZPL 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 WPL 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    iTunes 音乐库导入器</td>
<td></td>
</tr>
<tr>
<td>playlist    dummy ifo 去复用</td>
<td></td>
</tr>
<tr>
<td>playlist    Google 视频播放列表导入器</td>
<td></td>
</tr>
<tr>
<td>playlist    QuickTime 媒体链接导入器</td>
<td></td>
</tr>
<tr>
<td>playlist    Kasenna 媒体库解析器</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 ASX 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    新建 winamp 5.2 shoutcast 导入</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 XSPF 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    Podcast 解析器</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 DVB 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 B4S 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 PLS 播放列表</td>
<td></td>
</tr>
<tr>
<td>playlist    RAM 播放列表导入</td>
<td></td>
</tr>
<tr>
<td>playlist    导入 M3U 播放列表</td>
<td></td>
</tr>
<tr>
<td>ogg    OGG 去复用器</td>
<td></td>
</tr>
<tr>
<td>nuv    Nuv 去复用器</td>
<td></td>
</tr>
<tr>
<td>nsv    NullSoft 去复用器</td>
<td></td>
</tr>
<tr>
<td>nsc    Windows Media NSC 元去复用</td>
<td></td>
</tr>
<tr>
<td>mpgv    MPEG-I/II 视频去复用器</td>
<td></td>
</tr>
<tr>
<td>mpc    MusePack 去复用器</td>
<td></td>
</tr>
<tr>
<td>mp4    MP4 串流去复用器</td>
<td></td>
</tr>
<tr>
<td>mod    MOD 去复用器 (libmodplug)</td>
<td></td>
</tr>
<tr>
<td>mkv    Matroska 串流去复用器</td>
<td></td>
</tr>
<tr>
<td>mjpeg    M-JPEG 摄像机去复用器</td>
<td></td>
</tr>
<tr>
<td>image    图像去复用器</td>
<td></td>
</tr>
<tr>
<td>hevc    HEVC/H.265 视频去复用器</td>
<td></td>
</tr>
<tr>
<td>h264    H264 视频去复用器</td>
<td></td>
</tr>
<tr>
<td>gme    Game Music Emu</td>
<td></td>
</tr>
<tr>
<td>flacsys    FLAC 去复用器</td>
<td></td>
</tr>
<tr>
<td>es    MPEG-I/II/4 / A52 / DTS / MLP 音频</td>
<td></td>
</tr>
<tr>
<td>es    MPEG-4 视频</td>
<td></td>
</tr>
<tr>
<td>diracsys    Dirac 视频去复用器</td>
<td></td>
</tr>
<tr>
<td>demux_stl    EBU STL 字幕解析器</td>
<td></td>
</tr>
<tr>
<td>demux_cdg    CDG 去复用器</td>
<td></td>
</tr>
<tr>
<td>demuxdump    文件转储器</td>
<td></td>
</tr>
<tr>
<td>caf    CAF 去复用器</td>
<td></td>
</tr>
<tr>
<td>avi    AVI 去复用器</td>
<td></td>
</tr>
<tr>
<td>au    AU 去复用器</td>
<td></td>
</tr>
<tr>
<td>asf    ASF/WMV 去复用器</td>
<td></td>
</tr>
<tr>
<td>aiff    AIFF 去复用器</td>
<td></td>
</tr>
<tr>
<td>win_msg    Windows messages interface</td>
<td></td>
</tr>
<tr>
<td>win32    全局热键接口</td>
<td></td>
</tr>
<tr>
<td>oldrc    远程控制接口</td>
<td></td>
</tr>
<tr>
<td>ntservice    Windows 服务接口</td>
<td></td>
</tr>
<tr>
<td>netsync    网络同步</td>
<td></td>
</tr>
<tr>
<td>hotkeys    热键管理接口</td>
<td></td>
</tr>
<tr>
<td>gestures    鼠标手势控制接口</td>
<td></td>
</tr>
<tr>
<td>dummy    dummy 界面</td>
<td></td>
</tr>
<tr>
<td>zvbi    VBI 及 Teletext 解码器</td>
<td></td>
</tr>
<tr>
<td>x265    H.265/HEVC 编码器 (x265)</td>
<td></td>
</tr>
<tr>
<td>x264    H.264/MPEG-4 Part 10/AVC 编码器 (x264)</td>
<td></td>
</tr>
<tr>
<td>vpx    WebM 视频解码器</td>
<td></td>
</tr>
<tr>
<td>vorbis    Vorbis 音频解码器</td>
<td></td>
</tr>
<tr>
<td>vorbis    Vorbis 音频编码器</td>
<td></td>
</tr>
<tr>
<td>vorbis    Vorbis 音频封包器</td>
<td></td>
</tr>
<tr>
<td>uleaddvaudio    Ulead DV 音频解码器</td>
<td></td>
</tr>
<tr>
<td>twolame    Libtwolame 音频解码器</td>
<td></td>
</tr>
<tr>
<td>theora    Theora 视频解码器</td>
<td></td>
</tr>
<tr>
<td>theora    Theora 视频编码器</td>
<td></td>
</tr>
<tr>
<td>theora    Theora 视频封包器</td>
<td></td>
</tr>
<tr>
<td>t140    T.140 文本编码器</td>
<td></td>
</tr>
<tr>
<td>svcdsub    Philips OGT (SVCD 字幕) 解码器</td>
<td></td>
</tr>
<tr>
<td>svcdsub    Philips OGT (SVCD 字幕) 封包器</td>
<td></td>
</tr>
<tr>
<td>subsusf    USF 字幕解码器</td>
<td></td>
</tr>
<tr>
<td>substx3g    tx3g 字幕解码器</td>
<td></td>
</tr>
<tr>
<td>subsdec    文本字幕解码器</td>
<td></td>
</tr>
<tr>
<td>stl    EBU STL 字幕解码器</td>
<td></td>
</tr>
<tr>
<td>spudec    DVD 字幕解码器</td>
<td></td>
</tr>
<tr>
<td>spudec    DVD 字幕封包器</td>
<td></td>
</tr>
<tr>
<td>speex    Speex 音频解码器</td>
<td></td>
</tr>
<tr>
<td>speex    Speex 音频编码器</td>
<td></td>
</tr>
<tr>
<td>speex    Speex 音频封包器</td>
<td></td>
</tr>
<tr>
<td>scte27    SCTE-27 decoder</td>
<td></td>
</tr>
<tr>
<td>schroedinger    Dirac 视频解码器，使用 libschroedinger</td>
<td></td>
</tr>
<tr>
<td>schroedinger    Dirac 视频编码器，使用 libschroedinger</td>
<td></td>
</tr>
<tr>
<td>rawvideo    伪 raw 视频解码器</td>
<td></td>
</tr>
<tr>
<td>rawvideo    伪 raw 视频封包器</td>
<td></td>
</tr>
<tr>
<td>quicktime    QuickTime 库解码器</td>
<td></td>
</tr>
<tr>
<td>qsv    Intel QuickSync Video 的 MPEG4-Part10/MPEG2 (亦作 H.264/H.262) 编码器</td>
<td></td>
</tr>
<tr>
<td>png    PNG 视频解码器</td>
<td></td>
</tr>
<tr>
<td>png    PNG 视频编码器</td>
<td></td>
</tr>
<tr>
<td>opus    Opus 音频解码器</td>
<td></td>
</tr>
<tr>
<td>opus    Opus 音频编码器</td>
<td></td>
</tr>
<tr>
<td>mpeg_audio    MPEG 音频层 I/II/III 解码器</td>
<td></td>
</tr>
<tr>
<td>mpeg_audio    MPEG 音频层 I/II/III 封包器</td>
<td></td>
</tr>
<tr>
<td>mft    Media Foundation Transform 解码器</td>
<td></td>
</tr>
<tr>
<td>lpcm    线性 PCM 音频解码器</td>
<td></td>
</tr>
<tr>
<td>lpcm    线性 PCM 音频编码器</td>
<td></td>
</tr>
<tr>
<td>lpcm    线性 PCM 音频封包器</td>
<td></td>
</tr>
<tr>
<td>libmpeg2    MPEG I/II 视频解码器 (使用 libmpeg2)</td>
<td></td>
</tr>
<tr>
<td>libass    使用 libass 渲染字幕</td>
<td></td>
</tr>
<tr>
<td>kate    Kate 重叠解码器</td>
<td></td>
</tr>
<tr>
<td>jpeg    JPEG 图像解码器</td>
<td></td>
</tr>
<tr>
<td>jpeg    JPEG 图像编码器</td>
<td></td>
</tr>
<tr>
<td>g711    G.711 解码器</td>
<td></td>
</tr>
<tr>
<td>g711    G.711 编码器</td>
<td></td>
</tr>
<tr>
<td>flac    Flac 音频解码器</td>
<td></td>
</tr>
<tr>
<td>flac    Flac 音频编码器</td>
<td></td>
</tr>
<tr>
<td>faad    AAC 音频解码器 (使用 libfaad2)</td>
<td></td>
</tr>
<tr>
<td>edummy    dummy 编码器</td>
<td></td>
</tr>
<tr>
<td>dxva2    DirectX 视频加速 (DXVA) 2.0</td>
<td></td>
</tr>
<tr>
<td>dvbsub    DVB 字幕解码器</td>
<td></td>
</tr>
<tr>
<td>dvbsub    DVB 字幕编码器</td>
<td></td>
</tr>
<tr>
<td>dts    DTS 解析器</td>
<td></td>
</tr>
<tr>
<td>dts    DTS 音频封包器</td>
<td></td>
</tr>
<tr>
<td>dmo    DirectMedia Object 解码器</td>
<td></td>
</tr>
<tr>
<td>dmo    DirectMedia Object 编码器</td>
<td></td>
</tr>
<tr>
<td>ddummy    dummy 解码器</td>
<td></td>
</tr>
<tr>
<td>ddummy    倾倒解码器</td>
<td></td>
</tr>
<tr>
<td>cvdsub    CVD 字幕解码器</td>
<td></td>
</tr>
<tr>
<td>cvdsub    超级 VCD 字幕封包器</td>
<td></td>
</tr>
<tr>
<td>crystalhd    Crystal HD 硬件视频解码器</td>
<td></td>
</tr>
<tr>
<td>cdg    CDG 视频解码器</td>
<td></td>
</tr>
<tr>
<td>cc    封闭字幕解码器</td>
<td></td>
</tr>
<tr>
<td>avcodec    FFmpeg 音频/视频解码器</td>
<td></td>
</tr>
<tr>
<td>avcodec    avparser 封包器</td>
<td></td>
</tr>
<tr>
<td>avcodec    libavformat AVIO 访问输出</td>
<td></td>
</tr>
<tr>
<td>avcodec    libavformat AVIO 访问</td>
<td></td>
</tr>
<tr>
<td>avcodec    Avformat 复用器</td>
<td></td>
</tr>
<tr>
<td>avcodec    Avformat 去复用器</td>
<td></td>
</tr>
<tr>
<td>avcodec    FFmpeg 音频/视频编码器</td>
<td></td>
</tr>
<tr>
<td>araw    raw/Log 音频解码器</td>
<td></td>
</tr>
<tr>
<td>araw    raw 音频解码器</td>
<td></td>
</tr>
<tr>
<td>aes3    AES3/SMPTE 302M 音频解码器</td>
<td></td>
</tr>
<tr>
<td>aes3    AES3/SMPTE 302M 音频封包器</td>
<td></td>
</tr>
<tr>
<td>adpcm    ADPCM 音频解码器</td>
<td></td>
</tr>
<tr>
<td>a52    A/52 解析器</td>
<td></td>
</tr>
<tr>
<td>a52    A/52 音频封包器</td>
<td></td>
</tr>
<tr>
<td>waveout    WaveOut 音频输出</td>
<td></td>
</tr>
<tr>
<td>wasapi    Windows 音频会话 API 输出</td>
<td></td>
</tr>
<tr>
<td>mmdevice    Windows Multimedia Device output</td>
<td></td>
</tr>
<tr>
<td>directsound    DirectX 音频输出</td>
<td></td>
</tr>
<tr>
<td>directsound    DirectX 音频输出</td>
<td></td>
</tr>
<tr>
<td>amem    音频内存输出</td>
<td></td>
</tr>
<tr>
<td>afile    文件音频输出</td>
<td></td>
</tr>
<tr>
<td>adummy    dummy 音频输出</td>
<td></td>
</tr>
<tr>
<td>integer_mixer    整数音频音量</td>
<td></td>
</tr>
<tr>
<td>float_mixer    单精度音频音量</td>
<td></td>
</tr>
<tr>
<td>ugly_resampler    最近邻音频重采样器</td>
<td></td>
</tr>
<tr>
<td>ugly_resampler    最近邻音频重采样器</td>
<td></td>
</tr>
<tr>
<td>trivial_channel_m    ixer 用于弱音声道混合的音频滤镜</td>
<td></td>
</tr>
<tr>
<td>stereo_widen    简单立体声增强效果</td>
<td></td>
</tr>
<tr>
<td>speex_resampler    Speex 重采样器</td>
<td></td>
</tr>
<tr>
<td>speex_resampler    Speex 重采样器</td>
<td></td>
</tr>
<tr>
<td>spatializer    音频空间化器</td>
<td></td>
</tr>
<tr>
<td>simple_channel_mi    xer 用于简易声道混音的音频滤镜</td>
<td></td>
</tr>
<tr>
<td>scaletempo    音频节拍定标器，与频率同步</td>
<td></td>
</tr>
<tr>
<td>samplerate    Secret Rabbit Code (libsamplerate) 重采样器</td>
<td></td>
</tr>
<tr>
<td>samplerate    Secret Rabbit Code (libsamplerate) 重采样器</td>
<td></td>
</tr>
<tr>
<td>remap    音频声道重映射器</td>
<td></td>
</tr>
<tr>
<td>param_eq    参数均衡器</td>
<td></td>
</tr>
<tr>
<td>normvol    音量规格化</td>
<td></td>
</tr>
<tr>
<td>mpgatofixed32    MPEG 音频解码器</td>
<td></td>
</tr>
<tr>
<td>mono    立体声转单声道缩混器</td>
<td></td>
</tr>
<tr>
<td>karaoke    简易卡拉 OK 滤镜</td>
<td></td>
</tr>
<tr>
<td>headphone_channel    _mixer 耳机虚拟空间定位效果</td>
<td></td>
</tr>
<tr>
<td>gain    增益控制滤镜</td>
<td></td>
</tr>
<tr>
<td>equalizer    10 波段均衡器</td>
<td></td>
</tr>
<tr>
<td>dtstospdif    用于 DTS-&gt;S/PDIF 封装的音频滤镜</td>
<td></td>
</tr>
<tr>
<td>dtstofloat32    DTS 逻辑声学音频解码器</td>
<td></td>
</tr>
<tr>
<td>dolby_surround_de    coder 杜比环绕声编码流的简易解码器</td>
<td></td>
</tr>
<tr>
<td>compressor    动态范围压缩器</td>
<td></td>
</tr>
<tr>
<td>chorus_flanger    声音延迟</td>
<td></td>
</tr>
<tr>
<td>audio_format    用于 PCM 格式转换的音频滤镜</td>
<td></td>
</tr>
<tr>
<td>audiobargraph_a    BarGraph 功能的音频部分</td>
<td></td>
</tr>
<tr>
<td>a52tospdif    用于 A/52-&gt;S/PDIF 封装的音频滤镜</td>
<td></td>
</tr>
<tr>
<td>a52tofloat32    ATSC A/52 (AC-3) 音频解码器</td>
<td></td>
</tr>
<tr>
<td>udp    UDP 流输出</td>
<td></td>
</tr>
<tr>
<td>access_output_sho    ut IceCAST 输出</td>
<td></td>
</tr>
<tr>
<td>access_output_liv    ehttp HTTP Live 流输出</td>
<td></td>
</tr>
<tr>
<td>access_output_htt    p HTTP 流输出</td>
<td></td>
</tr>
<tr>
<td>access_output_fil    e 文件流输出</td>
<td></td>
</tr>
<tr>
<td>access_output_dum    my dummy 串流输出</td>
<td></td>
</tr>
<tr>
<td>zip    Zip 文件滤镜</td>
<td></td>
</tr>
<tr>
<td>zip    Zip 访问</td>
<td></td>
</tr>
<tr>
<td>vdr    VDR 录制</td>
<td></td>
</tr>
<tr>
<td>vcd    VCD 输入</td>
<td></td>
</tr>
<tr>
<td>udp    UDP 输入</td>
<td></td>
</tr>
<tr>
<td>timecode    时间码子画面基本流生成器</td>
<td></td>
</tr>
<tr>
<td>tcp    TCP 输入</td>
<td></td>
</tr>
<tr>
<td>smb    SMB 输入</td>
<td></td>
</tr>
<tr>
<td>shm    帧缓冲共享内存</td>
<td></td>
</tr>
<tr>
<td>sftp    SFTP 输入</td>
<td></td>
</tr>
<tr>
<td>sdp    会话描述协议</td>
<td></td>
</tr>
<tr>
<td>screen    屏幕输入</td>
<td></td>
</tr>
<tr>
<td>rtp    实时协议 (RTP) 输入</td>
<td></td>
</tr>
<tr>
<td>rar    Uncompressed RAR</td>
<td></td>
</tr>
<tr>
<td>rar    Uncompressed RAR</td>
<td></td>
</tr>
<tr>
<td>live555    RTP/RTSP/SDP 去复用器 (使用 Live555)</td>
<td></td>
</tr>
<tr>
<td>live555    RTSP/RTP 访问与去复用</td>
<td></td>
</tr>
<tr>
<td>libbluray    蓝光光碟支持 (libbluray)</td>
<td></td>
</tr>
<tr>
<td>imem    内存输入</td>
<td></td>
</tr>
<tr>
<td>imem    内存输入</td>
<td></td>
</tr>
<tr>
<td>idummy    dummy 输入</td>
<td></td>
</tr>
<tr>
<td>http    HTTP 输入</td>
<td></td>
</tr>
<tr>
<td>ftp    FTP 输入</td>
<td></td>
</tr>
<tr>
<td>ftp    FTP 上传输出</td>
<td></td>
</tr>
<tr>
<td>filesystem    文件输入</td>
<td></td>
</tr>
<tr>
<td>filesystem    文件输入</td>
<td></td>
</tr>
<tr>
<td>dvdread    DVDRead 输入 (无菜单支持)</td>
<td></td>
</tr>
<tr>
<td>dvdnav    DVD 导航输入</td>
<td></td>
</tr>
<tr>
<td>dvdnav    DVDnav demuxer</td>
<td></td>
</tr>
<tr>
<td>dtv    数字电视与广播</td>
<td></td>
</tr>
<tr>
<td>dshow    DirectShow 输入</td>
<td></td>
</tr>
<tr>
<td>dshow    DirectShow 输入</td>
<td></td>
</tr>
<tr>
<td>cdda    音频 CD 输入</td>
<td></td>
</tr>
<tr>
<td>attachment    附件输入</td>
<td></td>
</tr>
<tr>
<td>access_realrtsp    Real RTSP</td>
<td></td>
</tr>
<tr>
<td>access_mms    Microsoft 媒体服务器 (MMS) 输入</td>
<td></td>
</tr>
<tr>
<td>bd    蓝光光碟输入</td>
<td></td>
</tr>
<tr>
<td>core    主程序</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Video</tag>
        <tag>VLC</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode:存储空间清理</title>
    <url>/p/a7582be5.html</url>
    <content><![CDATA[<blockquote>
<p>当前存储空间已不足，请清理您的电脑文件 – macOS</p>
</blockquote>
<h2 id="移除-Xcode-运行安装-APP-产生的缓存文件-DerivedData"><a href="#移除-Xcode-运行安装-APP-产生的缓存文件-DerivedData" class="headerlink" title="移除 Xcode 运行安装 APP 产生的缓存文件(DerivedData)"></a>移除 Xcode 运行安装 APP 产生的缓存文件(DerivedData)</h2><p>只要重新运行Xcode就一定会重新生成，而且会随着运行程序的增多，占用空间会越来越大。删除后在重新运行程序可能会稍微慢一点，建议定期清理。</p>
<p>路径：</p>
<p><code>~/Library/Developer/Xcode/DerivedData</code></p>
<h2 id="移除-APP-打包的ipa历史版本-Archives"><a href="#移除-APP-打包的ipa历史版本-Archives" class="headerlink" title="移除 APP 打包的ipa历史版本(Archives)"></a>移除 APP 打包的ipa历史版本(Archives)</h2><p>删除后不可恢复，文件夹是按照日期排列的，所以如果你不想全部删除，就只保留最新的几个版本就好了，个人建议全部删除。<br>路径：</p>
<p><code>~/Library/Developer/Xcode/Archives</code></p>
<h2 id="移除-APP-打包的app-icon历史版本-Archives"><a href="#移除-APP-打包的app-icon历史版本-Archives" class="headerlink" title="移除 APP 打包的app icon历史版本(Archives)"></a>移除 APP 打包的app icon历史版本(Archives)</h2><p>删除后不可恢复，文件夹是Bundle Idenifier排列的，然后再按照archive的版本号排列的，如果你看每个版本内的内容，其实就是你的app icon，个人建议全部删除。</p>
<p>路径：</p>
<p><code>~/Library/Developer/Xcode/Products/</code></p>
<h2 id="移除模拟器的缓存数据-Devices"><a href="#移除模拟器的缓存数据-Devices" class="headerlink" title="移除模拟器的缓存数据(Devices)"></a>移除模拟器的缓存数据(Devices)</h2><p>模拟器的相关数据。每个版本的模拟器占用的内存空间大约为10M左右。每个文件夹里包含的就是一个特定系统版本的设备的数据。每个文件夹对应哪个设备可以在其下device.plist中查看。删除之后，如果立即运行程序会报错，先关闭Xcode，再重新打开程序，运行即可。运行该路径下会立马生成模拟器对应版本的文件。</p>
<p>路径：</p>
<p><code>~/Library/Developer/CoreSimulator/Devices/</code></p>
<h2 id="移除对旧设备的支持-iOS-DeviceSupport"><a href="#移除对旧设备的支持-iOS-DeviceSupport" class="headerlink" title="移除对旧设备的支持(iOS DeviceSupport)"></a>移除对旧设备的支持(iOS DeviceSupport)</h2><p>一般是占用内存空间最大的文件夹，即使全部删，再连接设备调试时，会重新自动生成。一般iOS只向下兼容两个版本就可以了，所以我移除了9.0以下的所有版本。</p>
<p>路径：</p>
<p><code>~/Library/Developer/Xcode/iOS DeviceSupport</code></p>
<h2 id="移除-Xcode-中的无效的插件-Plug-ins"><a href="#移除-Xcode-中的无效的插件-Plug-ins" class="headerlink" title="移除 Xcode 中的无效的插件(Plug-ins)"></a>移除 Xcode 中的无效的插件(Plug-ins)</h2><p>因为之前你可能安装了一些 Xcode 的插件，比如HighlightSelectedString、VVDocumenter-Xcode等非常方便好用的第三方插件，在Xcode升级到version 8.0以后，就失效了，Xcode在内部已经集成了类似的方法，所以之前安装的也都没有用了，但是还在原来的位置占用着内存空间，建议删除。</p>
<p>路径：</p>
<p><code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code></p>
<p>如果你曾经没有安装过插件，那么可能不存在此路径。</p>
<h2 id="移除旧版本的模拟器支持"><a href="#移除旧版本的模拟器支持" class="headerlink" title="移除旧版本的模拟器支持"></a>移除旧版本的模拟器支持</h2><p>如果你不小心安装了很多个版本的模拟器，那么你可以删除一些旧版本的。但是当你需要旧版本的模拟器时，就需要重新下载了。建议留下1~2个版本就好了，其余的都删了吧。</p>
<p>路径：</p>
<p><code>~/Library/Developer/CoreSimulator/Profiles/Runtimes/</code></p>
<h2 id="移除-playground-的项目缓存-XCPGDevices"><a href="#移除-playground-的项目缓存-XCPGDevices" class="headerlink" title="移除 playground 的项目缓存(XCPGDevices)"></a>移除 playground 的项目缓存(XCPGDevices)</h2><p>删除后可重新生成，可以全部删除。再次运行程序会缓存。</p>
<p>路径：</p>
<p><code>~/Library/Developer/XCPGDevices/</code></p>
<h2 id="移除旧的文档-Docsets"><a href="#移除旧的文档-Docsets" class="headerlink" title="移除旧的文档(Docsets)"></a>移除旧的文档(Docsets)</h2><p>删除后不可恢复，该目录下存储的为开发文档，一般有三个文件<br>com.apple.adc.documentation.iOS.docset(1.68GB)、com.apple.adc.documentation.OSX.docset(2.62GB)和com.apple.adc.documentation.Xcode.docset(256.4M)，如果你只做iOS开发，其实你可以把OSX.docset删除掉的，因为它占用了2.62GB的内存。</p>
<p>路径：</p>
<p><code>~/Library/Developer/Shared/Documentation/DocSets</code></p>
<h2 id="移除模拟器中的SDK版本-iPhoneSimulator-sdk"><a href="#移除模拟器中的SDK版本-iPhoneSimulator-sdk" class="headerlink" title="移除模拟器中的SDK版本(iPhoneSimulator.sdk)"></a>移除模拟器中的SDK版本(iPhoneSimulator.sdk)</h2><p>不可恢复，操作请慎重。我个人的此路径下的只有最新版本的sdk，除非当你有多个版本的sdk再酌情删除。</p>
<p>路径:</p>
<p><code>~/application/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/</code></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-Checklist</title>
    <url>/p/a78b76d2.html</url>
    <content><![CDATA[<hr>
<p>title: ‘iOS:Checklist’<br>date: 2018-11-21 16:44:38<br>tags: iOS<br>categories: IT</p>
<hr>
<p>App在开发测试阶段可能有多种修改设置，但在上线前需要对某些设置进行隐藏、消除，否则上线版本可能出现意想不到的错误，本质上讲这个问题可以通过测试处理，作为开发者也得注意下测试工作，为了方便检查，记录下上线前的checklist</p>
<h2 id="Debug-Release"><a href="#Debug-Release" class="headerlink" title="Debug/Release"></a>Debug/Release</h2><p>Xcode本身区分Debug/Release环境，在Debug环境下，对象释放、内存管理为了调试需要做了很多额外工作，发布一般使用Release，但开发者可能配置多个多个开发环境，在打包上架时要检查下包的环境</p>
<h2 id="Version-Build"><a href="#Version-Build" class="headerlink" title="Version/Build"></a>Version/Build</h2><p>app的版本号与编译需要，版本号的规则一般是x.x.x，分别对应大版本.小版本.小更新，上线appStore的更新包build编号不能重复，并且需要大于上一个上传的build</p>
<h2 id="AppStore审核"><a href="#AppStore审核" class="headerlink" title="AppStore审核"></a>AppStore审核</h2><p>iOS应用的审核应该是所有应用市场最严格的吧，上线检查是否触犯苹果审查规则，否则被打回来也是浪费时间，注意一些常见的规则</p>
<ul>
<li>奔溃和错误</li>
<li>商品支付</li>
<li>客户端适配</li>
<li>ipv6适配</li>
<li>提供测试账号</li>
<li>出现demo、test等测试信息</li>
<li>绑定对应硬件才能发挥功能，如智能家居相关app</li>
<li>内购</li>
<li>Plist文件中请求了某权限</li>
<li>申请后台存活权限但没有说明</li>
<li>出现或要求安装其它第三方应用，比如分享</li>
<li>App Store 审核指南</li>
<li>UIWebView</li>
</ul>
<h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><p>支付场景在国内比较复杂，有支付宝、微信、银联、N大银行，国外有Paypal、AppPay、N大国际银行<br>注意没有安装对应应用就不要显示入口了</p>
<p>内购是苹果商店的大蛋糕，苹果对待内购非常严格，部分平台可能有某些方式绕过内购，一旦发现会被处罚，审核周期变长，严重者会被下架、封号</p>
<h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>注意没有安装对应应用就不要显示入口了</p>
<h2 id="iOS版本支持-2018"><a href="#iOS版本支持-2018" class="headerlink" title="iOS版本支持 2018"></a>iOS版本支持 2018</h2><p>iOS8～12，可以分成三个梯队，8/9～10/11～12</p>
<p>iOS8在WebView、文本渲染、换行、动态计算列表高度上有坑</p>
]]></content>
  </entry>
  <entry>
    <title>iOS:OC中的多态</title>
    <url>/p/cdf7ce60.html</url>
    <content><![CDATA[<h2 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h2><p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。由于每个类都属于该类的名字空间，这使得多态称为可能。类定义中的名字和类定义外的名字并不会冲突。</p>
<a id="more"></a>
<h2 id="类的实例变量和类方法有如下特点："><a href="#类的实例变量和类方法有如下特点：" class="headerlink" title="类的实例变量和类方法有如下特点："></a>类的实例变量和类方法有如下特点：</h2><p>和 C 语言中结构体中的数据成员一样，类的实例变量也位于该类独有的名字空间。</p>
<p>与 C 语言中的方法名不同，类的方法名并不是一个全局符号。一个类中的方法名不会和其他类中同样的方法名冲突。两个完全不同的类可以实现同一个方法。</p>
<p>方法名是对象接口的一部分。对象收到的消息的名字就是调用的方法的名字。因为不同的对象可以有同名的方法，所以对象必须能理解消息的含义。同样的消息发给不同的对象，导致的操作并不相同。</p>
<p>多态的主要好处就是简化了编程接口。它容许在类和类之间重用一些习惯性的命名，而不用为每一个新加的函数命名一个新名字。这样，编程接口就是一些抽象的行为的集合，从而和实现接口的类区分开来。</p>
<p>Objective-C 支持方法名的多态，但不支持参数和操作符的多态。</p>
<h2 id="OC中如何实现多态"><a href="#OC中如何实现多态" class="headerlink" title="OC中如何实现多态"></a>OC中如何实现多态</h2><p>在 Objective-C 中是通过一个叫做 selector 的选取器实现的。在 Objective-C 中，selector 有两个意思：当用在给对象的源码消息时，用来指方法的名字。它也指那个在源码编译后代替方法名的唯一的标识符。</p>
<p>编译后的选择器的类型是 SEL，有同样名字的方法、也有同样的选择器。你可以使用选择器来调用一个对象的方法。</p>
<h2 id="选取器有以下特点："><a href="#选取器有以下特点：" class="headerlink" title="选取器有以下特点："></a>选取器有以下特点：</h2><p>所有同名的方法拥有同样的选取器</p>
<p>所有的选取器都是不一样的</p>
<h2 id="SEL和-selector"><a href="#SEL和-selector" class="headerlink" title="SEL和@selector"></a>SEL和@selector</h2><p>选择器的类型是 SEL。@selector 指示符用来引用选择器，返回类型是SEL。</p>
<p>例如：</p>
<p><code>SEL responseSEL; 
responseSEL = @selector(loadDataForTableView:);</code></p>
<p>可以通过字符串来得到选取器，例如：</p>
<p>1<br>responseSEL = NSSelectorFromString(@”loadDataForTableView:”);<br>也可以通过反向转换，得到方法名，例如：</p>
<p><code>NSString *methodName = NSStringFromSelector(responseSEL);</code></p>
<h2 id="方法和选取器"><a href="#方法和选取器" class="headerlink" title="方法和选取器"></a>方法和选取器</h2><p>选取器确定的是方法名，而不是方法实现。这是多态性和动态绑定的基础，它使得向不同类对象发送相同的消息成为现实；否则，发送消息和标准C中调用方法就没有区别，也就不可能支持多态性和动态绑定。</p>
<p>另外，同一个类的同名类方法和实例方法拥有相同的选取器。</p>
<h2 id="方法返回值和参数类型"><a href="#方法返回值和参数类型" class="headerlink" title="方法返回值和参数类型"></a>方法返回值和参数类型</h2><p>消息机制通过选取器找到方法的返回值类型和参数类型，因此，动态绑定（例：向 id 定义的对象发送消息）需要同名方法的实现拥有相同返回值类型和相同的参数类型；否则，运行时可能出现找不到对应方法的错误。</p>
<p>有一个例外，虽然同名类方法和实例方法拥有相同的选取器，但是它们可以有不同的参数类型和返回值类型。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift：标记符 MARK、TODO、FIXME、warning、error等</title>
    <url>/p/bf6a8dd4.html</url>
    <content><![CDATA[<p>MARK、TODO、FIXME，这些标准符号可以在 Objective-C 或者 Swift 环境下使用。效果等同 #pragma mark - 的作用</p>
<a id="more"></a>

<h2 id="MARK、TODO、FIXME用法"><a href="#MARK、TODO、FIXME用法" class="headerlink" title="MARK、TODO、FIXME用法"></a>MARK、TODO、FIXME用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;TODO: 标记将来要完成的内容</span><br><span class="line">&#x2F;&#x2F;MARK: 标记一件事情</span><br><span class="line">&#x2F;&#x2F;FIXME: 标记以后要修正或完善的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/imags/blog_swift_tag01.png" alt=""></p>
<p>但如何实现OC环境下的#warning效果呢？</p>
<h2 id="warning"><a href="#warning" class="headerlink" title="#warning()"></a>#warning()</h2><p>在Swift4.2后，Xcode另外支持了新的⚠️标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#warning(&quot;Warning description&quot;)</span><br><span class="line">#error(&quot;Throws a build error&quot;)</span><br></pre></td></tr></table></figure>

<p>可以实现这种效果</p>
<p><img src="/imags/blog_swift_tag02.jpg" alt=""></p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>在target–&gt;build phases–&gt;editor–&gt;add run script build phases中，我们可以添加run script，将文件中的MARK、TODO、FIXME标签内容注入到warning，这种方案就没有版本的限制。</p>
<p>参考代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TAGS&#x3D;&quot;TODO:|FIXME:|WARNING:&quot;</span><br><span class="line">ERRORTAG&#x3D;&quot;ERROR:&quot;</span><br><span class="line">find &quot;$&#123;SRCROOT&#125;&quot; \( -name &quot;*.h&quot; -or -name &quot;*.m&quot; -or -name &quot;*.swift&quot; \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching &quot;($TAGS).*\$|($ERRORTAG).*\$&quot; | perl -p -e &quot;s&#x2F;($TAGS)&#x2F; warning: \$1&#x2F;&quot;| perl -p -e &quot;s&#x2F;($ERRORTAG)&#x2F; error: \$1&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/24183812/swift-warning-equivalent" target="_blank" rel="noopener">StackOverflow:Swift: #warning equivalent</a></p>
<p><a href="https://bendodson.com/weblog/2014/10/02/showing-todo-as-warning-in-swift-xcode-project/" target="_blank" rel="noopener">Showing TODO as a warning in a Swift Xcode project</a></p>
<p><a href="http://jeffreysambells.com/2013/01/31/generate-xcode-warnings-from-todo-comments" target="_blank" rel="noopener">Generate Xcode Warnings from TODO Comments</a></p>
<p><a href="https://juejin.im/post/6844903666722275335" target="_blank" rel="noopener">忘不了的 TODOS &amp; FIXMES &amp; ERRORS</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS:UITableView滚动优化</title>
    <url>/p/68b3f2eb.html</url>
    <content><![CDATA[<h1 id="导致卡顿的操作"><a href="#导致卡顿的操作" class="headerlink" title="导致卡顿的操作"></a>导致卡顿的操作</h1><h2 id="CPU-消耗型任务"><a href="#CPU-消耗型任务" class="headerlink" title="CPU 消耗型任务"></a>CPU 消耗型任务</h2><h3 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h3><p>布局计算是 iOS 中最为常见的消耗 CPU 资源的地方，如果视图层级关系比较复杂，计算出所有图层的布局信息就会消耗一部分时间。因此我们应该尽量提前计算好布局信息，然后在合适的时机调整对应的属性。还要避免不必要的更新，只在真正发生了布局改变时再更新。<br>对象创建</p>
<p>对象创建过程伴随着内存分配、属性设置、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，如果视图元素不需要响应触摸事件，用 CALayer 会更加合适。</p>
<p>通过 Storyboard 创建视图对象还会涉及到文件反序列化操作，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>
<p>对于列表类型的页面，还可以参考 UITableView 的复用机制。每次要初始化 View 对象时先根据 identifier 从缓存池里取，能取到就复用这个 View 对象，取不到再真正执行初始化过程。滑动屏幕时，会将滑出屏幕外的 View 对象根据 identifier 放入缓存池，新进入屏幕可见范围内的 View 又根据前面的规则来决定是否要真正初始化。</p>
<h3 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h3><p>Autolayout 是苹果在 iOS6 之后新引入的布局技术，在大多数情况下这一技术都能大大提升开发速度，特别是在需要处理多语言时。比如阿拉伯语下布局是从右往左，通过 Autolayout 设置 leading 和 trailing 即可。<br>但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题，对于性能敏感的页面建议还是使用手动布局的方式，并控制好刷新频率，做到真正需要调整布局时再重新布局。</p>
<h3 id="文本计算"><a href="#文本计算" class="headerlink" title="文本计算"></a>文本计算</h3><p>如果一个界面中包含大量文本（比如微博、微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。<br>一个比较常见的场景是在 UITableView 中，heightForRowAtIndexPath这个方法会被频繁调用，即使不是耗时的计算在调用次数多了之后也会带来性能损耗。这里的优化就是尽量避免每次都重新进行文本的行高计算，可以在获取到 Model 数据后就根据文本内容计算好布局信息，然后将这份布局信息作为一个属性保存到对应的 Model 中，这样在 UITableView 的回调中就可以直接使用 Model 中的属性，减少了文本的计算。</p>
<h3 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h3><p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。<br>这一部分的性能优化就需要我们放弃使用系统提供的上层控件转而直接使用 CoreText 进行排版控制。<br>Wherever possible, try to avoid making changes to the frame of a view that contains text, because it will cause the text to be redrawn. For example, if you need to display a static block of text in the corner of a layer that frequently changes size, put the text in a sublayer instead.<br>上面这段话引用自 iOS Core Animation: Advanced Techniques，翻译过来的意思就是说包含文本的视图在改变布局时会触发文本的重新渲染，对于静态文本我们应该尽量减少它所在视图的布局修改。</p>
<h3 id="图像的绘制"><a href="#图像的绘制" class="headerlink" title="图像的绘制"></a>图像的绘制</h3><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示的过程。调用 CG 开头的方法消耗的是 CPU 资源。我们可以将绘制过程放到后台线程，然后在主线程里将结果设置到 layer 的 contents 中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)display &#123;</span><br><span class="line">dispatch_async(backgroundQueue, ^&#123;</span><br><span class="line">CGContextRef ctx &#x3D; CGBitmapContextCreate(...);</span><br><span class="line">&#x2F;&#x2F; draw in context...</span><br><span class="line">CGImageRef img &#x3D; CGBitmapContextCreateImage(ctx);</span><br><span class="line">CFRelease(ctx);</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    layer.contents &#x3D; img;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Once an image file has been loaded, it must then be decompressed. This decompression can be a computationally complex task and take considerable time. The decompressed image will also use substantially more memory than the original.</span><br></pre></td></tr></table></figure>

<p>图片被加载后需要解码，图片的解码是一个复杂耗时的过程，并且需要占用比原始图片还多的内存资源。</p>
<p>为了节省内存，iOS 系统会延迟解码过程， 在图片被设置到 layer 的 contents 属性或者设置成 UIImageView 的 image 属性后才会执行解码过程，但是这两个操作都是在主线程进行，还是会带来性能问题。</p>
<p>如果想要提前解码，可以使用 ImageIO 或者提前将图片绘制到 CGContext 中，这部分实践可以参考 <code>iOS Core Animation: Advanced Techniques</code></p>
<p>这里多提一点，常用的 UIImage 加载方法有 <code>imageNamed</code> 和 <code>imageWithContentsOfFile</code>。其中 imageNamed 加载图片后会马上解码，并且系统会将解码后的图片缓存起来，但是这个缓存策略是不公开的，我们无法知道图片什么时候会被释放。因此在一些性能敏感的页面，我们还可以用 static 变量 hold 住 imageNamed 加载到的图片避免被释放掉，以空间换时间的方式来提高性能。</p>
<h3 id="GPU消耗型任务"><a href="#GPU消耗型任务" class="headerlink" title="GPU消耗型任务"></a>GPU消耗型任务</h3><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。宽泛的说，大多数 CALayer 的属性都是用 GPU 来绘制。<br>以下一些操作会降低 GPU 绘制的性能，</p>
<h3 id="大量几何结构"><a href="#大量几何结构" class="headerlink" title="大量几何结构"></a>大量几何结构</h3><p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>另外当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。<br>视图的混合</p>
<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并且减少不必要的透明视图。</p>
<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>离屏渲染是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作。</p>
<p>离屏渲染需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕，而上下文环境的切换是一项高开销的动作。</p>
<p>会造成 offscreen rendering 的原因有：</p>
<ul>
<li>阴影（UIView.layer.shadowOffset/shadowRadius/…）</li>
<li>圆角（当 UIView.layer.cornerRadius 和 UIView.layer.maskToBounds 一起使用时）</li>
<li>图层蒙板</li>
<li>开启光栅化（shouldRasterize = true）</li>
</ul>
<p>使用阴影时同时设置 shadowPath 就能避免离屏渲染大大提升性能。</p>
<p>CALayer 有一个 shouldRasterize 属性，将这个属性设置成 true 后就开启了光栅化。开启光栅化后会将图层绘制到一个屏幕外的图像，然后这个图像将会被缓存起来并绘制到实际图层的 contents 和子图层，对于有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧来更加高效。但是光栅化原始图像需要时间，而且会消耗额外的内存。</p>
<p>光栅化也会带来一定的性能损耗，是否要开启就要根据实际的使用场景了，图层内容频繁变化时不建议使用。最好还是用 Instruments 比对开启前后的 FPS 来看是否起到了优化效果。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS UITextField 中文输入监听</title>
    <url>/p/9aa2c853.html</url>
    <content><![CDATA[<p>在UITextField开发中，如果对输入长度有限制的话，可以通过leng<br>属性来判断，但如果要区分中英文呢？不如最大长度20个字，英文一个字，中文算两个字，那么该怎么实现呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;中文输入监听</span><br><span class="line">- (void)textFieldDidChange:(UITextField *)textField &#123;</span><br><span class="line">    int kMaxLength &#x3D; 6;</span><br><span class="line">    NSString *toBeString &#x3D; textField.text;</span><br><span class="line">    NSString *lang &#x3D; [[textField textInputMode] primaryLanguage]; &#x2F;&#x2F; 键盘输入模式</span><br><span class="line">    if ([lang isEqualToString:@&quot;zh-Hans&quot;]) &#123; &#x2F;&#x2F; 简体中文输入，包括简体拼音，健体五笔，简体手写</span><br><span class="line">        UITextRange *selectedRange &#x3D; [textField markedTextRange];</span><br><span class="line">        &#x2F;&#x2F;获取高亮部分</span><br><span class="line">        UITextPosition *position &#x3D; [textField positionFromPosition:selectedRange.start offset:0];</span><br><span class="line">        &#x2F;&#x2F; 没有高亮选择的字，则对已输入的文字进行字数统计和限制</span><br><span class="line">        if (!position) &#123;</span><br><span class="line">            if (toBeString.length &gt; kMaxLength) &#123;</span><br><span class="line">                textField.text &#x3D; [toBeString substringToIndex:kMaxLength];</span><br><span class="line">                [HZProgressHUD showHUDTitle:Localized(@&quot;标签最多6个字&quot;)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况</span><br><span class="line">    else&#123;</span><br><span class="line">        if (toBeString.length &gt; kMaxLength) &#123;</span><br><span class="line">            textField.text &#x3D; [toBeString substringToIndex:kMaxLength];</span><br><span class="line">            [HZProgressHUD showHUDTitle:Localized(@&quot;标签最多6个字&quot;)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS:TCP-UDP-基于CocoaAsyncSocket的运用</title>
    <url>/p/23982a59.html</url>
    <content><![CDATA[<p>在iOS开发中使用socket，一般都是用第三方库GCDAsyncSocket（虽然也有原生CFSocket）。</p>
<p>GCDAsyncSocket 下载地址: GCDAsyncSocket</p>
<p>使用之前需要先在项目引入ASyncSocket库：</p>
<p>把ASyncSocket库源码加入项目：只需要增加RunLoop目录中的AsyncSocket.h、AsyncSocket.m、AsyncUdpSocket.h和AsyncUdpSocket.m四个文件。<br>在项目增加CFNetwork框架：<br>在Framework目录右健,选择Add–&gt;Existing Files…<br>选择 CFNetwork.framework<br>下面开始介绍一下如何使用ASyncSocket：</p>
<p>一般来说，一个用户只需要建立一个socket长连接，所以可以用单例类方便使用。</p>
<p>单例方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建单例</span><br><span class="line">+ (Singleton *) sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static Singleton *sharedInstace &#x3D; nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstace &#x3D; [[self alloc] initPrivate];</span><br><span class="line">    &#125;);</span><br><span class="line">    return sharedInstace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 私有创建方法，不公开</span><br><span class="line">- (instancetype)initPrivate &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        _lockStr &#x3D; @&quot;1234&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 废除init创建方法</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;初始化异常&quot; reason:@&quot;不允许通过init方法创建对象&quot; userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>建立socket长连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define TIME_OUT 20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 建立socket连接</span><br><span class="line">-(void)socketConnectHost&#123;</span><br><span class="line">    _socket &#x3D; [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];</span><br><span class="line">    NSLog(@&quot;连接服务器&quot;);</span><br><span class="line">    NSError *error &#x3D; nil;</span><br><span class="line">    [_socket connectToHost:_socketHost onPort:_socketPort withTimeout:TIME_OUT error:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; socket成功连接回调</span><br><span class="line">-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port &#123;</span><br><span class="line">    NSLog(@&quot;成功连接到%@:%d&quot;,host,port);</span><br><span class="line">    _bufferData &#x3D; [[NSMutableData alloc] init]; &#x2F;&#x2F; 存储接收数据的缓存区</span><br><span class="line">    [_socket readDataWithTimeout:-1 tag:99];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>心跳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, retain) NSTimer *heartTimer;   &#x2F;&#x2F; 心跳计时器</span><br><span class="line">在连接成功的回调方法里，启动定时器，每隔2秒向服务器发送固定的消息来检测长连接。</span><br><span class="line">&#x2F;&#x2F; 心跳连接</span><br><span class="line">-(void)longConnectToSocket&#123;</span><br><span class="line">    根据服务器要求发送固定格式的数据，假设为指令@&quot;longConnect&quot;，但是一般不会是这么简单的指令</span><br><span class="line">    NSString *longConnect &#x3D; @&quot;longConnect&quot;;</span><br><span class="line">    NSData   *dataStream  &#x3D; [longConnect dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    [_socket writeData:dataStream withTimeout:1 tag:1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断开连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 主动断开</span><br><span class="line">- (void)cutOffSocket &#123;</span><br><span class="line">    [_socket disconnect];</span><br><span class="line">    _socket.userData &#x3D;  @(SocketOfflineByUser);</span><br><span class="line">    NSLog(@&quot;断开连接&quot;);</span><br><span class="line">&#125;</span><br><span class="line">* 被动断开</span><br><span class="line">-(void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err &#123;</span><br><span class="line">    if (err.code &#x3D;&#x3D; 57) &#123;</span><br><span class="line">        _socket.userData &#x3D; @(SocketOfflineByWifiCut); &#x2F;&#x2F; wifi断开</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        _socket.userData &#x3D;  @(SocketOfflineByServer);  &#x2F;&#x2F; 服务器掉线</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;断开连接，错误：%@&quot;,err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发消息</span><br><span class="line">- (void)sendMessage:(NSData *)data &#123;</span><br><span class="line">    [_socket writeData:data withTimeout:TIME_OUT tag:10];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; wirte成功</span><br><span class="line">-(void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 持续接收数据</span><br><span class="line">    &#x2F;&#x2F; 超时设置为附属，表示不会使用超时</span><br><span class="line">    [_socket readDataWithTimeout:-1 tag:tag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123;</span><br><span class="line">    &#x2F;&#x2F; 在这里处理消息</span><br><span class="line">    [self disposeBufferData:data];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;持续接收服务端的数据</span><br><span class="line">    [sock readDataWithTimeout:-1 tag:tag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS UITextView 内容上下居中</title>
    <url>/p/68829288.html</url>
    <content><![CDATA[<p>在UITextView中，如果想要实现左右居中，可以通过设置textAligment属性来设置，但如果要实现上下居中呢？</p>
<a id="more"></a>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    self &#x3D; [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self config];</span><br><span class="line">        [self setText:@&quot;\n&quot;];</span><br><span class="line">        [self setText:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加contentSize监听"><a href="#添加contentSize监听" class="headerlink" title="添加contentSize监听"></a>添加contentSize监听</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)config &#123;</span><br><span class="line">    self.delegate &#x3D; self;</span><br><span class="line">    self.font &#x3D; [UIFont systemFontOfSize:32];</span><br><span class="line">    [self hasUpdateContentInset];</span><br><span class="line">    [self addObserver:self forKeyPath:kContentSize options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:NULL];</span><br><span class="line">    [self updateContentInset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="keyvalue-observe"><a href="#keyvalue-observe" class="headerlink" title="keyvalue observe"></a>keyvalue observe</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;change :%@&quot;,change);</span><br><span class="line">    if ([keyPath isEqualToString:kContentSize])</span><br><span class="line">    &#123;</span><br><span class="line">        [self updateContentInset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置垂直方向contentInset"><a href="#设置垂直方向contentInset" class="headerlink" title="设置垂直方向contentInset"></a>设置垂直方向contentInset</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)updateContentInset &#123;</span><br><span class="line">    NSLog(@&quot;contentSize %@&quot;,NSStringFromCGSize(self.contentSize));</span><br><span class="line">    CGFloat deadSpace &#x3D; (CGRectGetHeight(self.bounds) - self.contentSize.height);</span><br><span class="line">    CGFloat inset &#x3D; MAX(0, deadSpace&#x2F;2.0);</span><br><span class="line">    self.contentInset &#x3D; UIEdgeInsetsMake(inset, self.contentInset.left, inset, self.contentInset.right);</span><br><span class="line">    self.contentOffset &#x3D; CGPointMake(0, -inset);</span><br><span class="line">    [self layoutSubviews];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS WKWebView适配iOS8支持网页宽度自适应</title>
    <url>/p/c6cc69a1.html</url>
    <content><![CDATA[<p>iOS在iOS8推出基于WebKit的WKWebView显示网页、富文本内容，相比UIWebView在速度、内容消耗上有了很大的提升，但WKWebView也埋下了不少坑，最近碰到一个iOS8独享bug，iOS8上，网页宽度自适应失效，内容强制显示屏幕宽度，而不是WKWebView的宽度，主要是标签的支持问题，在此记录下解决方案，希望iOS8不再是开发者的痛；（ps：iOS12都快出了，iOS8还想走多远 ==）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *jScript &#x3D; @&quot;var meta &#x3D; document.createElement(&#39;meta&#39;); meta.setAttribute(&#39;name&#39;, &#39;viewport&#39;); meta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width&#39;); document.getElementsByTagName(&#39;head&#39;)[0].appendChild(meta);&quot;;</span><br><span class="line">            </span><br><span class="line">WKUserScript *wkUScript &#x3D; [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</span><br><span class="line">WKUserContentController *wkUController &#x3D; [[WKUserContentController alloc] init];</span><br><span class="line">wkUController addUserScript:wkUScript];</span><br><span class="line">Configuration.userContentController &#x3D; wkUController;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Xcode上传AppStore报错 ERROR ITMS-90158</title>
    <url>/p/36d43aa4.html</url>
    <content><![CDATA[<p>ERROR ITMS-90158: “The following URL schemes found in your app are not in the current format.”</p>
<p>Info-URL Scheme中，设置对应的URL Scheme 不能以数字开头！</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS iOS11刷新时 tableview reloadData抖动</title>
    <url>/p/e0dc33b4.html</url>
    <content><![CDATA[<h1 id="iOS-iOS11刷新时-tableview-reloadData抖动"><a href="#iOS-iOS11刷新时-tableview-reloadData抖动" class="headerlink" title="iOS iOS11刷新时 tableview reloadData抖动"></a>iOS iOS11刷新时 tableview reloadData抖动</h1><p>在iOS11中，在TableView中，如果Cell的高度相差很大，同时你有是使用UITableViewAutomaticDimension实现自动动态高度，那么在你reloadData时，可能看到tableView异常抖动，主要是contentOffset的不正常变化，这一异常主要是因为刷新时，过当estimatedRowHeight,sectionHeaderHeight,sectionFooterHeight不为0时，contentSize的高度时通以上数据计算出来的，在iOS11上面几个参数默认不为0，所以会引起reloadData时contentSize的变化，解决方案如下：</p>
<a id="more"></a>
<p>1.使高度估算失效：单独关闭摸一个UITableView的Self-Sizing。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_tableView.estimatedRowHeight &#x3D; 0.;</span><br><span class="line">_tableView.estimatedSectionFooterHeight &#x3D; 0.;</span><br><span class="line">_tableView.estimatedSectionHeaderHeight &#x3D; 0.;</span><br></pre></td></tr></table></figure>

<p>2.关闭所有的UIScroolView、UITableView和UICollectionView的Self-Sizing：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIScrollView.appearance.contentInsetAdjustmentBehavior &#x3D; UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">UITableView.appearance.estimatedRowHeight &#x3D; 0;</span><br><span class="line">UITableView.appearance.estimatedSectionFooterHeight &#x3D; 0;</span><br><span class="line">UITableView.appearance.estimatedSectionHeaderHeight &#x3D; 0;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS:字符串%出现警告incomplete format specifier</title>
    <url>/p/96061a30.html</url>
    <content><![CDATA[<p><code>[NSString stringWithFormat:@&quot;已下载%.0lf\%&quot;,downProgress];</code></p>
<p>出现警告Incomplete format specifier</p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id=""><a href="#" class="headerlink" title="%%"></a>%%</h3><p><code>[NSString stringWithFormat:@&quot;已下载%.0lf%%&quot;,downProgress];</code></p>
<h3 id="uFF05"><a href="#uFF05" class="headerlink" title="\uFF05"></a>\uFF05</h3><p><code>[NSString stringWithFormat:@&quot;已下载%.0lf\uFF05&quot;,downProgress];</code></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>直接使用ASCII很好理解，但使用%%又是什么原理呢？</p>
<p>后续。。。。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS--审核 2.3.1+3.1.1 元数据审核被拒</title>
    <url>/p/ab68ed45.html</url>
    <content><![CDATA[<p>上线审核被拒，理由是2.3.1和3.1.1，记录下排查过程</p>
<a id="more"></a>

<pre>
Guideline 2.3.1 - Performance

We discovered that your app contains hidden features. 

The next submission of this app may require a longer review time, and this app will not be eligible for an expedited review until this issue is resolved.

Guideline 3.1.1 - Business - Payments - In-App Purchase

We noticed that your app or its metadata enables the purchase of content, services, or functionality in the app by means other than the in-app purchase API, which is not appropriate for the App Store.
</pre>

<p>出现这种情况，是在App有内购的情况下，审核人员内购以外的支付方式</p>
<p>隐藏第三方支付相关UI入口，如微信、支付宝、银联等</p>
<p>另外一种情况是ipa包机审，扫描出第三方支付相关信息</p>
<h2 id="移除第三方支付代码"><a href="#移除第三方支付代码" class="headerlink" title="移除第三方支付代码"></a>移除第三方支付代码</h2><ul>
<li>修改info.plist，移除LSApplicationQueriesSchemes项目中第三方支付相关白名单，如alipay</li>
<li>检查是否有某些第三方引入支付相关代码；注意不只是SDK，常量、函数中包含wechatpay、alipay这样的代码也有可能被拒绝</li>
<li>检查SDK版本，如微信、QQ分享Apple允许，但SDK中包含的支付代码可能会导致审核，应该换没有支付模块的SDK,比如接入微信应该使用无支付模块的SDK</li>
<li>触发2.3.1+3.1.1礼包后Apple会赠送惩罚套餐，审核时间被延长到1个星期，排除问题等待回复就是一周以上！</li>
</ul>
<p>当我解决这些问题的时候已经花了一个多月了！</p>
<p>(╯°□°）╯︵┻━┻</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 对应window旋转事件的响应和传递</title>
    <url>/p/ae1b8e69.html</url>
    <content><![CDATA[<h2 id="iOS-8-横竖屏不响应"><a href="#iOS-8-横竖屏不响应" class="headerlink" title="iOS 8 横竖屏不响应"></a>iOS 8 横竖屏不响应</h2><p>自定义appDelegate的window与main.storyboard 对屏幕旋转事件的响应冲突</p>
<p>在开启了横竖屏支持后，状态栏跟随变化但界面没触发旋转，在查找资料后发现，iOS设备的旋转事件会被window响应，通过window的rootViewController控制状态，window 上的view会发生旋转，而项目中ViewController是作为自定义window，需要在TabbarViewController、NavigationViewController、ViewController中传递控制。</p>
<p>但是！！！</p>
<p>在项目新建时，系统会自动创建main.storyboard，它也是携带window，如果没有删除main.storyboard，window响应会冲突，在iOS8上，自定义window的旋转事件不会响应！</p>
<p>解决方案：删除main.storyboard，将自定义window设置为KeyAndVisible，clear 项目，重启Xcode</p>
<a id="more"></a>

<p>iOS的App是通过UIWindow这个载体呈现出来的。默认情况下，iOS App对于开发者来说只有一个UIWindow，也就是AppDelegate在applicationDidFinishLaunching里面创建出来的。</p>
<h2 id="横屏及旋转"><a href="#横屏及旋转" class="headerlink" title="横屏及旋转"></a>横屏及旋转</h2><p>现在绝大多数的iPhone应用都是竖屏应用，即只支持Portrait模式。但是随着视频、直播的风口到来，在新闻、购物等等APP内都会插入视频播放这一特性，而视频播放需要的全屏播放特性势必要用到横屏，也就意味着会牵扯到旋转。<br>横屏旋转分为两种，一种是强制性的，一种是随着设备进行旋转的。</p>
<p>大家还记得手机上有旋转锁这一个开关吧，你将旋转锁开启的时候，手机就保持在锁定对应的模式下，无法自动根据你旋转设备而旋转。在这种模式下，如果你需要更改APP界面对应的UIInterfaceOrientation，就必须要么在对应的viewcontroller里面提供实现如下的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    return UIInterfaceOrientationMaskLandscapeRight; &#x2F;&#x2F; 表示支持水平右方向</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)shouldAutorotate</span><br><span class="line">&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当你展现到这个页面的时候，就会触发系统检查一下当前页面应该所处的Orientation，从而达到正确的显示效果。<br>但需要注意的是，如果你的界面是处于一个UINavigationController或者UITabbarController内的话，你就需要从父容器开始，写对应的supportedInterfaceOrientations实现，否则就无法得到正确的效果。</p>
<p>下面介绍监听屏幕旋转方向、视图控制器中旋转方向的设置、屏幕旋转方向下的视图处理以及强制横屏的处理</p>
<h2 id="监听屏幕旋转方向"><a href="#监听屏幕旋转方向" class="headerlink" title="监听屏幕旋转方向"></a>监听屏幕旋转方向</h2><p>在处理iOS横竖屏时，经常会和UIDeviceOrientation、UIInterfaceOrientation和UIInterfaceOrientationMask这三个枚举类型打交道，它们从不同角度描述了屏幕旋转方向。</p>
<h3 id="1、UIDeviceOrientation：设备方向"><a href="#1、UIDeviceOrientation：设备方向" class="headerlink" title="1、UIDeviceOrientation：设备方向"></a>1、UIDeviceOrientation：设备方向</h3><p>iOS的设备方向是通过iOS的加速计来获取的。</p>
<h4 id="1）iOS定义了以下七种设备方向"><a href="#1）iOS定义了以下七种设备方向" class="headerlink" title="1）iOS定义了以下七种设备方向"></a>1）iOS定义了以下七种设备方向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123;</span><br><span class="line">UIDeviceOrientationUnknown,                 &#x2F;&#x2F; 未知方向，可能是设备(屏幕)斜置</span><br><span class="line">UIDeviceOrientationPortrait,                &#x2F;&#x2F; 设备(屏幕)直立</span><br><span class="line">UIDeviceOrientationPortraitUpsideDown,      &#x2F;&#x2F; 设备(屏幕)直立，上下顛倒</span><br><span class="line">UIDeviceOrientationLandscapeLeft,           &#x2F;&#x2F; 设备(屏幕)向左横置</span><br><span class="line">UIDeviceOrientationLandscapeRight,          &#x2F;&#x2F; 设备(屏幕)向右橫置</span><br><span class="line">UIDeviceOrientationFaceUp,                  &#x2F;&#x2F; 设备(屏幕)朝上平躺</span><br><span class="line">UIDeviceOrientationFaceDown                 &#x2F;&#x2F; 设备(屏幕)朝下平躺</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明：UIDeviceOrientation参考home键方向，如：home方向在右，设备(屏幕)方向向左（UIDeviceOrientationLandscapeLeft） </p>
<h4 id="2）读取设备方向"><a href="#2）读取设备方向" class="headerlink" title="2）读取设备方向"></a>2）读取设备方向</h4><p>UIDevice单例代表当前的设备。从这个单例中可以获得的信息设备，如设备方向orientation。<br>UIDeviceOrientation deviceOrientation = [UIDevice currentDevice].orientation;</p>
<h4 id="3）监听、处理和移除-设备方向改变的通知"><a href="#3）监听、处理和移除-设备方向改变的通知" class="headerlink" title="3）监听、处理和移除 设备方向改变的通知"></a>3）监听、处理和移除 设备方向改变的通知</h4><p>当设备方向变化时候，发出UIDeviceOrientationDidChangeNotification通知；注册监听该通知，可以针对不同的设备方向处理视图展示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;开启和监听 设备旋转的通知（不开启的话，设备方向一直是UIInterfaceOrientationUnknown）</span><br><span class="line">if (![UIDevice currentDevice].generatesDeviceOrientationNotifications) &#123;</span><br><span class="line">[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class="line">&#125;</span><br><span class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(handleDeviceOrientationChange:) </span><br><span class="line">name:UIDeviceOrientationDidChangeNotification object:nil];</span><br><span class="line">&#x2F;&#x2F;设备方向改变的处理</span><br><span class="line">- (void)handleDeviceOrientationChange:(NSNotification *)notification&#123;</span><br><span class="line">UIDeviceOrientation deviceOrientation &#x3D; [UIDevice currentDevice].orientation;</span><br><span class="line">switch (ddeviceOrientation) &#123;</span><br><span class="line">case UIDeviceOrientationFaceUp:</span><br><span class="line">NSLog(@&quot;屏幕朝上平躺&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIDeviceOrientationFaceDown:</span><br><span class="line">NSLog(@&quot;屏幕朝下平躺&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIDeviceOrientationUnknown:</span><br><span class="line">NSLog(@&quot;未知方向&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIDeviceOrientationLandscapeLeft:</span><br><span class="line">NSLog(@&quot;屏幕向左横置&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIDeviceOrientationLandscapeRight:</span><br><span class="line">NSLog(@&quot;屏幕向右橫置&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIDeviceOrientationPortrait:</span><br><span class="line">NSLog(@&quot;屏幕直立&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIDeviceOrientationPortraitUpsideDown:</span><br><span class="line">NSLog(@&quot;屏幕直立，上下顛倒&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">NSLog(@&quot;无法辨识&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后在dealloc中移除通知 和结束设备旋转的通知</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">[[NSNotificationCenter defaultCenter]removeObserver:self];</span><br><span class="line">[[UIDevice currentDevice]endGeneratingDeviceOrientationNotifications];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：手机锁定竖屏后，UIDeviceOrientationDidChangeNotification通知就失效了。</p>
<h3 id="2、UIInterfaceOrientation：界面方向"><a href="#2、UIInterfaceOrientation：界面方向" class="headerlink" title="2、UIInterfaceOrientation：界面方向"></a>2、UIInterfaceOrientation：界面方向</h3><p>界面方向是反应iOS中界面的方向，它和Home按钮的方向是一致的。</p>
<h5 id="1）iOS定义了以下五种界面方向"><a href="#1）iOS定义了以下五种界面方向" class="headerlink" title="1）iOS定义了以下五种界面方向"></a>1）iOS定义了以下五种界面方向</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123;</span><br><span class="line">UIInterfaceOrientationUnknown            &#x3D; UIDeviceOrientationUnknown,       &#x2F;&#x2F;未知方向</span><br><span class="line">UIInterfaceOrientationPortrait           &#x3D; UIDeviceOrientationPortrait,               &#x2F;&#x2F;界面直立</span><br><span class="line">UIInterfaceOrientationPortraitUpsideDown &#x3D; UIDeviceOrientationPortraitUpsideDown,  &#x2F;&#x2F;界面直立，上下颠倒</span><br><span class="line">UIInterfaceOrientationLandscapeLeft      &#x3D; UIDeviceOrientationLandscapeRight,   &#x2F;&#x2F;界面朝左</span><br><span class="line">UIInterfaceOrientationLandscapeRight     &#x3D; UIDeviceOrientationLandscapeLeft    &#x2F;&#x2F;界面朝右</span><br><span class="line">&#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>

<p>说明：从定义可知，界面方向和设别方向有对应关系，如界面的竖直方向就是 设备的竖直方向：</p>
<p>UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown</p>
<h4 id="2）读取界面方向"><a href="#2）读取界面方向" class="headerlink" title="2）读取界面方向"></a>2）读取界面方向</h4><p>UIInterfaceOrientation和状态栏有关，通过UIApplication的单例调用statusBarOrientation来获取</p>
<p><code>UIInterfaceOrientation interfaceOrientation = [[UIApplication sharedApplication] statusBarOrientation];</code></p>
<h4 id="3）监听、处理和移除-界面方向改变的通知"><a href="#3）监听、处理和移除-界面方向改变的通知" class="headerlink" title="3）监听、处理和移除 界面方向改变的通知"></a>3）监听、处理和移除 界面方向改变的通知</h4><p>当界面方向变化时候，先后发出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;以监听UIApplicationDidChangeStatusBarOrientationNotification通知为例</span><br><span class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(handleStatusBarOrientationChange:) </span><br><span class="line">name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];</span><br><span class="line">&#x2F;&#x2F;界面方向改变的处理</span><br><span class="line">- (void)handleStatusBarOrientationChange: (NSNotification *)notification&#123;</span><br><span class="line">UIInterfaceOrientation interfaceOrientation &#x3D; [[UIApplication sharedApplication] statusBarOrientation];</span><br><span class="line">switch (interfaceOrientation) &#123;</span><br><span class="line">case UIInterfaceOrientationUnknown:</span><br><span class="line">NSLog(@&quot;未知方向&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIInterfaceOrientationPortrait:</span><br><span class="line">NSLog(@&quot;界面直立&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIInterfaceOrientationPortraitUpsideDown:</span><br><span class="line">NSLog(@&quot;界面直立，上下颠倒&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIInterfaceOrientationLandscapeLeft:</span><br><span class="line">NSLog(@&quot;界面朝左&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIInterfaceOrientationLandscapeRight:</span><br><span class="line">NSLog(@&quot;界面朝右&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最后在dealloc中移除通知</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">[[NSNotificationCenter defaultCenter]removeObserver:self];</span><br><span class="line">[[UIDevice currentDevice]endGeneratingDeviceOrientationNotifications];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：手机锁定竖屏后，UIApplicationWillChangeStatusBarOrientationNotification和 UIApplicationDidChangeStatusBarOrientationNotification通知也失效了。</p>
<h3 id="3、UIInterfaceOrientationMask"><a href="#3、UIInterfaceOrientationMask" class="headerlink" title="3、UIInterfaceOrientationMask"></a>3、UIInterfaceOrientationMask</h3><p>UIInterfaceOrientationMask是为了集成多种UIInterfaceOrientation而定义的类型，和ViewController相关，一共有7种</p>
<h4 id="1）iOS中的UIInterfaceOrientationMask定义"><a href="#1）iOS中的UIInterfaceOrientationMask定义" class="headerlink" title="1）iOS中的UIInterfaceOrientationMask定义"></a>1）iOS中的UIInterfaceOrientationMask定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123;</span><br><span class="line">UIInterfaceOrientationMaskPortrait &#x3D; (1 &lt;&lt; UIInterfaceOrientationPortrait),</span><br><span class="line">UIInterfaceOrientationMaskLandscapeLeft &#x3D; (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft),</span><br><span class="line">UIInterfaceOrientationMaskLandscapeRight &#x3D; (1 &lt;&lt; UIInterfaceOrientationLandscapeRight),</span><br><span class="line">UIInterfaceOrientationMaskPortraitUpsideDown &#x3D; (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown),</span><br><span class="line">UIInterfaceOrientationMaskLandscape &#x3D; (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),</span><br><span class="line">UIInterfaceOrientationMaskAll &#x3D; (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),</span><br><span class="line">UIInterfaceOrientationMaskAllButUpsideDown &#x3D; (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),</span><br><span class="line">&#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>

<h4 id="2）UIInterfaceOrientationMask的使用"><a href="#2）UIInterfaceOrientationMask的使用" class="headerlink" title="2）UIInterfaceOrientationMask的使用"></a>2）UIInterfaceOrientationMask的使用</h4><p>在ViewController可以重写- (UIInterfaceOrientationMask)supportedInterfaceOrientations方法返回类型，来决定UIViewController可以支持哪些界面方向。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;支持界面直立</span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations&#123;</span><br><span class="line">return UIInterfaceOrientationMaskPortrait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>UIDeviceOrientation（设备方向）和UIInterfaceOrientation（屏幕方向）是两个不同的概念。前者代表了设备的一种状态，而后者是屏幕为了应对不同的设备状态，做出的用户界面上的响应。在iOS设备旋转时，由UIKit接收到旋转事件，然后通过AppDelegate通知当前程序的UIWindow对象，UIWindow对象通知它的rootViewController，如果该rootViewController支持旋转后的屏幕方向，完成旋转，否则不旋转；弹出的ViewController也是如此处理。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS_柱状音频波形图绘制</title>
    <url>/p/5d83be7c.html</url>
    <content><![CDATA[<p>AVAssetReader 和 AVAssetWriter类提供的低级功能，能处理更复杂的媒体样本。</p>
<h2 id="AVAssetReader-和-AVAssetWriter"><a href="#AVAssetReader-和-AVAssetWriter" class="headerlink" title="AVAssetReader 和 AVAssetWriter"></a>AVAssetReader 和 AVAssetWriter</h2><h3 id="AVAssetReader"><a href="#AVAssetReader" class="headerlink" title="AVAssetReader"></a>AVAssetReader</h3><p>AVAssetReader 用于从 AVAsset示例中读取媒体样本。</p>
<p>通常会配置一个或多个AVAssetReaderOutput实例，并通过 copyNextSampleBuffer 方法访问音频和视频帧。</p>
<p>一个资源读取器的内部通道都是以多线程的方式不断提取下一个可用样本的。这样可以在系统请求资源时最小化时延。</p>
<h3 id="AVAssetWriter"><a href="#AVAssetWriter" class="headerlink" title="AVAssetWriter"></a>AVAssetWriter</h3><p>AVAssetWriter 用于对媒体资源进行编码并将其写入到文件中（如MPEG-4）。</p>
<p>通常由一个或多个AVAssetWriterInput对象配置，用于附加将包含要写入容器的媒体样本的CMSampleBuffer对象。</p>
<p>AVAssetWriter可用于实时操作和离线操作两种：</p>
<p>实时。当处理实时资源时，比如从AVCaptureVideoDataOutput写入捕捉样本时，AVAssetWriterInput应该令expectsMediaDataInRealTime属性为YES类确保readyForMoreMediaData（指示保持数据样本交错的情况下是否可以附加更多信息）值被正确计算。</p>
<p>离线。当从离线资源中读取媒体资源时，比如从AVAssetReader读取样本buffer，仍然需要readyForMoreMediaData，再可以使用requestMediaDataWhenReadyOnQueue:usingBlock方法来控制数据的提供。</p>
<h3 id="创建波形图"><a href="#创建波形图" class="headerlink" title="创建波形图"></a>创建波形图</h3><p>创建波形需要</p>
<ul>
<li>读取:读取音频样本进行渲染，需要读取或者解压音频数据。</li>
<li>缩减:读取到的样本远比我们需要的多，可以将样本分成小的样本块，并在每个样本块上找到最大值最小值和平均值。</li>
<li>渲染:将缩减后的样本呈现在屏幕上。</li>
</ul>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>使用AVAssetReader实例从AVAsset中读取音频样本并返回一个NSData对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;载入资源，读取asset样本</span><br><span class="line"></span><br><span class="line">+ (void)loadAudioSamplesFromAsset:(AVAsset *)asset</span><br><span class="line">                  completionBlock:(THSampleDataCompletionBlock)completionBlock &#123;</span><br><span class="line"></span><br><span class="line">	NSString *tracks &#x3D; @&quot;tracks&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;异步载入键对应的资源</span><br><span class="line"></span><br><span class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracks] completionHandler:^&#123;  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取tracks键载入状态</span><br><span class="line"></span><br><span class="line">        AVKeyValueStatus status &#x3D; [asset statusOfValueForKey:tracks error:nil];</span><br><span class="line">		NSData *sampleData &#x3D; nil;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果载入成功，则从资源音频轨道中读取样本</span><br><span class="line">        if (status &#x3D;&#x3D; AVKeyValueStatusLoaded&#123;                             </span><br><span class="line">            sampleData &#x3D; [self readAudioSamplesFromAsset:asset];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		dispatch_async(dispatch_get_main_queue(), ^&#123;                        </span><br><span class="line">            completionBlock(sampleData);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缩减音频样本"><a href="#缩减音频样本" class="headerlink" title="缩减音频样本"></a>缩减音频样本</h4><p>处理带有音频信息的NSData对象，根据指定的大小，将样本分成一个个样本块，找到样本块中的最大样本，得到筛选结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)filteredSamplesForSize:(CGSize)size &#123;</span><br><span class="line">&#x2F;&#x2F;filteredSamples保存筛选的样本数组</span><br><span class="line">    NSMutableArray *filteredSamples &#x3D; [[NSMutableArray alloc] init];       </span><br><span class="line">    &#x2F;&#x2F;sampleCount表示样本总数</span><br><span class="line">    NSUInteger sampleCount &#x3D; self.sampleData.length &#x2F; sizeof(SInt16);</span><br><span class="line">    &#x2F;&#x2F;binSize表示每个样本块的大小</span><br><span class="line">    NSUInteger binSize &#x3D; sampleCount &#x2F; size.width;</span><br><span class="line">	SInt16 *bytes &#x3D; (SInt16 *) self.sampleData.bytes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	SInt16 maxSample &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;迭代全部音频样本集合</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; sampleCount; i +&#x3D; binSize) &#123;</span><br><span class="line">        &#x2F;&#x2F;样本块</span><br><span class="line">        SInt16 sampleBin[binSize];</span><br><span class="line">        &#x2F;&#x2F;使用CFSwapInt16LittleToHost函数确保样本是按主机内置的字节顺序处理的</span><br><span class="line">        for (NSUInteger j &#x3D; 0; j &lt; binSize; j++) &#123;</span><br><span class="line">		   sampleBin[j] &#x3D; CFSwapInt16LittleToHost(bytes[i + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找到样本块中的最大绝对值,并存入筛选结果</span><br><span class="line">        SInt16 value &#x3D; [self maxValueInArray:sampleBin ofSize:binSize];     </span><br><span class="line">        [filteredSamples addObject:@(value)];</span><br><span class="line">		if (value &gt; maxSample) &#123;</span><br><span class="line">            maxSample &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;约束筛选样本</span><br><span class="line">    CGFloat scaleFactor &#x3D; (size.height &#x2F; 2) &#x2F; maxSample; </span><br><span class="line"></span><br><span class="line">	for (NSUInteger i &#x3D; 0; i &lt; filteredSamples.count; i++) 	&#123; </span><br><span class="line">        filteredSamples[i] &#x3D; @([filteredSamples[i] integerValue] * scaleFactor);</span><br><span class="line">    &#125;</span><br><span class="line">	return filteredSamples;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找到样本块中的最大绝对值</span><br><span class="line">- (SInt16)maxValueInArray:(SInt16[])values ofSize:(NSUInteger)size &#123;</span><br><span class="line"></span><br><span class="line">    SInt16 maxValue &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (abs(values[i]) &gt; maxValue) &#123;</span><br><span class="line"></span><br><span class="line">            maxValue &#x3D; abs(values[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="渲染音频样本"><a href="#渲染音频样本" class="headerlink" title="渲染音频样本"></a>渲染音频样本</h4><p>创建UIView子类, 使用QuartzCore渲染筛选后的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">	CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;适当缩放上下文</span><br><span class="line">	 CGContextScaleCTM(context, THWidthScaling, THHeightScaling);</span><br><span class="line">    &#x2F;&#x2F;适当在x y 轴上偏移</span><br><span class="line"></span><br><span class="line">	CGFloat xOffset &#x3D; self.bounds.size.width -(self.bounds.size.width * THWidthScaling);</span><br><span class="line">	CGFloat yOffset &#x3D; self.bounds.size.height -(self.bounds.size.height * THHeightScaling);</span><br><span class="line">	</span><br><span class="line">	CGContextTranslateCTM(context, xOffset &#x2F; 2, yOffset &#x2F; 2);</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;获取筛选后的音频样本</span><br><span class="line">	NSArray *filteredSamples &#x3D; [self.filter filteredSamplesForSize:self.bounds.size];</span><br><span class="line"></span><br><span class="line">	CGFloat midY &#x3D; CGRectGetMidY(rect);</span><br><span class="line">    &#x2F;&#x2F;创建CGMutablePathRef对象 用来绘制Bezier路径的上半部</span><br><span class="line">	CGMutablePathRef halfPath &#x3D; CGPathCreateMutable();   </span><br><span class="line">	CGPathMoveToPoint(halfPath, NULL, 0.0f, midY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;迭代样本 每次向路径中添加一个点</span><br><span class="line">	 for (NSUInteger i &#x3D; 0; i &lt; filteredSamples.count; i++)&#123;</span><br><span class="line">		float sample &#x3D; [filteredSamples[i] floatValue];</span><br><span class="line">		CGPathAddLineToPoint(halfPath, NULL, i, midY - sample);</span><br><span class="line">	&#125;</span><br><span class="line">	CGPathAddLineToPoint(halfPath, NULL, filteredSamples.count, midY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;绘制完整波形</span><br><span class="line"></span><br><span class="line">	CGMutablePathRef fullPath &#x3D; CGPathCreateMutable();  </span><br><span class="line"></span><br><span class="line">	CGPathAddPath(fullPath, NULL, halfPath);</span><br><span class="line"></span><br><span class="line">	CGAffineTransform transform &#x3D; CGAffineTransformIdentity;  </span><br><span class="line">	transform &#x3D; CGAffineTransformTranslate(transform, 0, CGRectGetHeight(rect));</span><br><span class="line"></span><br><span class="line"> 	transform &#x3D; CGAffineTransformScale(transform, 1.0, -1.0);</span><br><span class="line"></span><br><span class="line"> 	CGPathAddPath(fullPath, &amp;transform, halfPath);</span><br><span class="line">	CGContextAddPath(context, fullPath);</span><br><span class="line"></span><br><span class="line">    CGContextSetFillColorWithColor(context, self.waveColor.CGColor);</span><br><span class="line">    CGContextDrawPath(context, kCGPathFill);</span><br><span class="line">	CGPathRelease(halfPath);    </span><br><span class="line">    CGPathRelease(fullPath);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-自适应高度的TableViewCell</title>
    <url>/p/55abe18d.html</url>
    <content><![CDATA[<h1 id="自定义-IOS-TextView，高度自增自减"><a href="#自定义-IOS-TextView，高度自增自减" class="headerlink" title="自定义 IOS TextView，高度自增自减"></a>自定义 IOS TextView，高度自增自减</h1><p>如何实现UITextView文本框高度随文字行数自动增减呢？</p>
<h2 id="思路1、UITextView的Delegate方法"><a href="#思路1、UITextView的Delegate方法" class="headerlink" title="思路1、UITextView的Delegate方法"></a>思路1、UITextView的Delegate方法</h2><p><code>-textViewDidChange:</code></p>
<p>在Text变化时计算文字高度，刷新TextView高度</p>
<p>问题：</p>
<p>Text变化与实际有出入，此时的问题变化还没有存储到TextView的Text中，现在进行计算会得到上一个状态下的文字高度，导致TextView高度刷新延迟，换行第二个文字才增加高度，如果采用这个方法，就要进行文字拼接，再计算文字高度。</p>
<p>实现：不够优雅，不实现。</p>
<h2 id="思路2、TextView本质是一个ScrollView"><a href="#思路2、TextView本质是一个ScrollView" class="headerlink" title="思路2、TextView本质是一个ScrollView"></a>思路2、TextView本质是一个ScrollView</h2><p>文字高度超出TextView高度会自动增加contentSize属性的height，而且增加的高度刚好就是TextView需要改变的高度，不错。</p>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;宽度、高度与坐标</span><br><span class="line"></span><br><span class="line">\#define Main_Screen_Height      [[UIScreen mainScreen] bounds].size.height   </span><br><span class="line">\#define Main_Screen_Width       [[UIScreen mainScreen] bounds].size.width</span><br><span class="line">static float TextViewDefaultHeight &#x3D; 30.;  </span><br><span class="line">static float TextViewDefaultY &#x3D; 5.;  </span><br><span class="line">static float TextViewContentSizeDefaultHeight &#x3D; 22.;  </span><br><span class="line">&#x2F;&#x2F;测试中使用[UIFont systemFontOfSize:14]，每行高度变化为17</span><br><span class="line">self.TextViewInput &#x3D; [[UITextView alloc]initWithFrame:CGRectMake(45, UUInputTextViewDefaultY, Main_Screen_Width, UUInputTextViewDefaultHeight)];  </span><br><span class="line">[self.TextViewInput setContentSize:CGSizeMake(self.TextViewInput.width, UUInputTextViewContentSizeDefaultHeight)];  </span><br><span class="line">self.TextViewInput.delegate &#x3D; self;  </span><br><span class="line">self.TextViewInput.font &#x3D; [UIFont systemFontOfSize:14];  </span><br><span class="line">self.TextViewInput.textContainerInset &#x3D; UIEdgeInsetsMake(6,0, 0, 0);  </span><br><span class="line">&#x2F;&#x2F;KVO监听TextViewInput的contentSize变化  </span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;  </span><br><span class="line">[self.TextViewInput addObserver:self forKeyPath:@&quot;contentSize&quot; options:options context:nil];  </span><br><span class="line">[self addSubview:self.TextViewInput];  </span><br><span class="line">\#pragma mark -- KVO --</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;  </span><br><span class="line">if ([keyPath isEqualToString:@&quot;contentSize&quot;])&#123;  </span><br><span class="line">&#x2F;&#x2F;最高行数设置，本demo中最高四行，对应paste场景  </span><br><span class="line">    if (self.TextViewInput.height &gt; UUInputTextViewDefaultHeight+17*2 &amp;&amp; self.TextViewInput.contentSize.height &gt; UUInputTextViewContentSizeDefaultHeight+17*2) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F;文本为空时处理，对应文字发送、cut场景  </span><br><span class="line">    if (self.TextViewInput.text.length &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">        [UIView animateWithDuration:0.3 animations:^&#123;  </span><br><span class="line">            self.TextViewInput.frame &#x3D; CGRectMake(45, UUInputTextViewDefaultY, Main_Screen_Width-2*45, UUInputTextViewDefaultHeight);  </span><br><span class="line">        &#125; completion:nil];  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    CGRect frame &#x3D; self.TextViewInput.frame;</span><br><span class="line">    &#x2F;&#x2F;高度变化值  </span><br><span class="line">    float changeHeight &#x3D; self.TextViewInput.contentSize.height - UUInputTextViewContentSizeDefaultHeight;  </span><br><span class="line">    &#x2F;&#x2F;超过限定高度的场景处理  </span><br><span class="line">    if (changeHeight &gt; 17*2) &#123;  </span><br><span class="line">        changeHeight &#x3D; 17*2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    frame.origin.y &#x3D; UUInputTextViewDefaultY - changeHeight;  </span><br><span class="line">    frame.size.height &#x3D; UUInputTextViewDefaultHeight + changeHeight;  </span><br><span class="line">    &#x2F;&#x2F;动画效果  </span><br><span class="line">    [UIView animateWithDuration:0.3 animations:^&#123;  </span><br><span class="line">        self.TextViewInput.frame &#x3D; frame;  </span><br><span class="line">    &#125; completion:nil];  </span><br><span class="line">    NSLog(@&quot;%lf--    TextViewInput&quot;,self.TextViewInput.contentSize.height);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;注意要注销KVO</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;    </span><br><span class="line">    [self.TextViewInput removeObserver:self forKeyPath:@&quot;contentSize&quot;];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-获取UIImage上某一点的颜色</title>
    <url>/p/db9441c0.html</url>
    <content><![CDATA[<hr>
<p>title: iOS 获取UIImage上某一点的颜色<br>date: 2018-06-07 18:12:21<br>tags: iOS<br>categories: IT</p>
<hr>
<h1 id="获取图片上某一点的颜色"><a href="#获取图片上某一点的颜色" class="headerlink" title="获取图片上某一点的颜色"></a>获取图片上某一点的颜色</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIColor *)colorAtPixel:(CGPoint)point &#123;</span><br><span class="line">    if (!CGRectContainsPoint(CGRectMake(0.0f, 0.0f, self.size.width, self.size.height), point)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIColor* color &#x3D; nil;</span><br><span class="line">    </span><br><span class="line">    CGImageRef inImage &#x3D; self.CGImage;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Create off screen bitmap context to draw the image into. Format ARGB is 4 bytes for each pixel: Alpa, Red, Green, Blue</span><br><span class="line">    CGContextRef cgctx &#x3D; [self createARGBBitmapContextFromImage:inImage];</span><br><span class="line">    if (cgctx &#x3D;&#x3D; NULL) &#123; return nil; &#x2F;* error *&#x2F; &#125;</span><br><span class="line">    </span><br><span class="line">    size_t cgimageWidth &#x3D; CGImageGetWidth(inImage);</span><br><span class="line">    size_t cgimageHeight &#x3D; CGImageGetHeight(inImage);</span><br><span class="line">    point &#x3D; CGPointMake(point.x&#x2F;self.size.width*cgimageWidth, point.y&#x2F;self.size.width*cgimageHeight);</span><br><span class="line">    CGRect rect &#x3D; &#123;&#123;0,0&#125;,&#123;cgimageWidth,cgimageHeight&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Draw the image to the bitmap context. Once we draw, the memory</span><br><span class="line">    &#x2F;&#x2F; allocated for the context for rendering will then contain the</span><br><span class="line">    &#x2F;&#x2F; raw image data in the specified color space.</span><br><span class="line">    CGContextDrawImage(cgctx, rect, inImage);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Now we can get a pointer to the image data associated with the bitmap</span><br><span class="line">    &#x2F;&#x2F; context.</span><br><span class="line">    unsigned char* data &#x3D; CGBitmapContextGetData (cgctx);</span><br><span class="line">    if (data !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F;offset locates the pixel in the data from x,y.</span><br><span class="line">        &#x2F;&#x2F;4 for 4 bytes of data per pixel, w is width of one row of data.</span><br><span class="line">        int offset &#x3D; 4*((cgimageWidth*round(point.y))+round(point.x));</span><br><span class="line">        CGFloat alpha &#x3D;  data[offset];</span><br><span class="line">        int red &#x3D; data[offset+1];</span><br><span class="line">        int green &#x3D; data[offset+2];</span><br><span class="line">        int blue &#x3D; data[offset+3];</span><br><span class="line">        color &#x3D; [UIColor colorWithRed:(red&#x2F;255.0f) green:(green&#x2F;255.0f) blue:(blue&#x2F;255.0f) alpha:(alpha&#x2F;255.0f)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; When finished, release the context</span><br><span class="line">    CGContextRelease(cgctx);</span><br><span class="line">    &#x2F;&#x2F; Free image data memory for the context</span><br><span class="line">    if (data) &#123; free(data); &#125;</span><br><span class="line">    </span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (CGContextRef) createARGBBitmapContextFromImage:(CGImageRef)inImage</span><br><span class="line">&#123;</span><br><span class="line">    CGContextRef    context &#x3D; NULL;</span><br><span class="line">    CGColorSpaceRef colorSpace;</span><br><span class="line">    void *          bitmapData;</span><br><span class="line">    int            bitmapByteCount;</span><br><span class="line">    int            bitmapBytesPerRow;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Get image width, height. We&#39;ll use the entire image.</span><br><span class="line">    size_t pixelsWide &#x3D; CGImageGetWidth(inImage);</span><br><span class="line">    size_t pixelsHigh &#x3D; CGImageGetHeight(inImage);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Declare the number of bytes per row. Each pixel in the bitmap in this</span><br><span class="line">    &#x2F;&#x2F; example is represented by 4 bytes; 8 bits each of red, green, blue, and</span><br><span class="line">    &#x2F;&#x2F; alpha.</span><br><span class="line">    bitmapBytesPerRow   &#x3D; (pixelsWide * 4);</span><br><span class="line">    bitmapByteCount     &#x3D; (bitmapBytesPerRow * pixelsHigh);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Use the generic RGB color space.</span><br><span class="line">    colorSpace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    </span><br><span class="line">    if (colorSpace &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error allocating color space\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Allocate memory for image data. This is the destination in memory</span><br><span class="line">    &#x2F;&#x2F; where any drawing to the bitmap context will be rendered.</span><br><span class="line">    bitmapData &#x3D; malloc( bitmapByteCount );</span><br><span class="line">    if (bitmapData &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf (stderr, &quot;Memory not allocated!&quot;);</span><br><span class="line">        CGColorSpaceRelease( colorSpace );</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Create the bitmap context. We want pre-multiplied ARGB, 8-bits</span><br><span class="line">    &#x2F;&#x2F; per component. Regardless of what the source image format is</span><br><span class="line">    &#x2F;&#x2F; (CMYK, Grayscale, and so on) it will be converted over to the format</span><br><span class="line">    &#x2F;&#x2F; specified here by CGBitmapContextCreate.</span><br><span class="line">    context &#x3D; CGBitmapContextCreate (bitmapData,</span><br><span class="line">                                     pixelsWide,</span><br><span class="line">                                     pixelsHigh,</span><br><span class="line">                                     8,      &#x2F;&#x2F; bits per component</span><br><span class="line">                                     bitmapBytesPerRow,</span><br><span class="line">                                     colorSpace,</span><br><span class="line">                                     kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    if (context &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free (bitmapData);</span><br><span class="line">        fprintf (stderr, &quot;Context not created!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Make sure and release colorspace before returning</span><br><span class="line">    CGColorSpaceRelease( colorSpace );</span><br><span class="line">    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>iOS11 自定义导航栏item边距</title>
    <url>/p/420832a0.html</url>
    <content><![CDATA[<p>iOS11下，用图片button来设置barButtonItem会无法设置Size，因为iOS11上，navigationBar相关布局修改为autolayout约束</p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>1、在设置成barButtonItem后，添加判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (@available(iOS 11, *)) &#123;</span><br><span class="line">      [rightBtn.widthAnchor constraintEqualToConstant:standardSize.width].active &#x3D; YES;</span><br><span class="line">      [rightBtn.heightAnchor constraintEqualToConstant:standardSize.height].active &#x3D; YES;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS10适配ATS</title>
    <url>/p/738bfe3e.html</url>
    <content><![CDATA[<h2 id="一-HTTPS"><a href="#一-HTTPS" class="headerlink" title="一. HTTPS"></a>一. HTTPS</h2><p>其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。从HTTP切换到HTTPS是一个非常简单的过程，在做具体的切换操作之前，我们需要了解几个概念：</p>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS:"></a>SSL/TLS:</h3><p>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，今后TLS将会继承SSL优良血统继续为我们进行加密服务</p>
<h3 id="SSL-TLS协议运行机制的概述"><a href="#SSL-TLS协议运行机制的概述" class="headerlink" title="SSL/TLS协议运行机制的概述"></a>SSL/TLS协议运行机制的概述</h3><p>简单的来说，SSL/TSL通过四次握手。SSL协议的工作流程：</p>
<ul>
<li>服务器认证阶段：</li>
<li>客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</li>
<li>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</li>
<li>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</li>
<li>服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</li>
<li>用户认证阶段：</li>
</ul>
<p>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。</p>
<p>经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证</p>
<h2 id="二-App-Transport-Security"><a href="#二-App-Transport-Security" class="headerlink" title="二. App Transport Security"></a>二. App Transport Security</h2><p>iOS9中新增App Transport Security（简称ATS）特性, 主要使到原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。在 iOS 9 和 OS X 10.11 中，默认情况下非 HTTPS 的网络访问是被禁止的。当然，因为这样的推进影响面非常广，作为缓冲，我们可以在 Info.plist 中添加 NSAppTransportSecurity<br>字典并且将 NSAllowsArbitraryLoads设置为 YES来禁用 ATS。</p>
<p><del>不过，WWDC 16 中，Apple 表示将继续在 iOS 10 和 macOS 10.12 里收紧对普通 HTTP 的访问限制。从 2017 年 1 月 1 日起，所有的新提交 app 默认是不允许使用 NSAllowsArbitraryLoads 来绕过 ATS 限制的，也就是说，我们最好保证 app 的所有网络请求都是 HTTPS 加密的，否则可能会在应用审核时遇到麻烦</del></p>
<h2 id="三-iOS10-NSAppTransportSecurity"><a href="#三-iOS10-NSAppTransportSecurity" class="headerlink" title="三. iOS10 NSAppTransportSecurity"></a>三. iOS10 NSAppTransportSecurity</h2><p>通过在info.plist中配置这个键，开发者可以自定义网络安全策略。例如：</p>
<ul>
<li>允许针对个别服务器的不安全访问。</li>
<li>允许不安全的 web 或媒体内容访问，但不影响整个app的ATS策略。</li>
<li>启用新的安全特性，例如Certificate Transparency。</li>
<li>对NSAppTransportSecurity的支持自 iOS9.0，OS X v10.11 开始，适用于 app 和 app extension。</li>
</ul>
<p>自 iOS10.0，macOS 10.12 开始，增加了对下列子键的支持：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSAllowsArbitraryLoadsInMedia</span><br><span class="line">NSAllowsArbitraryLoadsInWebContent</span><br><span class="line">NSRequiresCertificateTransparency</span><br><span class="line">NSAllowsLocalNetworking</span><br></pre></td></tr></table></figure>

<h3 id="ATS-Configuration-Basics-ATS-配置基础知识"><a href="#ATS-Configuration-Basics-ATS-配置基础知识" class="headerlink" title="ATS Configuration Basics / ATS 配置基础知识"></a>ATS Configuration Basics / ATS 配置基础知识</h3><p>对于使用 iOS9.0， OS X v10.11 SDK 及以上的 app 来说，ATS（App Transport Security）默认开启，NSAllowsArbitraryLoads是字典NSAppTransportSecurity的根键，默认值NO。</p>
<p>在启用 ATS 的情况下，所有的 HTTP 请求必须为 HTTPS（RFC 2818） 连接。任何不安全的 HTTP 请求都将失败。ATS 使用 TLS（Transport Layer Security）v1.2（RFC 5246）。</p>
<p>下面是字典NSAppTransportSecurity的总体结构，所有键都是非必填:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSAppTransportSecurity : Dictionary &#123;</span><br><span class="line">    NSAllowsArbitraryLoads : Boolean</span><br><span class="line">    NSAllowsArbitraryLoadsInMedia : Boolean</span><br><span class="line">    NSAllowsArbitraryLoadsInWebContent : Boolean</span><br><span class="line">    NSAllowsLocalNetworking : Boolean</span><br><span class="line">    NSExceptionDomains : Dictionary &#123;</span><br><span class="line">         : Dictionary &#123;</span><br><span class="line">            NSIncludesSubdomains : Boolean</span><br><span class="line">            NSExceptionAllowsInsecureHTTPLoads : Boolean</span><br><span class="line">            NSExceptionMinimumTLSVersion : String</span><br><span class="line">            NSExceptionRequiresForwardSecrecy : Boolean   &#x2F;&#x2F; Default value is YES</span><br><span class="line">            NSRequiresCertificateTransparency : Boolean</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，所有键可以分为两类：主键，这些键用来定义 app 的总体 ATS 策略；子键，即NSExceptionDomains下面的键，使用这些键针对某个域名单独配置.</p>
<p>主键包括：</p>
<h4 id="NSAllowsArbitraryLoads"><a href="#NSAllowsArbitraryLoads" class="headerlink" title="NSAllowsArbitraryLoads"></a>NSAllowsArbitraryLoads</h4><p>设置为 YES，解除整个 app 的 ATS 限制；但是，通过-NSExceptionDomains进 行的配置依然有效。默认值为 NO。</p>
<p>注意：设置为 YES，会引发 App Stroe 的审查，开发者必须说明原因。</p>
<h4 id="NSAllowsArbitraryLoadsInMedia"><a href="#NSAllowsArbitraryLoadsInMedia" class="headerlink" title="NSAllowsArbitraryLoadsInMedia"></a>NSAllowsArbitraryLoadsInMedia</h4><p>设置为 YES，解除通过 AV Foundation 框架访问媒体内容时的 ATS 限制；启用这个 键，务必确保载入的媒体内容已经被加密，例如受FairPlay保护的文件，或者是安全的 HLS流媒，其中不包含敏感的个人信息。默认为 NO。</p>
<h4 id="NSAllowsArbitraryLoadsInWebContent"><a href="#NSAllowsArbitraryLoadsInWebContent" class="headerlink" title="NSAllowsArbitraryLoadsInWebContent"></a>NSAllowsArbitraryLoadsInWebContent</h4><p>设置为 YES，解除通过 web view 发出的网络请求的 ATS 限制。启用这个键，可以使 app 访问任意网页内容，但不影响 app 的总体 ATS 策略。此键值默认为 NO。</p>
<h4 id="NSAllowsLocalNetworking"><a href="#NSAllowsLocalNetworking" class="headerlink" title="NSAllowsLocalNetworking"></a>NSAllowsLocalNetworking</h4><p>设置为 YES，使得 app 可以载入任意本地资源，但不影响 app 的总体 ATS 策略。默 认为 NO。</p>
<h4 id="NSExceptionDomains"><a href="#NSExceptionDomains" class="headerlink" title="NSExceptionDomains"></a>NSExceptionDomains</h4><p>为一个或多个域名单独配置 ATS。</p>
<p>被单独配置的域名，默认受到完全的 ATS 限制，不管NSAllowsArbitraryLoads的值 如何；需要通过子键，进一步配置<br>所有的子键都属于NSExceptionDomain。向Info.plist中添加这一主键：创建字典，针对一个或多个域名，以便进行 ATS 配置。</p>
<p>这意味着之前使用主键所做的设置，对于这个域名来说，已经无效。</p>
<p>例如，及时之前设置NSAllowsArbitraryLoadsInMedia为 YES，然而NSExceptionDomain所代表的域名依然不能访问不安全的媒体内容。<br>基于这样的设定，可以针对域名进行 ATS 配置，增加或减少安全措施。例如：将NSExceptionAllowsInsecureHTTPLoads设置为 YES，就 ；这样做会引发 App Store 的审查，详情见App Store Review for ATS。通过配置NSExceptionRequiresForwardSecrecy为 NO，取消正向保密。</p>
<p>通过配置NSExceptionMinimumTLSVersion，更改 TLS 最低版本</p>
<h4 id="NSExceptionDomains字典构成："><a href="#NSExceptionDomains字典构成：" class="headerlink" title="NSExceptionDomains字典构成："></a>NSExceptionDomains字典构成：</h4><p>&lt;域名字符串&gt;代表想要配置的特定域名。可以添加多个域名（即添加多个这样的键），为它们统一配置 ATS 策略。这个键对应一个字典，包含以下子键：</p>
<ul>
<li>NSIncludesSubdomains 设置为 YES，当前域名的 ATS 策略适用于其所有子域名。默认为 NO。</li>
<li>NSExceptionAllowsInsecureHTTPLoads 设置为 YES，可以同时通过 HTTP 和 HTTPS 访问当前域名。默认为 NO。注意，配置这个键值，将引发 App Store 的审查，开发者必须说明原因。</li>
<li>NSExceptionMinimumTLSVersion* 指定 TLS 的最低版本，因此可以使用版本较低，有安全漏洞的 TLS 协议。注意，配置这个键值，将引发 App Store 的审查，开发者必须说明原因。</li>
<li>NSExceptionRequiresForwardSecrecy* 设置为 NO，允许针对当前域名使用不支持正向保密的 TLS 加密算法。默认为 YES。</li>
<li>NSRequiresCertificateTransparency* 设置为 YES，将验证域名服务器证书的Certificate Transparency时间戳 。默认为 NO。</li>
</ul>
<p>Requirements for Connecting Using ATS ／ 使用 ATS 的前提条件</p>
<p>在 ATS 完全开启的情况下，系统要求 app 的 HTTPS 连接必须满足以下要求：</p>
<p>X.509 数字证书必须满足下列标准中的一项：</p>
<p>由操作系统内嵌的根证书颁发机构签发<br>由通过操作系统管理员或用户主动安装的根证书颁发机构签发TLS 版本必须为1.2，任何不使用或使用较低版本 TLS / SSL 的连接，都将失败。</p>
<p>连接必须使用 AES-128 或 AES-256 对称加密算法。 TLS 算法套装必须以 ECDSA 密钥交换的形式支持正向保密，加密算法必须为下面之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</span><br><span class="line">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span><br><span class="line">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</span><br><span class="line">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</span><br><span class="line">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</span><br><span class="line">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</span><br><span class="line">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</span><br><span class="line">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span><br><span class="line">TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</span><br><span class="line">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</span><br><span class="line">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</span><br></pre></td></tr></table></figure>

<p>服务端的叶证书签名密钥必须为下面之一：</p>
<p>至少2048位的 RSA 密钥</p>
<p>至少256位的 ECC 密钥</p>
<p>此外，服务器证书的哈希算法必须为 SHA-2，其摘要长度至少位256位（即 SHA-256 及以上）。上面的标准，未来可能会发生变化。但不会影响到 app 二进制包的兼容性。</p>
<h3 id="App-Store-Review-for-ATS-App-Store-对于-ATS-相关项的审核"><a href="#App-Store-Review-for-ATS-App-Store-对于-ATS-相关项的审核" class="headerlink" title="App Store Review for ATS / App Store 对于 ATS 相关项的审核"></a>App Store Review for ATS / App Store 对于 ATS 相关项的审核</h3><p>某些对 ATS 的配置会引发 App Store 的审核，开发者必须说明原因。这些键有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSAllowsArbitraryLoads</span><br><span class="line">NSExceptionAllowsInsecureHTTPLoads</span><br><span class="line">NSExceptionMinimumTLSVersion</span><br></pre></td></tr></table></figure>

<p>以下是一些原因说明例子，供参考：</p>
<ul>
<li>必须连接由其他机构控制的服务器，其还不支持安全连接。</li>
<li>必须支持那些还未升级至可使用安全连接，不得不通过公共域名访问网络的设备。</li>
<li>必须通过 web 展示来源不一的各种网络内容，但又不能完全使用NSAllowsArbitraryLoadsInWebContent所管理的类。</li>
<li>向 App Store 提交审核时，开发者应主动提供足够的信息，以便解释 app 无法使用安全连接的原因</li>
</ul>
<h2 id="四-实现支持安全ATS策略"><a href="#四-实现支持安全ATS策略" class="headerlink" title="四. 实现支持安全ATS策略"></a>四. 实现支持安全ATS策略</h2><p>ATS相关设置对iOS8及以下系统无效</p>
<p>需要解决的问题（iOS 9、iOS10及以上）</p>
<p>1、app内服务器网络请求访问支持https（即一般的请求）</p>
<p>2、webview内支持任意http访问</p>
<p>3、第三方sdk接入与支持http访问</p>
<p>主要是围绕info.pilst配置文件作相关的安全ATS策略</p>
<p>Info.plist文件是向操作系统描述应用程序的XML属性列表,是iPhone应用程序文件夹包含所有重要的Info.plist文件<br>你可能注意到一些关键字像是使用了一些其他关键字中的词但是在前面加上了”ThirdParty”字样，在功能上，这些关键字与不含有”ThirdParty”的关键字有同样的效果。而且实际运行中所调用的代码将会完全忽略是否使用”ThirdParty”关键字。</p>
<p>简单粗暴的方案：</p>
<hr>
<p>NSExceptionDomains 的设置方法如下, 比如我们要将 weibo.com 这个域名排除在 ATS 验证之外，就可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key&gt;NSAppTransportSecurity&lt;&#x2F;key&gt;  </span><br><span class="line">&lt;dict&gt;  </span><br><span class="line">    &lt;key&gt;NSExceptionDomains&lt;&#x2F;key&gt;  </span><br><span class="line">    &lt;dict&gt;  </span><br><span class="line">        &lt;key&gt;weibo.com&lt;&#x2F;key&gt;  </span><br><span class="line">        &lt;dict&gt;  </span><br><span class="line">            &lt;key&gt; NSIncludesSubdomains &lt;&#x2F;key&gt;  </span><br><span class="line">            &lt;true&#x2F;&gt;  </span><br><span class="line">            &lt;key&gt; NSExceptionRequiresForwardSecrecy &lt;&#x2F;key&gt;  </span><br><span class="line">            &lt;false&#x2F;&gt;  </span><br><span class="line">            &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;&#x2F;key&gt;  </span><br><span class="line">            &lt;true&#x2F;&gt;  </span><br><span class="line">        &lt;&#x2F;dict&gt;  </span><br><span class="line">    &lt;&#x2F;dict&gt;  </span><br><span class="line">    &lt;key&gt;NSAllowsArbitraryLoads&lt;&#x2F;key&gt;  </span><br><span class="line">    &lt;true&#x2F;&gt;  </span><br><span class="line">&lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>

<p>注意：每个需添加的域都需要设置此三个属性。如果请求的网络图片是HTTP，也是需要设置的图片的域。</p>
<p>注意⚠️这个方案风险较大，有可能被拒绝。“需要访问的域名是第三方服务器，他们没有进行 HTTPS 对应”会是审核时的一个可选理由，但是这应该只需要针对特定域名，而非全面开放。如果访问的是自己的服务器的话，可能这个理由会无法通过.</p>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>1、app内服务器网络请求访问支持https</p>
<p>解决方案：</p>
<p>搭建https服务器</p>
<p>搭建https服务器需要ssl证书</p>
<ul>
<li>ssl自制证书：称自签名ssl证书，容易被假冒伪造，浏览器不信任。（审核不通过）</li>
<li>免费CA证书：部分CA机构提供免费的SSL证书，如wosign，starts等（App Store pass掉不通过）</li>
<li>付费CA证书：多指企业级及以上的数字证书。</li>
</ul>
<p>HTTPS服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，那么我们在使用Xcode开发的时候，对网络的适配什么都不用做，我们也能正常与服务器通信。但是，当我们对安全性有更高的要求时或者我们自建证书时，我们需要本地导入证书来进行验证。</p>
<h3 id="使用AFNetworking来支持https"><a href="#使用AFNetworking来支持https" class="headerlink" title="使用AFNetworking来支持https"></a>使用AFNetworking来支持https</h3><p>AFNetworking是iOS/OSX开发最流行的第三方开源库之一,现在iOS oc 代码90%以上都是用这个框架网络请求。AFNetworking已经将上面的逻辑代码封装好，甚至更完善，在AFSecurityPolicy文件中，有兴趣可以阅读这个模块的代码；以下就是在AFNetworking 2.6.0以前版本和3.0.0版本基于支持https的验证方式</p>
<p>步骤：</p>
<ul>
<li>新建一个manager</li>
<li>在mainBundle中寻找我们刚才拖进项目中的https.cer, 并且将相关的数据读取出来</li>
<li>新建一个AFSecurityPolicy，并进行相应的配置</li>
<li>将这个AFSecurityPolicy 实例赋值给manager</li>
</ul>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSURL  url &#x3D; [NSURL URLWithString:@”https:&#x2F;&#x2F;www.google.com&quot;];</span><br><span class="line">AFHTTPRequestOperationManager  requestOperationManager &#x3D; [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];</span><br><span class="line">dispatch_queue_t requestQueue &#x3D; dispatch_create_serial_queue_for_name(“kRequestCompletionQueue”);</span><br><span class="line">requestOperationManager.completionQueue &#x3D; requestQueue;</span><br><span class="line">AFSecurityPolicy * securityPolicy &#x3D; [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span><br><span class="line">&#x2F;&#x2F;如果是需要验证自建证书，需要设置为YES</span><br><span class="line">securityPolicy.allowInvalidCertificates &#x3D; YES;</span><br><span class="line">&#x2F;&#x2F;validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">&#x2F;&#x2F;假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span><br><span class="line">&#x2F;&#x2F;置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span><br><span class="line">&#x2F;&#x2F;如置为NO，建议自己添加对应域名的校验逻辑。</span><br><span class="line">securityPolicy.validatesDomainName &#x3D; YES;</span><br><span class="line">&#x2F;&#x2F;validatesCertificateChain 是否验证整个证书链，默认为YES</span><br><span class="line">&#x2F;&#x2F;设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：</span><br><span class="line">&#x2F;&#x2F;GeoTrust Global CA</span><br><span class="line">&#x2F;&#x2F; Google Internet Authority G2</span><br><span class="line">&#x2F;&#x2F; .google.com</span><br><span class="line">&#x2F;&#x2F;那么，除了导入.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；</span><br><span class="line">&#x2F;&#x2F;如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">securityPolicy.validatesCertificateChain &#x3D; NO;</span><br><span class="line">requestOperationManager.securityPolicy &#x3D; securityPolicy;</span><br><span class="line"></span><br><span class="line">另afnetworking 3.0.0以上版本用的是AFHTTPSessionManager</span><br><span class="line"></span><br><span class="line"> AFHTTPSessionManager  manager &#x3D; [AFHTTPSessionManager manager];</span><br><span class="line">    NSString  cerPath &#x3D; [[NSBundle mainBundle] pathForResource:@”server” ofType:@”cer”];</span><br><span class="line">    NSData  cerData &#x3D; [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">    NSLog(@”%@”, cerData);</span><br><span class="line">    manager.securityPolicy &#x3D; [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:[[NSArray alloc] initWithObjects:cerData, nil nil]];</span><br><span class="line">    manager.securityPolicy.allowInvalidCertificates &#x3D; YES;</span><br><span class="line">    [manager.securityPolicy setValidatesDomainName:NO];</span><br><span class="line">    manager.requestSerializer &#x3D; [AFJSONRequestSerializer serializer];</span><br><span class="line">    manager.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];</span><br><span class="line">    NSDictionary  parameter &#x3D; @&#123;@”username”:self.username, @”password”:self.password&#125;;</span><br><span class="line">    [manager POST:@”https:&#x2F;&#x2F;192.168.1.4:9777&quot; parameters:parameter success:^(NSURLSessionDataTask  task, id responseObject) &#123;</span><br><span class="line">        NSLog(@”success %@”, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">        failure:^(NSURLSessionDataTask  task, NSError * error) &#123;</span><br><span class="line">            NSLog(@”failure %@”, error);</span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure>


<h3 id="NSAppTransportSecurity"><a href="#NSAppTransportSecurity" class="headerlink" title="NSAppTransportSecurity"></a>NSAppTransportSecurity</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSAllowsArbitraryLoads &#x2F;&#x2F;设置为 YES，解除整个app的ATS限制；但是通过NSExceptionDomains进行的配置依然有效</span><br><span class="line"></span><br><span class="line">NSAllowsArbitraryLoadsInMedia &#x2F;&#x2F;设置为 YES，解除通过AVFoundation框架访问媒体内容时的 ATS 限制</span><br><span class="line"></span><br><span class="line">NSAllowsArbitraryLoadsInWebContent &#x2F;&#x2F;设置为 YES，解除通过webview发出的网络请求的ATS限制</span><br><span class="line"></span><br><span class="line">NSAllowsLocalNetworking &#x2F;&#x2F;设置为 YES，使得app可以载入任意本地资源，但不影响app的总体 ATS 策略</span><br></pre></td></tr></table></figure>


<h3 id="2、webview内支持任意http访问"><a href="#2、webview内支持任意http访问" class="headerlink" title="2、webview内支持任意http访问"></a>2、webview内支持任意http访问</h3><p>对于网页浏览和视频播放的行为，iOS 10 中新加入了 NSAllowsArbitraryLoadsInWebContent 键。通过将它设置为 YES，可以让 app 中的 WKWebView 和使用 AVFoundation 播放的在线视频不受 ATS 的限制。这也应该是绝大多数使用了相关特性的 app 的选择。但是坏消息是这个键在 iOS 9 中并不会起作用。</p>
<p>如果app只支持 iOS 10，并且有用户可以自由输入网址进行浏览的功能，或者是在线视频音频播放功能的话，简单地加入 NSAllowsArbitraryLoadsInWebContent，并且将组件换成 WKWebKit 或者 AVFoundation 就可以了。如果你还需要支持 iOS 9，并且需要访问网页和视频的话，可能只能去开启 NSAllowsArbitraryLoads 然后提交时进行说明，并且看 Apple 审核员决定让不让通过了。</p>
<p>另外，当 NSAllowsArbitraryLoads 和NSAllowsArbitraryLoadsInWebContent 同时存在时，根据系统不同，表现的行为也会不一样。简单说，iOS 9 只看NSAllowsArbitraryLoads，而 iOS 10 会先看NSAllowsArbitraryLoadsInWebContent。在 iOS 10 中，要是NSAllowsArbitraryLoadsInWebContent 存在的话，就忽略掉NSAllowsArbitraryLoads，如果它不存在，则遵循NSAllowsArbitraryLoads 的设定UIWebView 在 NSAllowsArbitraryLoadsInWebContent 为 YES 时访问 HTTP，无效。WKWebView 在 NSAllowsArbitraryLoadsInWebContent 为 YES 时在iOS 10 中访问 HTTP，有效，iOS 9无效。如果用WkWebView替换UIWebView，iOS 7 将无法使用WkWebView，可做适配加载，没有特殊的什么需求的话，尽早将 UIWebView 全部换为 WkWebView 会比较好。所以为了能让WebView在所有版本都能访问非https内容，只能把NSAllowsArbitraryLoads设置为YES。</p>
<h4 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h4><p>开启 NSAllowsArbitraryLoads 为 YES，然后提交时进行说明</p>
<h4 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h4><p>设置 NSExceptionDomains 属性来访问指定域名，然后提交时进行说明</p>
<h3 id="3、第三方sdk接入与支持http访问"><a href="#3、第三方sdk接入与支持http访问" class="headerlink" title="3、第三方sdk接入与支持http访问"></a>3、第三方sdk接入与支持http访问</h3><p>但是按照国内的现状，关闭这个限制也许是更实际的做法。至于原因就太多了，第三方SDK（几乎都是访问http），合作伙伴接入（不能要求它们一定要支持https）第三方sdk，同样需要遵守ATS规则，即第三方sdk也有被ATS过滤的风险，微信，qq，分享，登陆功能都能正常，微博登陆不能正常通过。另在网上找到了一些可能存在有问题的sdk，目前已知的有：</p>
<ul>
<li>友盟 （已经有最新的v1.4.0版本sdk，支持https，待验证）</li>
<li>百度地图</li>
</ul>
<h4 id="解决方案一：-1"><a href="#解决方案一：-1" class="headerlink" title="解决方案一："></a>解决方案一：</h4><p>更新最新sdk，接入并测试</p>
<h4 id="解决方案二：-1"><a href="#解决方案二：-1" class="headerlink" title="解决方案二："></a>解决方案二：</h4><p>可以设置 NSExceptionDomains属性来将需要排除强制验证的域名写进来：</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>开启 NSAllowsArbitraryLoads 为 YES</p>
<p>对第三方访问的服务器设置NSExceptionDomains方式添加白名单</p>
<p>提交审核说明：</p>
<p>必须连接由其他机构控制的服务器，其还不支持安全连接。必须通过 web 展示来源不一的各种网络内容，但又不能完全使用NSAllowsArbitraryLoadsInWebContent所管理的类。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中的HTTPS证书校验</title>
    <url>/p/e0dc9eb4.html</url>
    <content><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>本文的目的，一是简要分析下对服务器身份验证的完整握手过程，二是证书链的验证，三是探索下iOS中原生库NSURLConnection或NSURLSession如何支持实现https。</p>
<a id="more"></a>

<h2 id="一、HTTPS"><a href="#一、HTTPS" class="headerlink" title="一、HTTPS"></a>一、HTTPS</h2><p>HTTPS是承载在TLS/SSL之上的HTTP，相较于HTTP明文数据传输方面所暴露出的缺点，HTTPS具有防止信息被窃听、篡改、劫持，提供信息加密，完整性校验及身份验证等优势。TLS/SSL是安全传输层协议，介于TCP和HTTP之间。TLS1.0是建立在SSL3.0规范之上的，可以理解为SSL3.0的升级版本。目前推荐使用的版本是TLS1.2。</p>
<p>TLS/SSL协议通常分为两层：TLS记录协议(TLS Record Protocol)和TLS握手协议(TLS Handshake Protocol)。 TLS记录协议建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。TLS握手协议建立在记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。除了这俩协议以外，还存在其它三种辅助协议： Changecipher spec 协议用来通知对端从handshake切换到record协议(有点冗余，在TLS1.3里面已经被删掉了)。alert协议，用来通知各种返回码。application data协议，就是把http，smtp等的数据流传入record层做处理并传输。</p>
<p>想象一种场景：通常我们会访问 <a href="http://xxx" target="_blank" rel="noopener">http://xxx</a> 的网站，当你在浏览器地址栏输入支持HTTPS协议的URL地址后，服务器返回的数据会显示在页面上。对于不了解HTTPS协议工作原理的小伙伴可能觉得这个过程很简单：发送请求－服务器响应请求－结果返回并显示。但对于HTTPS而言，在整个发送请求返回数据过程中还涉及到通讯双方证书验证、数据加密、数据完整性校验等。</p>
<p>下面以登录qq邮箱为例，通过Wireshark抓包可以看到如下图：</p>
<p>在浏览器与服务器进行Application Data传输之前，还经历了Client Hello－Server Hello－Client Key Exchange－Change Cipher Spec等过程。而这些过程正是TLS/SSL提供的服务所决定的：</p>
<ul>
<li>认证服务器身份，确保数据发送到正确的服务器；</li>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ul>
<p>上述单向验证的完整握手过程，总结如下：</p>
<h3 id="第一阶段：ClientHello"><a href="#第一阶段：ClientHello" class="headerlink" title="第一阶段：ClientHello"></a>第一阶段：ClientHello</h3><p>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数random_C，扩展字段等信息。</p>
<h3 id="第二阶段：ServerHello－ServerHelloDone"><a href="#第二阶段：ServerHello－ServerHelloDone" class="headerlink" title="第二阶段：ServerHello－ServerHelloDone"></a>第二阶段：ServerHello－ServerHelloDone</h3><p>如上图可以看出这个阶段包含4个过程( 有的服务器是单条发送，有的是合并一起发送)。服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法、随机数random_S等，其中随机数用于后续的密钥协商。服务器也会配置并返回对应的证书链Certificate，用于身份验证与密钥交换。然后会发送ServerHelloDone信息用于通知服务器信息发送结束。</p>
<h3 id="第三阶段：证书校验"><a href="#第三阶段：证书校验" class="headerlink" title="第三阶段：证书校验"></a>第三阶段：证书校验</h3><p>在上图中的5-6之间，客户端这边还需要对服务器返回的证书进行校验。只有证书验证通过后，才能进行后续的通信。(具体分析可参看后续的证书验证过程)</p>
<h3 id="第四阶段：ClientKeyExchange－Finished"><a href="#第四阶段：ClientKeyExchange－Finished" class="headerlink" title="第四阶段：ClientKeyExchange－Finished"></a>第四阶段：ClientKeyExchange－Finished</h3><p>服务器返回的证书验证合法后， 客户端计算产生随机数字Pre-master，并用server证书中公钥加密，发送给服务器。同时客户端会根据已有的三个随机数根据相应的生成协商密钥。客户端会通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。然后客户端发送Finished消息用于通知客户端信息发送结束。</p>
<h3 id="第五阶段：服务器端生成协商密钥"><a href="#第五阶段：服务器端生成协商密钥" class="headerlink" title="第五阶段：服务器端生成协商密钥"></a>第五阶段：服务器端生成协商密钥</h3><p>服务器也会根据已有的三个随机数使用相应的算法生成协商密钥，会通知客户端后续的通信都采用协商的通信密钥和加密算法进行加密通信。然后发送Finished消息用于通知服务器信息发送结束。</p>
<h3 id="第六阶段：握手结束"><a href="#第六阶段：握手结束" class="headerlink" title="第六阶段：握手结束"></a>第六阶段：握手结束</h3><p>在握手阶段结束后，客户端和服务器数据传输开始使用协商密钥进行加密通信。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，HTTPS请求整个过程主要分为两部分。一是握手过程：用于客户端和服务器验证双方身份，协商后续数据传输时使用到的密钥等。二是数据传输过程：身份验证通过并协商好密钥后，通信双方使用协商好的密钥加密数据并进行通信。在握手过程协商密钥时，使用的是非对称密钥交换算法， 密钥交换算法本身非常复杂，密钥交换过程涉及到随机数生成，模指数运算，空白补齐，加密，签名等操作。在数据传输过程中，客户端和服务器端使用协商好的密钥进行对称加密解密。</p>
<h2 id="二、证书"><a href="#二、证书" class="headerlink" title="二、证书"></a>二、证书</h2><p>PKI (Public Key Infrastructure)，公开密钥基础设施。它是一个标准,在这个标准之下发展出的为了实现安全基础服务目的的技术统称为PKI。 权威的第三方机构CA(认证中心)是PKI的核心， CA负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务。 x.509是PKI中最重要的标准，它定义了公钥证书的基本结构。</p>
<h3 id="证书申请过程"><a href="#证书申请过程" class="headerlink" title="证书申请过程"></a>证书申请过程</h3><ul>
<li>证书申请者向颁发证书的可信第三方CA提交申请证书相关信息，包括：申请者域名、申请者生成的公钥(私钥自己保存)及证书请求文件.cer等</li>
</ul>
<ul>
<li>CA通过线上、线下等多种手段验证证书申请者提供的信息合法和真实性。</li>
</ul>
<ul>
<li>当证书申请者提供的信息审核通过后，CA向证书申请者颁发证书，证书内容包括明文信息和签名信息。其中明文信息包括证书颁发机构、证书有效期、域名、申请者相关信息及申请者公钥等，签名信息是使用CA私钥进行加密的明文信息。当证书申请者获取到证书后，可以通过安装的CA证书中的公钥对签名信息进行解密并与明文信息进行对比来验证签名的完整性。</li>
</ul>
<h3 id="证书验证过程"><a href="#证书验证过程" class="headerlink" title="证书验证过程"></a>证书验证过程</h3><ul>
<li>验证证书本身的合法性（验证签名完整性，验证证书有效期等）</li>
<li>验证证书颁发者的合法性（查找颁发者的证书并检查其合法性，这个过程是递归的）</li>
<li>证书验证的递归过程最终会成功终止，而成功终止的条件是：证书验证过程中遇到了锚点证书，锚点证书通常指：嵌入到操作系统中的根证书(权威证书颁发机构颁发的自签名证书)。</li>
</ul>
<h3 id="证书验证失败的原因"><a href="#证书验证失败的原因" class="headerlink" title="证书验证失败的原因"></a>证书验证失败的原因</h3><ul>
<li>无法找到证书的颁发者</li>
<li>证书过期</li>
<li>验证过程中遇到了自签名证书，但该证书不是锚点证书。</li>
<li>无法找到锚点证书(即在证书链的顶端没有找到合法的根证书)</li>
<li>访问的server的dns地址和证书中的地址不同</li>
</ul>
<h2 id="三、iOS实现支持HTTPS"><a href="#三、iOS实现支持HTTPS" class="headerlink" title="三、iOS实现支持HTTPS"></a>三、iOS实现支持HTTPS</h2><p>在OC中当使用NSURLConnection或NSURLSession建立URL并向服务器发送https请求获取资源时，服务器会使用HTTP状态码401进行响应(即访问拒绝)。此时NSURLConnection或NSURLSession会接收到服务器需要授权的响应，当客户端授权通过后，才能继续从服务器获取数据。如下图所示：</p>
<h3 id="非自签名证书验证实现"><a href="#非自签名证书验证实现" class="headerlink" title="非自签名证书验证实现"></a>非自签名证书验证实现</h3><p>在接收到服务器返回的状态码为401的响应后，对于NSURLSession而言，需要代理对象实现URLSession:task:didReceiveChallenge:completionHandler:方法。对于NSURLConnection而言，需要代理对象实现connection:willSendRequestForAuthenticationChallenge: 方法(OS X v10.7和iOS5及以上)，对于早期的版本代理对象需要实现代理对象要实现connection:canAuthenticateAgainstProtectionSpace:和connection:didReceiveAuthenticationChallenge:方法。代码如下(参考文档)：</p>
<p>当客户端发送https请求后，服务器会返回需要授权的相关信息，然后connection:willSendRequestForAuthenticationChallenge:方法被调用。客户端根据返回的challenge信息，首先获取需要验证的信任对象trust,然后调用SecTrustEvaluate方法是用系统默认的验证方式对信任对象进行验证，当验证通过时，使用该信任对象trust生成证书凭证，然后self.connection使用该凭证继续连接。如下详解：</p>
<p>NSURLAuthenticationChallenge包含如下信息：</p>
<ul>
<li><p>error ：最后一次授权失败的错误信息</p>
</li>
<li><p>failureResponse ：最后一次授权失败的错误信息</p>
</li>
<li><p>previousFailureCount ：授权失败的次数</p>
</li>
<li><p>proposedCredential ：建议使用的证书</p>
</li>
<li><p>protectionSpace ：NSURLProtectionSpace对象，代表了服务器上的一块需要授权信息的区域。包括了服务器地址、端口等信息。在此指的是challenge.protectionSpace。其中Auth-scheme指protectionSpace所支持的验证方法，+ NSURLAuthenticationMethodServerTrust指对protectionSpace执行证书验证。</p>
</li>
<li><p>sender:发送者，在此指的是self.connection</p>
</li>
<li><p>SecTrustRef</p>
</li>
</ul>
<p>表示需要验证的信任对象(Trust Object)，在此指的是challenge.protectionSpace.serverTrust。包含待验证的证书和支持的验证方法等。</p>
<ul>
<li>SecTrustResultType</li>
</ul>
<p>表示验证结果。其中 kSecTrustResultProceed表示serverTrust验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)。 kSecTrustResultUnspecified表示 serverTrust验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书。 两者取其一就可以认为对serverTrust验证成功。</p>
<ul>
<li>SecTrustEvaluate</li>
</ul>
<p>函数内部递归地从叶节点证书到根证书验证。使用系统默认的验证方式验证Trust Object，根据上述证书链的验证可知，系统会根据Trust Object的验证策略，一级一级往上，验证证书链上每一级证书有效性。</p>
<ul>
<li>NSURLCredential</li>
</ul>
<p>表示身份验证证书。URL Lodaing支持3种类型证书：password-based user credentials, certificate-based user credentials, 和certificate-based server credentials(需要验证服务器身份时使用)。因此NSURLCredential可以表示由用户名/密码组合、客户端证书及服务器信任创建的认证信息，适合大部分的认证请求。对于NSURLCredential也存在三种持久化机制：</p>
<ul>
<li>NSURLCredentialPersistenceNone ：要求 URL 载入系统 “在用完相应的认证信息后立刻丢弃”。</li>
<li>NSURLCredentialPersistenceForSession ：要求 URL 载入系统 “在应用终止时，丢弃相应的 credential ”。</li>
<li>NSURLCredentialPersistencePermanent ：要求 URL 载入系统 “将相应的认证信息存入钥匙串（keychain），以便其他应用也能使用。</li>
</ul>
<p>对于已经验证通过的信任对象，客户端也可以不提供证书凭证。</p>
<p>对于NSURLSession，传递如下之一的值给completion handler回调：</p>
<p>NSURLSessionAuthChallengePerformDefaultHandling处理请求，就好像代理没有提供一个代理方法来处理认证请求</p>
<p>NSURLSessionAuthChallengeRejectProtectionSpace拒接认证请求。基于服务器响应的认证类型，URL加载类可能会多次调用代理方法。</p>
<p>对于 NSURLConnection 和 NSURLDownload，在[challenge sender] 上调用continueWithoutCredentialsForAuthenticationChallenge:方法。不提供证书的话，可能会导致连接失败，调用connectionDidFailWithError:方法 ，或者会返回一个不需要验证身份的替代的URL。 如下代码：</p>
<p>对于非自签名的证书，即使服务器返回的证书是信任的CA颁发的，而为了确定返回的证书正是客户端需要的证书，这需要本地导入证书，并将证书设置成需要参与验证的锚点证书，再调用SecTrustEvaluate通过本地导入的证书来验证服务器证书是否是可信的。如果服务器证书是这个锚点证书对应CA或者子CA颁发的，或服务器证书本身就是这个锚点证书，则证书信任通过。如下代码(参考文档)：</p>
<h3 id="自签名证书验证实现"><a href="#自签名证书验证实现" class="headerlink" title="自签名证书验证实现"></a>自签名证书验证实现</h3><p>对于自签名证书，这样Trust Object中的服务器证书是不可信任的CA颁发的，直接使用SecTrustEvaluate验证是不会成功的。可以采取下述简单代码绕过HTTPS的验证：</p>
<p>上述代码一般用于当服务器使用自签名证书时，为了方便测试，客户端可以通过该方法信任所有自签名证书。</p>
<p>综上对非自建和自建证书验证过程的分析，可以总结如下：</p>
<p>获取需要验证的信任对象(Trust Object)。对于NSURLConnection来说，<br>是从delegate方法-connection: willSendRequestForAuthenticationChallenge:回调回来的参数challenge中获取(challenge.protectionSpace.serverTrust) 。</p>
<p>使用系统默认验证方式验证Trust Object。SecTrustEvaluate会根据Trust Object的验证策略，一级一级往上，验证证书链上每一级数字签名的有效性，从而评估证书的有效性。</p>
<p>如第二步验证通过了，一般的安全要求下，就可以直接验证通过，进入到下一步：使用Trust Object生成一份凭证([NSURLCredential credentialForTrust:serverTrust])，传入challenge的sender中([challenge.sender useCredential:cred forAuthenticationChallenge:challenge])处理，建立连接。</p>
<p>假如有更强的安全要求，可以继续对Trust Object进行更严格的验证。常用的方式是在本地导入证书，验证Trust Object与导入的证书是否匹配。</p>
<p>假如验证失败，取消此次Challenge-Response Authentication验证流程，拒绝连接请求。</p>
<p>假如是自建证书的，则不使用第二步系统默认的验证方式，因为自建证书的根CA的数字签名未在操作系统的信任列表中。</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>love death robot：生命的意义</title>
    <url>/p/346f5a7f.html</url>
    <content><![CDATA[<p>关于爱、死亡和机器人的18集短片动画，内容就像大标题，简单纯粹，在短短 5～20min 描述一个故事，2D/3D 画面，有各具特色的画面，自由而紧凑。</p>
<h2 id="生存和死亡是最大驱动力"><a href="#生存和死亡是最大驱动力" class="headerlink" title="生存和死亡是最大驱动力"></a>生存和死亡是最大驱动力</h2><p>生死之外，并无大事，在第一集的《Sonnie’s Edge》，绚丽的画面、狂热的竞技场，在利欲纠缠下，暴力、财富、阴谋、技术、色欲等等手段不断展现，而最后存活的，是生命对生存的渴望和对死亡的恐惧。</p>
<h2 id="现实与虚幻"><a href="#现实与虚幻" class="headerlink" title="现实与虚幻"></a>现实与虚幻</h2><p>人是无法直接感知世界，只能通过五感来接收信息从而形成对世界的视界，而五感的信号是可以模拟的，所以人类的感知到的世界不真实，甚至可能是假的！《Beyond the Aquila Rift》中男主角被困在时空中，同样在绝境中虫族营造了梦境来安抚人类，面对这样的世界，有谁能选择醒来呢？</p>
<p>类似的讨论可以看 空之境界·伽蓝之洞，相关的理论可以去了解康德的作品。</p>
<p>本集中的音乐 《Living in the Shadows》 非常契合主题，下面是部分歌词：</p>
<p>Smoke is clearing out</p>
<p>All the circling lights, blind me</p>
<p>I’ve been running out</p>
<p>Now it’s all just a fight, to breathe</p>
<p>I gave it all, yeah</p>
<p>I gave everything</p>
<p>I will never break the silence</p>
<p>When I look inside</p>
<p>I don’t have to hide</p>
<p>If you’re looking, you won’t find me</p>
<p>Who’s the enemy?</p>
<p>Don’t know what to believe</p>
<p>Living in the shadows</p>
<p>Living in the shadows</p>
<p>Light is breaking through a dark that is underneath</p>
<p>I know the truth but for you it’s just out of reach</p>
<p>You took it all, yeah</p>
<p>You took everything</p>
<h2 id="科学与魔法"><a href="#科学与魔法" class="headerlink" title="科学与魔法"></a>科学与魔法</h2><p>科学与魔法都是一种力量，让人类创造繁华的社会，也能让人迷失在其中，在《Good Hunting 》中，男主角代表人类的成长，幼年随父亲驱妖，成年后在大都市学习机械工艺，见证了魔法的衰落和科学的发展，而女主角代表自然，从自在的狐妖到失去化形的能力，只能依靠人类的皮相买卖生存，在被强行改造成机械人体后，凭借男主角的科学机械技术再次化作狐型，完成一个循环。</p>
<p>地球的自然环境和人类的关系不也是这样吗？人类从敬畏环境到改造环境，但肆意浪费和污染让地球以巨大的自然灾害回报人类，也是一个循环。</p>
<h2 id="异类"><a href="#异类" class="headerlink" title="异类"></a>异类</h2><p>人群中的异类，同样给人恐惧感。</p>
<p>在《Shape-Shifters 》中，军队中的改造狼人冲锋陷阵、流血流汗，但与众不同总是让其他人无法接受，如同克苏鲁神话的本质：无知的恐惧。</p>
<h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><p>为了生命的延续，我们可以付出怎样的代价？在《Helping Hand 》中给了现实而残酷的演示，现在很多作品都宣扬团结、信念、感情，这一集则在冷冰冰的太空中展示了另一个答案：代价。</p>
<h2 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h2><p>自我探索是哲学追求的真理之一，生命的意义是什么？自我是什么？活着的意义？哲人到现在还没一个统一的概念。</p>
<p>在《Zima Blue 》中，生命的意义通过 Zima 数百年的探索，通过人、大地、海洋、天空直到星空，回归自我，回归到最开始的平静。</p>
<h2 id="牺牲"><a href="#牺牲" class="headerlink" title="牺牲"></a>牺牲</h2><p>战争中的生死残酷而现实，快到没时间感伤和恐惧，《Secret War 》前期的压抑到最后绝命坚守的高潮节奏都非常得当，最后在悠悠琴声中结束。</p>
]]></content>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS推送</title>
    <url>/p/b552076e.html</url>
    <content><![CDATA[<p>从 iOS 10 新增的 UserNotifications Framework 可以发现，Apple 整合了原有散乱的 API，并且增加了许多强大的功能。以 Apple 官方的角度来看，也必然是相当重视推送服务对 App 的影响、以及对 Apple iOS 生态圈长远发展的影响。</p>
<a id="more"></a>

<h2 id="准备篇"><a href="#准备篇" class="headerlink" title="准备篇"></a>准备篇</h2><h3 id="Tip-1：推送通知（Push-Notification）必须购买-Apple-开发者账号，并使用特定的推送证书"><a href="#Tip-1：推送通知（Push-Notification）必须购买-Apple-开发者账号，并使用特定的推送证书" class="headerlink" title="Tip 1：推送通知（Push Notification）必须购买 Apple 开发者账号，并使用特定的推送证书"></a>Tip 1：推送通知（Push Notification）必须购买 Apple 开发者账号，并使用特定的推送证书</h3><p>使用免费帐号不能推送。<br>那如果我们使用的是第三方推送服务（以下简称第三方）呢？比如「极光推送」。也必须购买开发者帐号。因为所有的第三方都会将推送请求发至 APNs（Apple Push Notification service 苹果推送通知服务），所有推送均是由 APNs 下发。<br>如何注册及正确的配置证书，参考这里 iOS 证书设置指南。<br>原理篇</p>
<h3 id="Tip-2：推送通知本身是-iOS-系统的行为，所以在-App-没有运行（没有在前台也没有在后台）的时候："><a href="#Tip-2：推送通知本身是-iOS-系统的行为，所以在-App-没有运行（没有在前台也没有在后台）的时候：" class="headerlink" title="Tip 2：推送通知本身是 iOS 系统的行为，所以在 App 没有运行（没有在前台也没有在后台）的时候："></a>Tip 2：推送通知本身是 iOS 系统的行为，所以在 App 没有运行（没有在前台也没有在后台）的时候：</h3><p>仍然能够推送及接收（通知中心通知、顶部横幅、刷新 App 右上角的小圆点即 badge [以下简称角标] 等都会由系统来控制和展示）。</p>
<p>收到推送时，是无法在 App 的代码中获取到通知内容的。因为沙盒机制，此时 App 的任何代码都不可能被执行。</p>
<h3 id="Tip-3：手机向-APNs-注册推送服务"><a href="#Tip-3：手机向-APNs-注册推送服务" class="headerlink" title="Tip 3：手机向 APNs 注册推送服务"></a>Tip 3：手机向 APNs 注册推送服务</h3><p>在代码中注册推送服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef __IPHONE_8_0 </span><br><span class="line">if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)])&#123;     </span><br><span class="line">	UIUserNotificationSettings *settings &#x3D; [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge| UIUserNotificationTypeSound|UIUserNotificationTypeAlert categories:nil];     </span><br><span class="line">	[[UIApplication sharedApplication] registerUserNotificationSettings:settings]; </span><br><span class="line">	&#125; else &#123;     </span><br><span class="line">	UIRemoteNotificationType myTypes &#x3D; UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];</span><br><span class="line">	&#125; #else     </span><br><span class="line">	UIRemoteNotificationType myTypes &#x3D; UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes]; </span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>

<p>在第一次触发这段代码的时候，会有一个系统弹窗，询问你是否允许该 App 要给你推送信息。当你选择允许时，系统会打包 App+手机唯一标识+证书 信息发送至 APNs 服务器注册推送服务，APNs 系统会对该手机安装的该 App 是否有推送权限进行验证，所以必须要加入了 Apple Deveice 的手机，使用对应 App 的推送证书才能够成功的注册。</p>
<p>如果注册成功，则可以在 AppDelegate.m 的如下方法中获取到 deviceToken，它是对 该手机+该App 组合的一个唯一标识，当使用远程推送时，只需将推送消息发给指定的 deviceToken 即可使推送信息传达给指定手机的指定 App 上。因此如果你使用第三方，就需要在这个方法里将 deviceToken 传给第三方。（在 iOS 9 为了更好的保护用户隐私，会出现多次重复删除/安装 App 导致 deviceToken 不断变化的情况。有时会出现一条推送手机会收到 2 次的问题，属于 iOS 9 系统问题）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;       </span><br><span class="line"> &#x2F;&#x2F;将 deviceToken 传给极光推送 </span><br><span class="line">	[JPUSHService registerDeviceToken:deviceToken];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以上步骤均成功，此时你能够取到第三方提供的设备注册 id。能否取到该 id 值，可以作为判断设备是否能够成功推送的标准（见 Tip 6 – Registration ID）。因为当你取到该值时必然：</p>
<ul>
<li>推送证书配置正确（你拥有了推送权限）。</li>
<li>设备成功在 APNs 注册并返回了 deviceToken（APNs 能识别你的设备了）。</li>
<li>返回 的 deviceToken 传给第三方，成功在第三方生成了唯一标识注册 id（第三方能将你的设备信息传给 APNs 了）。</li>
<li>综上，注册及接收推送必须使用真机，必须连网。</li>
</ul>
<h3 id="Tip-4：推送通知从-服务端-–-gt-App-代码-的过程"><a href="#Tip-4：推送通知从-服务端-–-gt-App-代码-的过程" class="headerlink" title="Tip 4：推送通知从 服务端 –&gt; App 代码 的过程"></a>Tip 4：推送通知从 服务端 –&gt; App 代码 的过程</h3><p>使用你们公司或第三方的服务端向 APNs 发送推送请求（请参考苹果 APNs 相关资料，或者第三方推送提供了更简单的 REST API）。</p>
<ul>
<li>APNs 接收并验证推送请求。</li>
<li>APNs 找到设备下发推送。</li>
<li>手机收到推送通知，系统根据 App 状态进行处理：</li>
<li>前台收到：<ul>
<li>系统会将通知内容传到 didReceiveRemoteNotification</li>
</ul>
</li>
<li>后台收到：<ul>
<li>如果开启了 Remote Notification ，系统将推送传到 didReceiveRemoteNotification:fetchCompletionHandler:，否则此时代码中收不到推送。</li>
<li>展示横幅、通知中心、声音、角标。</li>
</ul>
</li>
<li>退出收到：<ul>
<li>如果点击推送横幅/通知中心而启动 App，系统将通知传到 didFinishLaunchingWithOptions。</li>
<li>展示横幅、通知中心、声音、角标。</li>
</ul>
</li>
</ul>
<h2 id="推送通知内容篇"><a href="#推送通知内容篇" class="headerlink" title="推送通知内容篇"></a>推送通知内容篇</h2><h3 id="Tip-5：推送通知分为-本地-远程-2-种类型："><a href="#Tip-5：推送通知分为-本地-远程-2-种类型：" class="headerlink" title="Tip 5：推送通知分为 本地/远程 2 种类型："></a>Tip 5：推送通知分为 本地/远程 2 种类型：</h3><p>本地通知，可指定推送时间，在该时间准时弹出推送通知。<br>远程推送通知，分为 普通推送/后台推送/静默推送 3 种类型。存在延迟问题（由于 Tip 1 第 2 点，APNs 的不稳定及高峰时段的巨量请求所致）。</p>
<h3 id="普通推送"><a href="#普通推送" class="headerlink" title="普通推送"></a>普通推送</h3><p>就是我们在手机上平时见到的推送通知。</p>
<p>包含声音、横幅、角标、自定义字段。</p>
<h4 id="App-："><a href="#App-：" class="headerlink" title="App ："></a>App ：</h4><ul>
<li>处于前台，不会展示横幅，可通过 didReceiveRemoteNotification（iOS 7 before）didReceiveRemoteNotification:fetchCompletionHandler:（iOS 7 after）获取通知内容（前台展示横幅的方法看这里）。</li>
<li>处于后台，会展示横幅，无法获取通知内容。</li>
<li>处于退出，会展示横幅，无法获取通知内容。</li>
<li>点击图标启动，无法获取通知内容。</li>
<li>点击通知横幅启动，在 didFinishLaunchingWithOptions 获取通知内容。</li>
</ul>
<p>通知内容类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; “_j_msgid” &#x3D; 200806057; &#x2F;&#x2F; 第三方附带的 id，用于统计点击 aps &#x3D; &#123; alert &#x3D; “显示内容”; badge &#x3D; 1; &#x2F;&#x2F; App 角标，可推送 n、+n、-n 来实现角标的固定、增加、减少 sound &#x3D; default; &#x2F;&#x2F; 推送声音，默认系统三全音，如需使用自己的声音，需要将声音文件拖拽&amp;拷贝至 Xcode 工程目录任意位置，并在推送时指定其文件名 &#125;; key1 &#x3D; value1; &#x2F;&#x2F; 自定义字段，可设置多组，用于处理内部逻辑 key2 &#x3D; value2;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后台推送"><a href="#后台推送" class="headerlink" title="后台推送"></a>后台推送</h3><ul>
<li>各种显示效果跟普通推送完全一样。</li>
<li>必须携带 “content-available” = 1;</li>
<li>必须携带 alert、badge、sound 中 至少 1 个字段。</li>
<li>仅 iOS 7 以后支持。</li>
<li>必须在 Xcode 工程中 TARGETS – Capabilities – Background Modes – Remote notifications 开启该功能，具体可参照 iOS 7 Background Remote Notification。</li>
</ul>
<h4 id="App："><a href="#App：" class="headerlink" title="App："></a>App：</h4><ul>
<li>处于前台，可通过didReceiveRemoteNotification（iOS 7 before）didReceiveRemoteNotification:fetchCompletionHandler:（iOS 7 after） 获取通知内容。</li>
<li>处于后台，可通过 didReceiveRemoteNotification:fetchCompletion Handler: 获取通知内容 // 获取情况中与普通推送的唯一不同点，此时 iOS 系统允许开发者在 App 处于后台的情况下，执行一些代码，大概提供几分钟的时间，可以用来偷偷的刷新 UI、切换页面、下载更新包等等操作。</li>
<li>处于退出，无法获取通知内容。</li>
<li>点击图标启动，无法获取通知内容。</li>
<li>点击推送横幅启动，在 didFinishLaunchingWithOptions 获取通知内容。</li>
</ul>
<p>通知内容类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; “_j_msgid” &#x3D; 2090737306; aps &#x3D; &#123; alert &#x3D; “显示内容”; badge &#x3D; 1; “content-available” &#x3D; 1; &#x2F;&#x2F; 必带字段 sound &#x3D; default; &#125;; key1 &#x3D; value1;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静默推送"><a href="#静默推送" class="headerlink" title="静默推送"></a>静默推送</h3><ul>
<li>没有任何展示效果。</li>
<li>必须携带 “content-available” = 1;，因此静默必然是后台的。</li>
<li>必须不携带 alert、badge、sound。</li>
<li>可携带自定义字段。</li>
</ul>
<p>App ：</p>
<ul>
<li>处于前台，可通过didReceiveRemoteNotification（iOS 7 before）didReceiveRemoteNotification:fetchCompletionHandler:（iOS 7 after） 获取通知内容。</li>
<li>处于后台，可通过 didReceiveRemoteNotification:fetchCompletion Handler: 获取通知内容 //获取情况中与普通推送的唯一不同点，此时 iOS 系统允许开发者在 App 处于后台的情况下，执行一些代码，大概提供几分钟的时间，可以用来偷偷的刷新 UI、切换页面、下载更新包等等操作。</li>
<li>处于退出，无法获取通知内容。</li>
</ul>
<p>通知内容类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">	 &quot;_j_msgid&quot; &#x3D; 3938587719;</span><br><span class="line">	 aps &#x3D;     &#123;        </span><br><span class="line">	 	alert &#x3D; &quot;&quot;;        </span><br><span class="line">	 	&quot;content-available&quot; &#x3D; 1;  &#x2F;&#x2F; 必带字段    </span><br><span class="line">	 	&#125;;    </span><br><span class="line">	 key1 &#x3D; value1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推送目标篇"><a href="#推送目标篇" class="headerlink" title="推送目标篇"></a>推送目标篇</h2><p>别名、标签、Registration ID 均是第三方提供的用于更方便地指定推送目标的功能。</p>
<h3 id="Tip-6：推送根据目标的不同可分为："><a href="#Tip-6：推送根据目标的不同可分为：" class="headerlink" title="Tip 6：推送根据目标的不同可分为："></a>Tip 6：推送根据目标的不同可分为：</h3><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><ul>
<li>无差别发送给所有用户。</li>
<li>别名 alias 推送</li>
<li>第三方提供的功能</li>
<li>一个手机的一款 App 只能设置一个 alias（可修改）。</li>
<li>建议对每一个用户都取不同的别名，以此来确定唯一的用户（也可多个用户取 1 个别名）。</li>
<li>推送时可指定多个 alias 来下发同一内容。</li>
<li>仅指定 alias 的用户能够收到推送。</li>
</ul>
<h3 id="标签-tag-推送"><a href="#标签-tag-推送" class="headerlink" title="标签 tag 推送"></a>标签 tag 推送</h3><p>第三方提供的功能。</p>
<ul>
<li>可设置多个、可增加、清空。</li>
<li>用于指定多样的属性，如 『1000』+『daily』+『discount』 可用于表示月消费超过 1k、喜欢购买日用品、偏好折扣商品的用户。</li>
<li>如果要删除，需要在上次设置时，将设置的 tags 保存至 NSUserDefaults，本次剔除不需要的 tag 后，再重新设置。</li>
<li>推送时可指定多个 tag 来下发同一内容。</li>
<li>手机如果设置了推送指定的多个 tag 中任一个tag，都能够收到推送消息。* Registration ID 推送</li>
</ul>
<p>在 Tip 3 的第 3 步时将 deviceToken 提供给第三方之后，其服务器会自动生成的指向该手机的唯一 id。</p>
<ul>
<li>可在推送时指定多个 id 来下发消息。</li>
<li>可用于对核心用户、旗舰用户的精准推送。</li>
</ul>
<h2 id="应用内消息篇"><a href="#应用内消息篇" class="headerlink" title="应用内消息篇"></a>应用内消息篇</h2><h3 id="Tip-7：应用内消息（以下简称消息-）和推送通知的区别，消息："><a href="#Tip-7：应用内消息（以下简称消息-）和推送通知的区别，消息：" class="headerlink" title="Tip 7：应用内消息（以下简称消息 ）和推送通知的区别，消息："></a>Tip 7：应用内消息（以下简称消息 ）和推送通知的区别，消息：</h3><ul>
<li>不需要 Apple 推送证书。</li>
<li>由第三方的服务器下发，而不是 APNs。</li>
<li>相比通知，更快速，几乎没有延迟，可用于 IM 消息的即时送达。</li>
<li>能够长时间保留离线消息，可获取所有历史消息内容。</li>
<li>通过长连接技术下发消息，因此：</li>
<li>手机必须启动并与第三方服务器建立连接。</li>
<li>如果手机启动立刻切至后台，很可能连接没有建立。</li>
<li>手机必须处于前台才能收到消息。</li>
<li>手机从后台切回前台，会自动重新建立连接，并收到离线消息。</li>
<li>没有任何展示（横幅、通知中心、角标、声音），因此可以：</li>
<li>自定义字段实现 UI 效果。</li>
<li>完全在静默情况下处理 App 内部逻辑。</li>
<li>使用一些 App Store 审核不会通过的功能，在审核时关闭功能，上架后通过接收消息，开启相关功能。</li>
</ul>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>note:201812</title>
    <url>/p/f468f6cb.html</url>
    <content><![CDATA[<h2 id="慎重"><a href="#慎重" class="headerlink" title="慎重"></a>慎重</h2><p>做任何一件事情，可以这样逼问自己，知道自己想要的是什么，知道要放弃的是什么，知道要承担什么样的责任。也就是想清楚它的目标、代价和责任。</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>一个男人，可以因为才华娶你，也可以因为能力娶你，更可以因为人品娶你，唯独因为年轻娶你最可怕。因为你的才华可以随着时间的流逝更加出众，你的能力也可以随着时间的流逝更加出色，你的人品还是你可以主宰的东西，唯独年轻貌美，是必然消失，而且由不得你的。</p>
<h2 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h2><p>不把信息当作知识，不把收藏当作学习，不把阅读当作思考，不把储存当作掌握。<br>不提炼总结、不应用学习、不深入思考、不实践反馈，就不会变成自己的能力。</p>
<h2 id="遗忘与抛弃"><a href="#遗忘与抛弃" class="headerlink" title="遗忘与抛弃"></a>遗忘与抛弃</h2><p>不要轻易抛弃你所拥有的。因为遗失的东西可以寻回，而抛弃的东西一旦失去，就再也无法找回了。</p>
<h2 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h2><p>设想不用代价的完美，也同样是elpis一词的恶意所在。作为一个凡人，最无法回避的往往不是灾难，而是希望本身。这也许是一种讽刺，可有谁能说，这不是希望本身的真正含义所在？赋予一个理想的概念太过美好的意象，这本身就是一个错误。</p>
<h2 id="人生"><a href="#人生" class="headerlink" title="人生"></a>人生</h2><p>有些人耗费一生的时间才能够到达的地方，另一些人出生时就在那里。</p>
<h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>过去只是用来回忆，而不是用来沉溺的。我们迟早都会长大，不可能永远在一起。总有那么一天，我们都会离开。我们应该做的是牢记心中对彼此的记忆，而并非是将彼此留在过去，因为成长也不过是无数离别堆积的过程而已。这不会是过去的结束，而只会是未来的开始。</p>
<h2 id="长期而言，我们都将死去"><a href="#长期而言，我们都将死去" class="headerlink" title="长期而言，我们都将死去"></a>长期而言，我们都将死去</h2><p>如果意识本身是物质堆积的产物，那思维也应该是某种运算吧。那么，如果保留同样的信息，通过另一种途径呈现，是否就能够再演同样的意识呢？这是否也可以被视为一种转生呢？如果是的话，人类的意识和灵魂，又到底是什么呢？究竟怎么样才可以称为真实和实在的呢？</p>
<h2 id="答案和真相"><a href="#答案和真相" class="headerlink" title="答案和真相"></a>答案和真相</h2><p>想清楚，你要的是答案还是真相？</p>
<h2 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h2><p>一个人的孤独不是孤独，一个人找另一个人，一句话找另一句话，才是真正的孤独。</p>
<h2 id="进"><a href="#进" class="headerlink" title="进"></a>进</h2><p>宁可一思进，莫在一思停</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>note:20181204</title>
    <url>/p/c3fb7d7d.html</url>
    <content><![CDATA[<h2 id="闻道而行"><a href="#闻道而行" class="headerlink" title="闻道而行"></a>闻道而行</h2><p>子路有闻，未之能行，唯恐有闻</p>
<h2 id="管理和影响"><a href="#管理和影响" class="headerlink" title="管理和影响"></a>管理和影响</h2><p>你不可能掌握所有事情，所以去管理你能够掌握的事，让它不要脱离你的掌握；去影响你不能掌握的事，让它向你希望的方向发展。</p>
<h2 id="已知-未知"><a href="#已知-未知" class="headerlink" title="已知/未知"></a>已知/未知</h2><p>妨碍我们学习的不是未知的，而是已知的，尤其是那种略知一二的。</p>
<h2 id="喜欢"><a href="#喜欢" class="headerlink" title="喜欢"></a>喜欢</h2><p>那是极好，可是我不喜欢。</p>
<h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><p>沟通不是为了征服，而是为了幸福。</p>
<h2 id="善良"><a href="#善良" class="headerlink" title="善良"></a>善良</h2><p>没有善良是不行的，仅有善良是不够的。</p>
<h2 id="饭菜"><a href="#饭菜" class="headerlink" title="饭菜"></a>饭菜</h2><p>做菜的重要性，超越于吃。</p>
<h2 id="承认自己"><a href="#承认自己" class="headerlink" title="承认自己"></a>承认自己</h2><p>我们之所以会不安是因为我们有良心。为了摆脱不安，最简单的方法是承认自己的错误。</p>
<h2 id="长短"><a href="#长短" class="headerlink" title="长短"></a>长短</h2><p>与其想方设法弥补你的短处，不如千方百计发挥你的长处。历史上没有那个人是因为没有缺点而名垂青史的。</p>
<h2 id="家"><a href="#家" class="headerlink" title="家"></a>家</h2><p>整齐的那是宾馆，方便的才是家。</p>
<h2 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h2><p>自由是需要资本的，人的能力越大他越自由。</p>
<h2 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h2><p>父母和孩子之间融洽的家庭关系是对孩子最好的教育。</p>
<h2 id="英雄主义"><a href="#英雄主义" class="headerlink" title="英雄主义"></a>英雄主义</h2><p>世上只有一种英雄主义，那就是看清了这个世界但仍然爱它。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>note:201901</title>
    <url>/p/75b8fc07.html</url>
    <content><![CDATA[<h2 id="你不是别人"><a href="#你不是别人" class="headerlink" title="你不是别人"></a>你不是别人</h2><p>你怯懦地祈助的</p>
<p>别人的著作救不了你</p>
<p>你不是别人，此刻你正身处</p>
<p>自己的脚步编织起的迷宫的中心之地</p>
<p>耶稣或者苏格拉底</p>
<p>所经历的磨难救不了你</p>
<p>就连日暮时分在花园里圆寂的</p>
<p>佛法无边的悉达多也于你无益</p>
<p>你手写的文字，口出的言辞</p>
<p>都像尘埃一般一文不值</p>
<p>命运之神没有怜悯之心</p>
<p>上帝的长夜没有尽期</p>
<p>你的肉体只是时光，不停流逝的时光</p>
<p>你不过是每一个孤独的瞬息</p>
<h2 id="伟大"><a href="#伟大" class="headerlink" title="伟大"></a>伟大</h2><p>伟大的作品不只是靠力量完成，更是靠坚定不移的信念。</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>只要你能足够强大，跳出时间设置的陷阱，而且持续、长期地守住目标，你就能成为时间的朋友。这种行为模式，叫作“长期主义”。只有长期主义者，才能成为时间的朋友。普通人的努力，在长期主义的复利下，会积累成奇迹。时间帮助了他们，他们成为了时间的朋友。</p>
<h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><p>这个世界的天理不是知恩图报，而是一旦有了什么，就再也回不去了。</p>
<h2 id="痛苦"><a href="#痛苦" class="headerlink" title="痛苦"></a>痛苦</h2><p>当一个人背离他的本质时，许多痛苦都是因着这样的背叛而造成的</p>
<h2 id="遗忘"><a href="#遗忘" class="headerlink" title="遗忘"></a>遗忘</h2><p>Time is not your enemy. Forever is.</p>
<p>时间不是你的敌人，永恒才是。</p>
<p>Chaos isn’t a pit. Chaos is a ladder.</p>
<p>混乱不是深渊。混乱是阶梯。</p>
<h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><p>生活中我们需要无害的人，生意上我们需要有益的人。</p>
<h2 id="贫穷"><a href="#贫穷" class="headerlink" title="贫穷"></a>贫穷</h2><p>贫穷并非是没钱，而是欲望和钱的错位。</p>
<h2 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h2><p>经不起变老、变旧的东西，价值都令人怀疑。</p>
<h2 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h2><p>人们在绝境下毫无自由的选择，常会带给你前所未有的自由。</p>
<h2 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h2><p>需要借助他人来实现的自尊，是理智与情感的双重自我蒙蔽。</p>
<h2 id="智慧"><a href="#智慧" class="headerlink" title="智慧"></a>智慧</h2><p>假如某个方法能够让你快速获得某种智慧，那么这种方法所造成的全社会智慧贬值的危害，要远大于你所获得智慧的益处。</p>
<h2 id="赚钱"><a href="#赚钱" class="headerlink" title="赚钱"></a>赚钱</h2><p>赚钱=你的理性✖️别人的非理性</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>note:201911</title>
    <url>/p/6ca3cd46.html</url>
    <content><![CDATA[<h2 id="写作的自由和不自由"><a href="#写作的自由和不自由" class="headerlink" title="写作的自由和不自由"></a>写作的自由和不自由</h2><p>写作的限制带来自由,时间，话题，文体都是限制,但作家就是在限制中做到更好，作家的deadline，厨师的食材，赛车手的跑道，限制让我们更专注于能够做到的事情。</p>
<h2 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h2><p>在存在主义中，一个人类，存在只是因为存在而已，不因为有特意的意义或目的而出现。不像是锤子，出现先于其本质/目的，因其是有需要所以再造出。也就是，人类被迫去拥有绝对自由。即萨特提出的绝对自由观点。人类既然没有被强加的意义，所以一切行为都需要自己承担后果。</p>
<h2 id="金钱的最大好处"><a href="#金钱的最大好处" class="headerlink" title="金钱的最大好处"></a>金钱的最大好处</h2><p>贫穷剥夺人的自由，迫使人为金钱而工作，因为钱意味着生存。</p>
<p>金钱的最大好处是使人摆脱贫穷的逼迫，在金钱面前获得自由。</p>
<p>也就是说，不必为金钱而工作了，可以做自己真正喜欢做的事情了。</p>
<p>可是，倘若一个人只喜欢钱，有了钱仍然只为金钱而工作，怎么样呢？他更不自由了，在<br>金钱面前他永无解放之日了。</p>
<p>物质上的贫民，钱越少，越受金钱的奴役。</p>
<p>精神上的贫民，钱越多，越受金钱的奴役。</p>
<h2 id="What-is-the-cost-of-lies"><a href="#What-is-the-cost-of-lies" class="headerlink" title="What is the cost of lies?"></a>What is the cost of lies?</h2><p>It’s not that we will mistake them for the truth. The real danger is that if we hear enough lies, then we no longer recognize the truth at all.</p>
<p>What can we do then?</p>
<p>What else is left but to abandon even the hope of truth and content ourselves instead with stories? In those stories, it doesn’t matter who the heroes are. All we want to know is: who to blame?</p>
<h2 id="西西弗斯"><a href="#西西弗斯" class="headerlink" title="西西弗斯"></a>西西弗斯</h2><p>西西弗斯无声的全部快乐就在于：他的命运是属于他的。他的岩石是他的事情。同样，当荒谬的人深思他的痛苦时，他就使一切偶像哑然失声。荒谬的人知道，他是自己生活的主人。我把西西弗斯留在山脚下！我们总是看到他身上的重负。而西西弗斯告诉我们，最高的虔诚是否认诸神并且搬掉石头。他也认为自己是幸福的。这个从此没有主宰的世界对他来讲既不是荒漠，也不是沃土。这块巨石上的每一颗粒，这黑黝黝的高山上的每一矿砂唯有对西西弗斯才形成一个世界。他爬上山顶所要进行的斗争本身就足以使一个人心里感到充实 ——加缪</p>
<h2 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h2><p>性格的作用比智力大得多，头脑的作用不如心情，天资不如由判断力所节制着的自制、耐心和规律。开始在内心生活得更严肃的人，也会在外表上开始生活得更朴素。悔恨自己的错误，而且力求不再重蹈覆辙，这才是真正的悔悟。 —海明威</p>
<h2 id="一件事”做得好”比较好，还是”做得快”比较好？"><a href="#一件事”做得好”比较好，还是”做得快”比较好？" class="headerlink" title="一件事”做得好”比较好，还是”做得快”比较好？"></a>一件事”做得好”比较好，还是”做得快”比较好？</h2><p>鱼和熊掌不能得兼，你怎么选择：做得好，付出的代价可能是耗时长、成本高；做得快，意味着完成度低、不是精品。</p>
<p>我很赞同一篇文章的结论：做得快更好。</p>
<p>做得快不仅可以让你在单位时间内完成更多的工作，而且 因为你工作得很快，所以你会觉得成本低，从而倾向于做更多。</p>
<p>写一篇博客，你可能需要两天。这是很高的时间成本，你觉得太贵了，于是你很少写。但是，做好一件事的唯一方法，就是多做这件事。 做得越快，这件事的时间成本就越低，你会愿意做得更多。</p>
<p>人们总是倾向于，多消费时间成本低的东西。网站很快，就会多访问；搜索很快，就会多搜索；文章很容易读懂，就会多读几篇。做得快的核心，就是要让时间成本降下来，从而多做。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>python: 批量修改图片 md5</title>
    <url>/p/ce037494.html</url>
    <content><![CDATA[<h1 id="如何用脚本批量修改图片md5"><a href="#如何用脚本批量修改图片md5" class="headerlink" title="如何用脚本批量修改图片md5"></a>如何用脚本批量修改图片md5</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>文件 md5，本质是文件的体积大小，只要修改了文件的大小 md5 值就会发生变化；</p>
<p>由于图片格式影响，直接在图片后面插入数据是不影响图片的显示效果，所以可以编译图片，插入数据引起图片 md5 改变；</p>
<a id="more"></a>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source_path &#x3D; os.path.abspath(r&#39;&#x2F;Users&#x2F;xxx&#x2F;imageFile&#39;)</span><br><span class="line"></span><br><span class="line">if os.path.exists(source_path):</span><br><span class="line">    # root 所指的是当前正在遍历的这个文件夹的本身的地址</span><br><span class="line">    # dirs 是一个 list，内容是该文件夹中所有的目录的名字(不包括子目录)</span><br><span class="line">    # files 同样是 list, 内容是该文件夹中所有的文件(不包括子目录)</span><br><span class="line">    for root, dirs, files in os.walk(source_path):</span><br><span class="line">        for file in files:</span><br><span class="line">            src_file &#x3D; os.path.join(root, file)</span><br><span class="line">            # 限制只修改 png 文件</span><br><span class="line">            if &quot;.png&quot; in src_file:</span><br><span class="line">                writefile &#x3D; int(time.time() * 1000)</span><br><span class="line">                with open(src_file,&quot;a&quot;) as f:</span><br><span class="line">                    print(src_file)</span><br><span class="line">                    f.write(str(writefile))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&#39;md5 files finished!&#39;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>《Down By The Sally Gardens（爱尔兰画眉）》</title>
    <url>/p/da07bd5e.html</url>
    <content><![CDATA[<p>Down By The Sally Gardens 是美籍爱尔兰哨笛音乐家Joanie Madden的作品，蕴含温婉的爱尔兰肘风笛凄美的低诉，地道的奏鸣让你感受最朴素的音域，畅游自由无界限的想象国度，宛如站在高原的草地上呼吸饱含泥土气息的清新景致，耳边熏荤着与你细语的微风，那一霎那扬起的草絮飘然从手心滑落。</p>
<p>曲谱</p>
<p><img src="/imags/music_blue_DownByTheSallyGardens.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>一流的人读书，都在哪里划线？：学习的目的</title>
    <url>/p/b5336401.html</url>
    <content><![CDATA[<p>学习是有目的，探索未知，而不是停留在已知。</p>
<p>《一流的人读书，都在哪里划线？》虽然大多是在讨论商业畅销书，但其中关于学习的目的是探索未知的观点非常值得思考，书中在总结作者自己多年的商业书经营经验，对读书有相当独到的见解，讲述了如何读书、选书，并推荐了不少作者眼中的好作品。</p>
<a id="more"></a>
<h2 id="读书的目的"><a href="#读书的目的" class="headerlink" title="读书的目的"></a>读书的目的</h2><p>不该因为从书中获得自己已经知道了的东西而喜悦，而应该重视自己忽视了的、没意识到的、甚至不同意的观点与证据。</p>
<p>换言之，读书是为了从中学东西，而不是读完以后更加自我感觉良好。</p>
<p>我们在摄取信息时太容易选择已经认可的，它的问题是：如果这些信息是没问题的，那么你已经知道了，再巩固也没有多少益处；而如果这些信息有偏见的成分，那继续选择这些信息就是在加深偏见了。</p>
<p>因此作者认为在做读书笔记时，不该以做出全书内容梳理列表为目的，而应该主要记录自己学到了什么，注重的是自己阅读后的变化，要清楚自己的不足，通过阅读去补足。</p>
<h2 id="读书不必读完"><a href="#读书不必读完" class="headerlink" title="读书不必读完"></a>读书不必读完</h2><p>商业书只要看对自己有帮助的部分就可以了，没必要整本看完。可不需要照搬里面的说法，理解不同价值观的人的思维才是重点。</p>
<p>閱讀商業書就像在挖掘鑽石，只要挖到鑽石，其他砂石都不重要。</p>
<h2 id="读书不必追求速度和数量"><a href="#读书不必追求速度和数量" class="headerlink" title="读书不必追求速度和数量"></a>读书不必追求速度和数量</h2><p>读书时为了追求知识、认知、运用的提升，而不是为了积累阅读书目。</p>
<h2 id="阅读不完全等于学习"><a href="#阅读不完全等于学习" class="headerlink" title="阅读不完全等于学习"></a>阅读不完全等于学习</h2><p>阅读是提供一个契机，脱离实践和应用的阅读并没有改变什么。就像看了游泳教材不下水有什么用？</p>
<p>閱讀本身不會讓你獲得競爭優勢。閱讀只是一種「工具」或「契機」，讓你懂得發問，問出你的競爭優勢，並引發你的行為。我小時候讀了昆蟲圖鑑就跑去山裡抓蟲子，這個昆蟲男孩的競爭優勢在於「親眼見證實物」。把昆蟲圖鑑翻到爛，只是為了獲得親眼驗證所需的基礎知識。一定要親自接觸過昆蟲，才能長出智慧。</p>
<h2 id="求知欲"><a href="#求知欲" class="headerlink" title="求知欲"></a>求知欲</h2><p>人在向陌生的世界探索时总会感到恐惧，拿不出手的知识领域、艰涩的书籍都能让人停滞不前。然而想成为一流人物，就必须让探索世界的欲望和渴求胜过恐惧。</p>
<h2 id="知识和财富"><a href="#知识和财富" class="headerlink" title="知识和财富"></a>知识和财富</h2><p>钱财会被抢走或摧毁，但知识不会。而且知识不用交税。</p>
<h2 id="天才"><a href="#天才" class="headerlink" title="天才"></a>天才</h2><p>天才就是能够花很长时间做某件事的人。</p>
<h2 id="连锁阅读"><a href="#连锁阅读" class="headerlink" title="连锁阅读"></a>连锁阅读</h2><p>在书中提到的文章或书籍也是一种财富，可以扩展和佐证观点，构建知识体系。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>一人之下：异人</title>
    <url>/p/a9344f56.html</url>
    <content><![CDATA[<p><img src="imags/blog_yiren_cover.jpeg" alt=""></p>
<p>一人之下是一部给我三次惊喜的作品。第一，这是第一部成体系的融合传统中国宗教、武术和怪传的漫画作品；第二，人物塑造的有深度，性格和经历复杂而立体，不是脸谱化的善恶正邪，而是有欲望有追求的人；第三，剧情一流，在罗天大醮篇和临时工篇，我看到了丰富的设定被完美得嵌合剧情中，故事线还有明有暗，开头的小小悬念在最后来个大爆发让人叹为观止。</p>
<h2 id="异人"><a href="#异人" class="headerlink" title="异人"></a>异人</h2><p>比起一人之下，我更喜欢最开始名字：异人，在罗天大醮篇，揭开身怀绝技的异人世界，但“异”这个点还是在主角张楚岚身上，在剧情推动中，我们嘲笑他吊儿郎当的行为，惊叹神通施展时的神威，但剥离主角光环，作者让我们看到他10年来的隐忍和克制，展示他内心的冷峻和理性，暴露他在生死面前的不安和理智，显示他为在意的人做出的算计和牺牲，这个真面目，让一个 loser 翻身当主角的故事一下子变得合情合理，没有上天注定或命运安排，只是一个人内心的信念和意志足够强大而已。</p>
<h2 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h2><p>临时工篇，连在异人中都找不到同类的毒蛊陈朵更是“异”，一个命中带悲的人物，但对于她而言，她不在意自己的出身的悲剧，她在意自由，选择的自由、爱的自由、死亡的自由，这种正常人无法理解的追求，最终死在自己的蛊毒中，但那安宁的笑容让人无法忘怀。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>中国人心里的苦 -《一句话顶一万句》</title>
    <url>/p/67d90507.html</url>
    <content><![CDATA[<p>转载：<a href="https://book.douban.com/review/5584795/" target="_blank" rel="noopener">https://book.douban.com/review/5584795/</a></p>
<p>作者：southstarj</p>
<p>刘震云53岁了，在公共场合里总是穿着一件对襟的黑色夹袄，说是妈妈亲手做的，这让他看起来很像个乡下来的手艺人。刘震云写小说已经写了30多年，故乡延津的老乡们不觉得当作家是个多荣耀的事儿，就是个靠编瞎话为生的说书人。所以他也不觉得写作是件多么高尚的事情，他最讨厌的就是所谓的知识分子那种俯瞰苍生的态度，他觉得与其跟这些人在一起凑个饭局，说些言不由衷的大话，到不如跟村里的舅舅，表哥们聊天更有意思，更有收益。他经常回自己的老家老庄村。老家的父老乡亲，那些卖豆腐、剃头、杀猪、贩驴的，他能跟他们说到一起。他们说的话更接近生活的本质，更知心，“一句顶一万句”。</p>
<p>刘震云的外祖母生前给刘震云讲了一个故事，“她有一个叔叔，一辈子没娶上老婆，跟家里的一头牛成了好朋友。有一天这头牛死了，叔叔三天没有说话。第四天凌晨，他离家出走了。后来，四乡八镇都找了，所有的井也打捞了，不见叔叔的身影。”这个故事让刘震云很震惊，是什么原因让一个这样的一个普通的养牛人离开自己的故乡和亲人，要去到领一个陌生的地方？因为一头牛的死掉，自己熟悉的地方已经变得陌生，所以只能去一个更陌生的地方去寻找一种新的生活。在刘震云开来，这就是精神上却都在“高级”流浪和漂泊。不要说精神的痛苦只有知识分子才有。</p>
<p>怀着这样的一个想法，刘震云用了三年时间，写下了新的长篇小说《一句顶一万句》，书中的话是两个主人公，这两个主人公，一个叫杨百顺，一个叫牛爱国，他们是在心里杀过人的“杀人犯”，一个人特别想找到另一个人。找他的目的非常简单，就是想告诉他一句知心的话。</p>
<p>“一个人的孤独不是孤独，一个人找另一个人，一句话找另一句话，才是真正的孤独。”小说中塑造了很多世间的百姓，卖豆腐的，剃头的，杀猪的，贩驴的，染布的，开饭铺的，还有提刀上路杀人的……每个人都在寻找一个可以说上知心话的朋友，一个人找另外一个知心朋友不容易，你可能跟这个人是好朋友，但是你们在一块的话未必能说得上话，其实比人找人不容易的是话找话，《一句顶一万句》反映了一种中国式的孤独和友情观。</p>
<p>“《论语》的第一句话就是：有朋自远方来，不亦乐乎？《一句顶一万句》的孤独就是对这句话的注解。”文学评论家李敬泽说，“不同于西方文学作品中人与世界的对抗产生的孤独不同，杨百顺他们的孤独又是另外一种孤独，杨百顺的问题是他总觉得这个世界上应该有那么一句话，应该有那么一个道理，他说不出来，他等着到茫茫人海中去找希望有个人能够说出来，能够找到，但是他找不到。他的孤独是他手里没攥着那么一个他自己绝对信的那么一句话。他想找那么一句话，这种不确定性，构成了一种更大的孤独。”</p>
<p>什么才是朋友?《一句顶一万句》里朋友的关系充满了不确定性，因为一句话，一件小事，知心的人可以瞬间一刀两断，就像刘震云说说：“朋友的关系是危险的。”生活的细节决定了生活的偶然，在刘震云看来,正是细节中的人和事，才构成了小说中所有命运的跌宕转折，因为中国人永远都是活在细节里的，而细节会变的，细节变了，生活变了，朋友也就变了，于是小说中的人物，不得不接受这种命运的变化，去另外一个更陌生的地方寻找新的生活。</p>
<p>“寻找”是《一句顶一万句》的母体，写作对于刘震云来讲也是一个寻找知心朋友的过程。他说不是自己创作了这些人物，是这些人物跟他出来谈话。他在《一地鸡毛》中找到了小林，在《手机》中找到了严守一，在《我叫刘跃进》中找到了刘跃进，这次在《一句顶一万句》中找到了杨百顺和牛爱国，还有传教的老詹，杀猪的老曾，剃头的老裴……。就是这些小人物，却都是刘震云真正可以说知心话的朋友。“与书中人物结伴而行，晓行夜宿，披肝沥胆，说的都是知心话”，他找的人越来越深，与这些人谈的话题也越来越深，《一句顶一万句》谈到了杀人，绿帽子，和孤独的事，这些话是凶险的，只能跟知心的人说，与杨百顺和牛爱国说这些话，刘震云也会被自己突然写出来的句子吓一跳，“知心话绝对不是滔滔不绝的，所以书里的句子很短，句号很多，没有形容词，朋友在一起谈知心话的时候那些形容和比喻是没用的。朋友在一起说的都是朴素的话，真实的话，和知心的话，这三种话是有力量的，所以我觉得我自己写的比原来好。”</p>
<p>有了这样的写作，刘振云就不再孤独。他说摆脱孤独是他写作的动机原因和目的，在书里交了朋友就也不孤单。在他不写做的时候反倒累了，总是感觉没着没落，“不知道自己从哪里来到哪里去我是谁了”，“写作的每一天都很愉快，不写作的间隙却很沮丧，就像喝酒一样，有酒喝喝醉的时候很愉快，第二天醒了就很难过”，所以刘震云说自己的最佳状态，就是像李白一样“但愿长醉不愿醒”，但他是要醉在写作里的。</p>
<p>“我肯定是个好作者，因为我写作不累”。刘振云说，“写作这个不是祖传的，我外祖父的爹曾经开创过一个村庄，叫老庄村。他逃荒逃到一片盐碱地，就靠熬盐、熬碱为生。我觉得他是个智慧的人，一个新创的村庄叫老庄，显得深，因为新，确实也有点虚张声势和作贼心虚的感觉，出门就吆喝，老庄的盐来了，老庄的碱来了，人家说老哥，怎么没听说过这个村啊？他说“有点远！”远来的和尚会念经，于是老庄的盐碱也就形成了品牌，周围村庄吃的都是老刘家的碱和盐。”</p>
<p>“我外祖父的爹真是个聪明人，这聪明背后，是河南人面对生活的态度。经常有人说我是幽默的，这个幽默不是话语的幽默，真正上升到文学的层面，话语的幽默会让人讨厌的，我的幽默是事情本身的幽默，也不是事情本身幽默，是事后边的这里理很拧把，明明看着不行的事情，大家都要去做，不做到成了不对的，这就变成了幽默。我们面对艰辛和苦难的时候，幽默会把铁像冰一样融化掉，如果说祖传，我的幽默的出产地也是我外祖父的爹开创的那个老庄村的盐碱地里，这个地点是祖传的。在苦难的地方长出幽默的大树，会更幽默。”刘震云说。</p>
<p>读这本书本打算放松一下，可读的过程中，心里越来越抓挠，苦涩得很。</p>
<p>书里的故事很简单，就像邻居的大爷和你闲扯，讲讲村里其他人的事情似的。可一页页翻下去，故事又不简单，刘震云说到的这些人：卖豆腐的、贩驴的、杀猪的、剃头的……这些似乎毫不相干的人的命运，却莫名其妙地交织在一起。无论是几十年前的爷爷辈儿，还是80年代的新中国，人们的生活变了，可人的内心却没有变。写到最后，这些人之间的关系，无非是分成“说得上话”和“说不上话”两种。书里的每一个人，都为了和别人“说不上话”苦了一辈子。</p>
<p>读这本书之前，本来以为这种苦只有我们这一代年轻人才有。大学寝室里，四个人各自开着电脑做着各自的事情，一晚上互相之间一句话不说，这似乎已经成为常态；曾经一起吃饭聊天吹牛逼的高中同学，进了大学就没怎么再说过话；也同样因为说不上话，身边的一对对分分合合……看了小说才知道，原来从两千年前中国人就都因为这个原因心里苦着。这种苦不是别的，就是孤独。</p>
<p>中国人喜欢热闹，是因为一大帮人闹哄哄的时候可以暂时忘了孤独，可当又不得不自己一个人的时候，又要觉得孤独了。书里面牛爱国陷入困境的时候曾经琢磨过：这世上的人有千千万，可能去投奔的却只有两三个。平日里和老婆说不上话，已经觉得孤独了，遇到走投无路的情况，就更加觉得孤苦无依，只好去千里之外找曾经“说的上话”的战友。可有的时候，离家已经千里之外，却还是“心里乱”，只好走得更远。孔子两千年前就曰过：“有朋自远方来，不亦乐乎？”，我们都以为是老朋友从大老远的地方赶来，心里很开心。可书里老汪说得好：你们都不明白孔老夫子的心思。从远方来的这个人，是不是朋友还两说着呢，反倒是因为和自己没什么关系，才能放心地把心里话说给他听。心里话说了，就舒坦了。</p>
<p>我们又何尝不是这样呢，和熟人说话，有些心里话得掂量着说；但和网上的陌生人聊天，反正谁也不认识谁，反倒是什么心里话都讲了。校内网出来了，微博实名制了，又把熟人圈子强行拉到了网上，于是大家说话，又开始掂量了。可话憋着总是难受，于是大家就发些不疼不痒的自拍和水贴，脑子费在了这些琐碎事上，也就暂时忘却了孤独感。这和喜欢热闹没什么本质区别，晚上躺在床上，汹涌的孤独感还是压得人喘不过气来。又有人发明了“微信”，晚上睡觉也能“摇”。可难免有人无法接受这种欺骗自己的做法，要么让自己不停忙碌从而忘记，否则只好独自承受。</p>
<p>可这心里的苦究竟是为了什么，书里没有给出明确的回答，但是我们也许可以从老詹的身上看到些什么。老詹是在延津传了一辈子天主教的意大利人，举手投足已经和中国的老头没什么区别。他这一辈子只在延津发展了八个教徒，但是他却从来没有放弃过传教。或许那八个教徒都不够虔诚，但是老詹绝对是从心底信了主。临死的时候也把自己设计的教堂草图放在身边。即便全延津的人，带上新乡天主教会的人都不待见他，但他仍然相信他能和主说上话。</p>
<p>中国人没有信仰不是什么新鲜话题了，当然，我们不用改，这就是我们的本性。西方人信神，我们信的是人。我们无法摆脱人际关系对我们的影响，家庭、朋友、领导、圈子……只要在中国生活，躲也躲不掉。神是有定性的，可人是没有定性的。甚至可能因为一句话，朋友变成了仇人；或是几十年后突然遇到，曾经的仇人变成了朋友。在中国人这里，朋友不一定说得上话，说得上话的不一定是朋友，就这么乱七八糟的，都在壳的外边。壳的里边，永远是一颗孤独的心。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>乡下人的悲歌：阶级</title>
    <url>/p/82bd4b03.html</url>
    <content><![CDATA[<p>《乡下人的悲歌》并不是励志传记，它是一曲忧伤的老歌，轻轻地流淌，唱给自己，唱给亲人，唱给过去的岁月。</p>
<p>本作描述了作者成长过程中，家人、亲戚、友邻长期地与生活作斗争，与贫穷、酗酒、暴力、愚昧、毒品对抗，时而淹没，时而沉浮。</p>
<h2 id="乡下人"><a href="#乡下人" class="headerlink" title="乡下人"></a>乡下人</h2><p>作者的祖父母一辈二战之后从肯塔基州迁至俄亥俄州的一个工业城市，经济上成为典型的中产阶级，但从来没有真正地脱离家暴、酗酒、拒绝学习和怨天尤人的文化与习惯。</p>
<p>作者的外祖父母，成天争吵不休。外祖父酗酒，外祖母性格刚烈，差点烧了不听劝告的酗酒丈夫。作者的母亲成长在这样的环境中，人虽聪明，却早早染上毒瘾，从此挣扎在迷幻的现实中，换了一任有一任的丈夫。<br>J.D.并非从小就有奋斗意识的有志青年，直到高中都还是经常逃学的学渣，他在社会上混过一段时间，后来参加了海军陆战队，随着阅历的开阔他才升起了求学之心，耶鲁大学以其开放性的教育思维和独特的选材眼光同意了他的入学申请，并以高额奖学金帮助了这位普通的贫困学生。</p>
<p>美国经济的发达实际上掩盖了底层白人在个人责任方面的缺失。在美国这样稳定的发达社会，实际上个人只要做到四点就能活得不错：一、不做伤害身体的事情，比如熬夜、吸毒、酗酒、吸烟等；二、不离婚，或至少不生孩子后不离婚；三、好好上学，学一门手艺；四、工作有收入后不乱花钱，有所储蓄。然而，这些底层白人就是连这些都做不到。</p>
<h2 id="恶性循环"><a href="#恶性循环" class="headerlink" title="恶性循环"></a>恶性循环</h2><p>本地工业公司的解体，直接减少了好的工作机会，有能力的家庭搬迁到更繁华的都市，让优秀劳动力减少，消费水平下降让稳定的企业和工作都进一步减少。</p>
<p>在作者家乡，小孩大都在读完高中前就早婚早育，不理智的婚姻又导致高离婚率，家庭不稳定的情况下小孩也难以培养成才。</p>
<p>淳朴的家族亲情关系，追求荣誉、生活随性洒脱，但排外、粗鲁、暴力、生活无计划让一切深陷泥潭。<br>不只是个人品性，整个集体在美国社会中不可避免地堕落，是无法看到其它新生活的无奈，是没有选择出路的绝望。</p>
<h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><p>J.D.万斯是这个城市移民家族的第三代，他的亲人们用了几十年的时间缩窄了文化的鸿沟，最终借助教育达到了身份的跃升。它是一种必然性和偶然性的完美统一。</p>
<p>万斯平凡又不平凡，平凡是因为有他这样身世的人太多了；而不平凡则正是因为像他这样出生在泥沼里的人，爬出来的太少了，而且是越来越少。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>人类不过是没毛猴子：裸猿-裸猿三部曲</title>
    <url>/p/38285210.html</url>
    <content><![CDATA[<h1 id="人类不过是没毛猴子：裸猿-裸猿三部曲"><a href="#人类不过是没毛猴子：裸猿-裸猿三部曲" class="headerlink" title="人类不过是没毛猴子：裸猿-裸猿三部曲"></a>人类不过是没毛猴子：裸猿-裸猿三部曲</h1><p>《裸猿》(The Naked Ape: A Zoologist’s Study of the Human Animal) 是英国科学家德斯蒙德·莫利斯（Desmond Morris）在1967年所写的一本探讨人类行为的科学著作。</p>
<p>在书里，他把人类当作一种物种，亦即“裸猿”来看待。透过把“裸猿”与其他品种的动物比较，来讨论人类的种种行为。本书认为：人类的大多数独特行为都是因为生活所需而演化出来的，为要应付狩猎收集者生活的挑战。</p>
<p><strong>注意：作为20世纪70年代的一本科普读物，与现在的科普概念不同，其中有大量概念时没有正式的，是通过一定的观察后总结、联系出来的观点。</strong></p>
<a id="more"></a>

<p>把人类作为作为动物来观察是一种独特的观点，在裸猿的观察中，成长、家庭、配偶、性行为的特征被赋予不同的解释。</p>
<h2 id="部分文章片段："><a href="#部分文章片段：" class="headerlink" title="部分文章片段："></a>部分文章片段：</h2><p>１因为类人猿是群体狩猎的。为了避免为了异性而争斗。必须实行配偶制。保证每个男性性生活的权利。</p>
<p>２因为需要使用复杂的狩猎工具。大脑的发育延长导致儿童期的增长。所以父母需要养育子女，这就构成了家庭的概念。</p>
<p>３对婴儿儿童来说父母的情感纽带非常重要，长大了里开父母之后。为了填补这个真空期，本能的寻找配偶，填补自己这个情感纽带的空白。</p>
<p>４为了形成牢固的配偶关系，人必须要有恋爱的能力。之后，用付出和求爱获得爱情，用激情的性生活维持爱情。缺一不可。</p>
<p>５女性的发展出来的性高潮是对自身没有了发情期的补偿。不然女人就都不愿意做爱那可麻烦了。并且性高潮可以强化配偶关系并且有利于对精液的吸收。</p>
<p>６为了稳定配偶制，必须防止婚外性。配偶之间分开的时候。为了抑制性冲动，不能够刺激别人和被别人刺激。所以需要对有性和性的象征的部位遮羞。这是衣服最早的意义。</p>
<p>７女性发展出来的嘴唇和胸部分别是对自己阴唇和臀部的性象征。、</p>
<p>８处女膜的产生源于儿童期的延长。</p>
<p>９女性遮羞是为了抑制性冲动。可矛盾的地方是，女性又要尽量使自己性感来减少别人的厌恶。</p>
<p>10探索促进了裸猿的进化</p>
<p>11我们总是试图将自己模仿父母一辈而来的习惯和价值观，同某种高尚的道德联系在一起。</p>
<p>12故作的微笑是无法被婴儿理解的。</p>
<p>13所谓兴趣就是以较少的精力获取较大的调查。</p>
<p>14对三岁前的婴儿没有溺爱的概念。父母在这个时期需要给他们足够多的爱。这样他们在儿童期才有足够旺盛的精力去探索。在这个阶段赔了培养独立能力，父母则必须减少自己的爱。</p>
<p>15如果儿童在早期缺失安全感，然而到了自立阶段又很活跃，那么他会有很多朋友但很难长久和深交；如果儿童在早期非常安稳并且在自立阶段也被过分的保护，那么他就会交由困难，努力联系旧友。</p>
<p>16语言的功能。传递信息，表达情感，艺术探索（诗歌之类的），社交整饰（一些礼节的废话）。</p>
<p>17人是机会主义的，要不断的为了食物探索。人之所以是恒温动物，是因为保持生理的活动效率。</p>
<p>18人的本性是和蔼和互助的。但是部落文明之后的城市化文明瓦解了这些原始本性。所必人需要有道德、法律来维护这些自然行为。</p>
<p>19人类发展出风俗的意义就是保持社群内部的团结。</p>
<p>20个人的创新和群体的凝聚力是有冲突的。部落文明中的凝聚力是非常强大的压抑了人的创新能力，然而城市文明的凝聚力笑了很多，人的创新了被激发出来。现在文明的大爆炸很大程度上有赖于此。</p>
<p>21现代人的性行为总共有十种功能。生育；结偶；维护配偶关系；满足生理需要；探索功能（就是找刺激，这是把双刃剑对家庭稳定又好又坏）；自偿功能(内心的满足）；解闷；镇静（消除紧张、挫败感）；商业功能（性工作者）；地位展示功能。</p>
<p>22所谓性的地位展示。就是在性中表现支配和征服。阴茎就是进攻、力量、地位的象征。竖中指是典型的阴茎象征主义。在现代社会之中。当权者很少，受压制着很多。长期的地位压抑必会带来性的地位展示。通过嫖妓、看脱衣舞、强奸、露阴癖、黄色笑话满足。这些都是人对自己性功能和地位的焦虑。</p>
<p>23都市环境中的矛盾是，他要求比人的生物学上的生长期更长的见习期。也就是说十四五岁生理上应该去独立的人，在社会中仍然不需要也很难独立。它干扰了这年龄本该有的不稳定结偶关系。因为不经过这个过渡期，就不会有形成认真恋爱关系能力的成熟期。也就是说。十四五的人在生理上应该多和异性接触（包括性交），这样才有利于之后成熟期的自己经得起诱惑而忠于家庭。</p>
<p>24人是机会主义者。本来就是要不断从环境中获得大量刺激的。如果一直静静得坐着晒太阳，放松悠闲，那反而会少活几年。现代社会分工精细，大多人的工作单调乏味，所以人必须要自己找刺激。有时人们又会在不断刺激之后总产生了一种幻灭感（空虚），觉得为自己找刺激而作的事情没有意义。</p>
<p>25因为找刺激的过程总伴随这一种幻灭感。所以人更愿意用别的方式找刺激。于是有了传播谣言的行为，也有了看书看电影的行为。这样可以替代者体验刺激。这样投入精力小。不过幻灭感还是会在。</p>
<p>26从生物学上来说，恋爱分为十二个接触过程。眼睛对身体；眼睛对眼睛；语言交流；手拉手；手搭肩；手挽腰；接吻；抚摸头部；抚摸身体；亲吻乳房；抚摸生殖器；性交。</p>
<p>27按照十二个阶段发展出来的性爱才会有真正高峰的体验。</p>
<p>28冲生物学角度来说。正常的夫妻性交。加上性前戏和性交本身的时间通常也就30分钟。</p>
<p>29城市文明的一个矛盾。人的亲密程度取决于人之间的信赖程度。然而城市中我们不能信任陌生人所以要尽量拉开距离。可是都市生活节奏让人容易紧张，我们越是被迫拉开距离就越是需要身体接触。</p>
<p>30虽然城市文明中有种种弊端，但是我们无法回到也没人愿意回到过去的原始。唯一的诀窍就是，让我们利用这个复杂的社会而不是让它来利用我们。我们已经被迫要主动寻找刺激的生活（就是人生的意义之类的）。我们最好是挑选有报偿的生活态度，纵情于积极的探索和创造，把科学精神赋予优先地位。</p>
<p>31婴儿生来在子宫就伴随着温暖拥抱和心跳节奏伸张。所以温暖，拥抱和感受节奏，可以让人心理恢复平静。</p>
<p>32母亲一般都是用左边的乳房喂婴儿。因为左边婴儿可以感受到心跳从而平静下来。</p>
<p>33微笑的意义就是现代文明中两人对相互拥抱的一种确认，那事一种象征性拥抱。</p>
<p>34亲密关系总是这样的顺序：先是抱紧我，再是放下我，最后是别关我。母子之间的亲密关系就是这样。</p>
<p>35恋人配偶之间为了一直保持亲密关系，需要不断通过性行为和共同养育子女的行为保持着童年期的（报警我）亲密关系。当然社会风气也会在另一方面来保障。</p>
<p>36第二春的科学依据是，中年人一旦坠入情网，会从生理机能上恢复年青的活力。</p>
<p>37红色的肌肤代表着欲火旺盛，所以穿红色相对性感些。</p>
<p>38现代社会中，人在离开父母之后，大多不能很快有配偶。所以人需要替代性的亲密行为。当然，理想的社会中是不需要替代性亲密行为的。但相比而言与亲密关系的替代品亲密总比没有亲密接触好。</p>
<p>39人离不开亲密接触，没有它人难以对付生存压力。（说明：亲密接触和性是相互独立的）我们会寻求所有的替代的亲密行为。一种得不到就退而求其次和下一种去亲密。一是亲爱的人；二是专业服务人（推拿按摩的人或性工作者）；三是宠物；四是物品；五是自己。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>什么能改变一个人的本质？ -- 异域镇魂曲</title>
    <url>/p/5386f8e6.html</url>
    <content><![CDATA[<p>异域镇魂曲，黑岛工作室独立制作的第一款“龙与地下城“类型的游戏，同时用最艰涩、受众最少的“异度风景”（Planescape）来作为游戏背景，推出后引起市场的剧烈响应，有人奉为神作，有人觉得莫名其妙，在大多数游戏评测平台获得极高评价的同时，游戏的销量极其不佳，与其说是游戏，更像一部小说、一个故事，关于诡异、迷幻和艰难。</p>
<a id="more"></a>

<h2 id="异度风景"><a href="#异度风景" class="headerlink" title="异度风景"></a>异度风景</h2><p>首先，“异度风景”的背景是哲学的、理论的世界，将世界分成了三大部分：主物质位面、内层位面和外层位面。主物质位面就是平时游戏中常见的世界；内层位面包括火、空气、水、土和正负能量这些元素所在地；外层位面是精神和信仰的投影，是神与恶魔的居住地，在这里信念即力量。多宇宙模型存在着三大定律：多元宇宙中心说，指多元宇宙无边无际故无中心，但反过来也可以说任何一个地方都是中心；万物归环，指不论地理还是哲学上的一切事物都是一个起始循环，终点总会回到起点；万事皆三，指一切事物总有3种可能，或者3种形态等等。相关的设定非常丰富</p>
<h2 id="迷失的自我-诞生"><a href="#迷失的自我-诞生" class="headerlink" title="迷失的自我 - 诞生"></a>迷失的自我 - 诞生</h2><p>无名氏，这就是游戏的主角，在某个教派组织的停尸间里以一种“诈尸”的方式醒来，不但浑身伤痕累累，还失去了所有记忆，面目丑陋可憎，身边只有一个漂浮在半空中不停唧唧歪歪的骷髅头。这一幕开场有一点新意，但谈不上脱俗。不过很快我们就会发现这款游戏的一个别致之处：主角是不死的！</p>
<p>这个没有名字的“无名氏”，每死一次都会复活，但都会丢失掉一部分记忆，在无数个轮回里无数次死亡，他就丧失了全部记忆。即便某一个轮回寻回了全部记忆，一死便又残缺不全了。这怎么看都是一个无解的循环。在这种坑爹的现实面前，主角获得了漂浮的骷髅头和其他朋友的指引，开始寻找死循环的原因，真相也一点点面前展开。</p>
<p>这种死亡是游戏中一环的设定让我想起“魂”系列，不过异域镇魂曲更多是关注叙事而不是游戏难度，不过它那不友好的游戏操作还是让玩家很难接受吧。</p>
<h2 id="自我的探索-成长"><a href="#自我的探索-成长" class="headerlink" title="自我的探索 - 成长"></a>自我的探索 - 成长</h2><p>自我，该如何去定义呢？在时间的长流中，我们应该怎么定义自己？无名氏，一个失去所有记忆的不死人，一块在流水中飘荡的腐木该怎么认知他自己呢？</p>
<p>随着游戏进行，无名氏可以找到很多“队友”加入，有背负着民族和宗教的苦难的苦修士，狂野单纯、活力又自卑的混血盗贼，失去智慧只剩嘴炮的骷髅头，追求火焰的力量最终化身火焰却失去一切的法师，美丽、安详、典雅、治愈的禁欲魅魔，信仰正义却以暴制暴的鬼铠甲，从逻辑中诞生出自我的机器人，还有一个痴心爱着你的幽灵，所有的队友就像主角一样，自我充斥了矛盾。</p>
<p>在旅途中，无名氏发现过去的自己留下的残骸，从中汲取过去回忆和力量时，真想和罪业也随之浮现，你夺取一个爱着你的女孩的生命，死后化作幽灵也不能解脱；是你利用苦修士的诺言让他成为你的奴隶；骷髅头的满口谎言是因为恐惧你对他的折磨；是你指引火焰法师追求力量走上非人的道路；混血盗贼的养父间接因你而死，但纯真善良的她却被你的强大所吸引；同行的那位睿智的魅魔在不知不觉中已经被你那不死的神秘经历所波动。。。</p>
<p>无名氏就像火焰，让人想去接近，同时又被烧成灰烬</p>
<h2 id="牢笼-自我"><a href="#牢笼-自我" class="headerlink" title="牢笼 - 自我"></a>牢笼 - 自我</h2><p>游戏中很多角色都被牢笼所困，主角困于自我混乱、苦修士困于民族的分裂、魅魔困于本能和理智的冲突、火焰法师困于力量、机器人困于逻辑与感情、哪怕神明“痛苦女士”也被困在印记城，每个自我都被困在某个牢笼中，有谁解脱？</p>
<h2 id="人的本质-变化"><a href="#人的本质-变化" class="headerlink" title="人的本质 - 变化"></a>人的本质 - 变化</h2><p>无名氏的永生并非没有代价，每次自我都会丢失一部分记忆，当记忆全部消失则会重新开始；更可怕的是每次死亡重生都会让三界中某个生灵失去生命，化作飘零的野鬼。在一次次死亡重生中，无名氏让自己和这个世界付出了巨大的代价，而这究竟是为了什么？</p>
<p>无名氏的每个分身都留存一些记忆的痕迹以便下一个分身不至于完全失忆—常见的方法就是将信息做成纹身刻在自己身上。他在时间长河里扮演了各种各样的角色：帝王、军人、伟大的法师或著名的游荡者。其中一个分身发现了挣脱噩梦的惟一方法：找回自己的凡人性。</p>
<p>长久以来，无名氏对于自己的过去都怀有无尽的悔恨，这些悔恨在诸界之外逐渐凝集形成了一个封闭独立的世界—悔恨要塞，他的凡人性就盘踞在这座要塞中，用防壁将自己重重包围，它已经形成了自己的理念，成为超凡之人，它不愿与无名氏再度融合，而是希望将他变成一个完全失忆的废人，这样自己就能够永远存在下去。</p>
<p>无名氏最终找到夜巫，一个极其强大、邪恶的女巫，是她让无名氏走上永生的折磨，而只有她能给出解脱的办法。</p>
<p>当无名氏的队伍找打夜巫时，她被神灵囚禁在荒芜之地多年，一个老朽、丑陋的老太婆，但很快就明白，外表只是幻影，她那不可思议的力量让她可以变换一些形态、穿梭异界空间，她不过是在这里等待，等待一个问题的答案：“什么能改变一个人的本质？”。</p>
<p>这是整个游戏的精髓，也是这款游戏超越“游戏”这个范畴的关键所在。游戏给出的选项很多，我选择的是“悔恨”，这是无名氏这个人物一直在承受的、也是整部游戏所探讨的；而实际上无论你选择哪一个答案都是可以的，因为这是你做出的选择，夜巫对你的爱也改变了她。</p>
<p>结束游戏的方式很多，最终你将进入悔恨要塞，面对痴情守候的戴娜拉，你可以选择欺骗她或告诉她当年你杀死她的真相，无论何种选择她都会将你传送进去，自己则了却夙愿、进入真实死亡等待你的到来。在黑暗中，你的队友皆被超凡人杀死，没有一个人为了生存而出卖你，当超凡人嘲笑他们的愚忠和渺小并质问你时，无名氏回答：</p>
<p>“许多东西会改变一个人的本质，无论是后悔、或爱，或复仇或害怕—你所相信的任何东西都可以改变一个人的本质……我曾见过信仰移动城市，使一个人脱离死亡，将邪恶女巫的心变得仁慈。这座要塞都是由信仰构筑的。信仰诅咒了一个女人，她的心紧系于希望，希望一个并不爱她的人能爱她。它曾经让一个人追求不朽，并且成功了。而且它让一个鬼魂以为它自己不只是我的一部分。</p>
<p>游戏终末，找回了凡人性、重为凡人之身的无名氏和队友一一道别，最后审判到来，他赎罪的战场便是投身必死的血腥战争，为秩序和平衡而战。无名氏义无反顾地握紧兵刃投入血色沙场，耳边响起夜巫的诘问:</p>
<blockquote>
<p>What can change the nature of a man?</p>
</blockquote>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>关于穿越异世界的不可选择性现象的思考</title>
    <url>/p/693fa31e.html</url>
    <content><![CDATA[<p>最近在整理阅读记录时发现前两年看了不少的穿越题材，归档后发现一个小现象，主角的穿越一般都是强制性的行为。如果是可选择的，那会怎么样呢？</p>
<p>试想一下，某天，一个自称无所不能的神秘存在邀请你来个有去无回的异世界旅行，希望仙侠？《将夜》了解一下；喜欢道法？徐公子胜治的《灵山》肯定对你胃口；你沉迷理工？《奥术神座》的世界欢迎你。喜欢机甲+魔法？《骑士魔法》可以满足你？想换个性别？《事象的宏图》、《谭雅战记》可以给你机会。不想做人了？《关于我转生成史莱姆的那些事》《OVERLORD》来试试。喜欢挑战高难度？《灰与幻想的格林姆迦尔》《从零开始的异世界生活》就适合你这种人。</p>
<p>但选择 YES 就代表放弃了过去的人生、否定了当前的自我，一个没有自我的人来当主角？</p>
<p>现实世界的’我’怎么办？异世界的’我’又该怎么定义？毕竟穿越只是现象的说明，实际操作可能是神打爆了你的头，然后在异世界选择了一个倒霉蛋修改了他的记忆，填充了你的记忆和认知。当’你’回复意识也只会发现自己‘穿越’这个事实而已。</p>
<p>考虑到这一系列的辩论很难圆过来，基本上穿越异世界的设定都是强制性的，切断过去联系，不再需要考虑过去的社会、环境、家庭和朋友，可以理解为继承了某种设定或记忆而已，现在还没看到有作品会讨论两个世界的自我定义问题。</p>
<blockquote>
<p>在虚幻的世界中寻找真实感的人一定脑袋有问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>俯澣风景:视界</title>
    <url>/p/445957ce.html</url>
    <content><![CDATA[<p><img src="imags/blog_kzjj_fkfj_cover.jpg" alt=""></p>
<a id="more"></a>

<h2 id="看见自由的囚徒"><a href="#看见自由的囚徒" class="headerlink" title="看见自由的囚徒"></a>看见自由的囚徒</h2><p>她自幼多病，而且是不治之症的脊髓钙化，年幼时期就已经失去了对下半身的控制，为了避免病情恶化，离开了最温暖快乐的学校，离开了温柔博学的老师，离开了体贴善良的同学们，进入了充斥着消毒水味道的冰冷医院。</p>
<p>纵有万贯家财也只能在医院中精心疗养等待自己全身失去知觉进而慢慢看着自己在最美好的年华时死去。直到她在走廊中遇到了他，那个对任何人都无比温柔善良的他，那个思维似乎不同于常人的他。他没有在意她是何种病症，他更在乎她的感受，因为他会在路过自己的独立病房时，带来一只生命旺盛的百合花，换走那只一周前被他留下的白百合。</p>
<p>他看到了她所看到的世界，他看到了她的痛苦，他看到了她的希望，他只是给与了自己力所能及的一朵花，但他也带走了她的希望。</p>
<p>一周复一周的期待，一周复一周的安心，她忽然不再失落，不再痛苦，不再害怕医院，而是一天一天计算着他到来的时间。。。不过她怎么会知道，他的朋友出院了，就不再需要前往医院的路上顺带稍一朵白百合了，他以为自己是个过客，却不经意间成为了她生命的希望。</p>
<h2 id="被灯火吸引的飞蛾"><a href="#被灯火吸引的飞蛾" class="headerlink" title="被灯火吸引的飞蛾"></a>被灯火吸引的飞蛾</h2><p>当你羡慕者别人衣食无忧的贵族生活之时，你并没有看到她所需经受的禁锢。<br>当你斤斤计较于眼前的得失而如草莽一样时，你就失去看到那个更加宏伟世界的机会。<br>当有人带你尝试到纸醉金迷的梦想生活之时，你那单薄如气泡一样的理智，你那耳边不断回响着的戒律都已经失去了对你的束缚力，你渴望着这么自由的新身份、新视角、新世界。<br>幽灵公主带着迷途的少女体验到了凌驾于万有引力的飞行之感，这不就是自己内心最渴望的自由吗，俯览世界的宏伟，发觉地面的人们如蚂蚁一样渺小，发觉自己曾经都只不过是渺小的存在，才发现，自己能够如同神一样俯览这片大地。这种坠落又飞翔着的感觉，已经完全攻克了理智与实感。当然，这片区域的时间已经扭曲，所以少女们并未看到自己早已坠落到了地面，而是在慢慢感受着自己这个缓慢的坠落过程，并以为自己在飞翔着。</p>
<h2 id="视界与世界"><a href="#视界与世界" class="headerlink" title="视界与世界"></a>视界与世界</h2><p>人类是通过感知来确定对世界的认知。</p>
<p>“俯澣风景究竟是怎样的感觉？眺望自所居住的世界时所感受到的冲动，也就是纵然本人有意抗拒，仍会突袭而来的暴力般的认知，俯瀚世界所带来的感情，那就是“遥远”，由高处俯视的风景很壮观，连毫不起眼的景色都会另人觉地美妙，不过，过于辽阔的世界会转变为与世界产生隔阂的诱因，认为居住的世界是“自己所看到的辽阔风景”，而非“自身能亲身体会的狭小空间”，这本是正确的，然而，无论如何都没有“自己就身处这个辽阔世界”的真实感，由此“基于认识的理性”与“基于经验的实感”相互摩擦，不久就有一方被磨损，导致意识的混乱，接着~所谓“视界”并非“眼球捕捉到的影像”而是“大脑所理解的影像”，我们的“常识”保护着我们的“视界”，人类无法离开自身的盒子继续生存。”</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>像外行一样思考，像专家一样实践 科研成功之道</title>
    <url>/p/74787f34.html</url>
    <content><![CDATA[<p>看似枯燥的科研工作中，有许多思想和方法值得我们去关注的，比如，要勇于舍弃固有的思想、最大程度地发挥构思能力、积极主动地与同行交流等。</p>
<a id="more"></a>
<p>我想成为一名科学家；</p>
<p>多少人的童年梦想是这样的？小时候，总是对科学家感到高大上，其实大部分的科学家一直都投入在科研工作中，实际的工作估计没有童年想的那么有趣。不过，估计大部分人对科研工作者的工作也不是那么了解，对于他们平常遇到的问题、解决问题的思考和方法也不甚了解，这次看到的这本说到让我微微窥到一角。</p>
<p>科研工作，很大一部分可以总结为创新与实现，本人也不是科研工作者，对具体工作方式和要求也不了解，不过对于科研工程中的思考和方法很感兴趣，本书对于科研中创新和实现总结为“像外行一样思考，像专家一样实践”，提倡科研中构思的天马行空，想法的幼稚天真，同时又要求跳出现有的成功，省略不必要的工作，深入情景中，用构思、智慧去解决问题，挺有意思的。</p>
<p>对于实际工作遇到的问题，也提供了一定的参考价值，如果哪天遇到难以解决的创造性问题，可以试试作者的方法。</p>
<p>作者本身作为教授对学习有比较深的感触，书中提到的不同领域交流、记忆力是创造力、规划能力的基础、对素质教育和填鸭式教育的讨论等也让人印象较深。</p>
<p>科学研究是一项严谨的工作，但也是一项非常有趣的工作。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>你为何讨厌自己</title>
    <url>/p/baf70031.html</url>
    <content><![CDATA[<p>我曾七次鄙视自己的灵魂</p>
<p>第一次，当它本可进取时，却故作谦卑；</p>
<p>第二次， 它杞人忧天，无病呻吟；</p>
<p>第三次，在困难和容易之间，它选择了容易；</p>
<p>第四次，它犯了错，却借由别人也会犯错来宽慰自己；</p>
<p>第五次， 她因为软弱而忍让，却声称为自己的坚韧；</p>
<p>第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；</p>
<p>第七次， 它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。</p>
<p>——卡里.纪伯伦</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>内观：探索自我</title>
    <url>/p/62c1debb.html</url>
    <content><![CDATA[<p>内观的意思是如实观察，也就是观察事物真正的面目：它是透过观察自身来净化身心的一个过程。开始的时候，借着观察自然的呼吸来提升专注力；等到觉知渐渐变得敏锐之后，接着就观察身和心不断在变化的特性，体验无常、苦以及无我的普遍性实相。这种经由直接的经验去了知实相的方式，就是净化的过程。</p>
<h2 id="行动的可贵"><a href="#行动的可贵" class="headerlink" title="行动的可贵"></a>行动的可贵</h2><p>开篇就探讨的单纯的思考没法改变生活的，只有行动起来才能过上想要的生活。</p>
<h2 id="苦与乐"><a href="#苦与乐" class="headerlink" title="苦与乐"></a>苦与乐</h2><p>对于生活中的痛苦与快乐，起源来自于自身对外在事物的“反应”，如果想控制生活中的七情六欲，那么必须回归自身，了解自己的初心，明白痛苦与快乐都是短暂的泡沫，放下贪念、嗔恨和痴心，实现知行合一。</p>
<h2 id="戒、定、慧"><a href="#戒、定、慧" class="headerlink" title="戒、定、慧"></a>戒、定、慧</h2><p>讨论了如何开始生活的平静和自在，从持戒、定心、修慧三方面讲述，持戒可以理解为不做错误的事情，定心是通过冥想等方式观察自身，让自我回归平静，不受思念干扰；在生活中保持正念，活在当下，专注而平静。修慧则是个人对生活中亲身的体验和领悟，主要有修行内观、理解无常、无我及苦、保持平等心</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>写作入门：《落花水面皆文章》</title>
    <url>/p/b4fba6de.html</url>
    <content><![CDATA[<blockquote>
<p>写作不是一件顶难的事情，找到方法，提笔就可作文。</p>
</blockquote>
<p>key: 写作、入门、生活</p>
<p>作者叶圣陶，原名叶绍钧，江苏苏州人，是教育家、作家、文学出版家，毕生致力于我国的教育文化事业发展。著有《落花水面皆文章——叶圣陶谈写作》《好读书而求甚解——叶圣陶谈阅读》《给青年的二十七堂文学课》等，与夏丏尊合著《七十二堂写作课》《文心》。</p>
<p>本书作为写作入门读物，探讨了写作的定义、当前教学上的部分错误方法、阅读和写作关系、写作的方法、评价写作好坏的方式等，如果读者也遇到提笔难言或写不出心中想法等问题，不妨一起体会下这部作品，也许能有解决的头绪。</p>
<a id="more"></a>

<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="写作是怎么回事"><a href="#写作是怎么回事" class="headerlink" title="写作是怎么回事"></a>写作是怎么回事</h3><p>开头就提出写作是极平常的事，不过是口头语言的书面话，可以看作写说，写下你想说的话，和平时说明没有太大的差别，不过是用笔来表达而已，目的都是为了更好得表达和传播自己的想法。</p>
<p>有时用写作来代替说话，是为了更好得表达自己的想法，写作能够有更多的思考空间，能够让表达得更深切、更准确、更生动。</p>
<p>同时点出写作是给人看的，作者要从读者的角度思考，首先自己要明确自己的想法、认认真真地记录下思绪、总结好自己经验，自己的作品要认真地负责。</p>
<h3 id="阅读是写作的基础。"><a href="#阅读是写作的基础。" class="headerlink" title="阅读是写作的基础。"></a>阅读是写作的基础。</h3><p>认真写作才有好作品，认真生活才能过上好生活。</p>
<h3 id="生活是写作的好材料"><a href="#生活是写作的好材料" class="headerlink" title="生活是写作的好材料"></a>生活是写作的好材料</h3><p>明白写作的定义后就能写出好文章了吗？作者表示好文章需要有好材料，好材料都在生活中；写作输出的是作者的经验记录，前期的积累来源于中生活的细心观察与分析，一切以实际生活出发。</p>
<p>同时，创作者应该诚实面对自己，自己都不相信、不知道的事情写作来第一个骗的就是自己，要挑能写的题目做，没看过几片鲁迅的文章就写周树人的深度分析能出什么好结果？</p>
<h2 id="怎么写作"><a href="#怎么写作" class="headerlink" title="怎么写作"></a>怎么写作</h2><p>本章主要讨论写作的实际方法，包括区分和锻炼记叙和叙事文，临摹和写生对写作的影响，白话文和文言文在写作中的正确使用、开头和结尾的写法、单句和排比句的使用等。</p>
<h3 id="好文章是改出来的"><a href="#好文章是改出来的" class="headerlink" title="好文章是改出来的"></a>好文章是改出来的</h3><p>好文章不是一口气写作来的，修改是文章不可缺少的一部分，作者讨论了文章修改的必要性，提出写完后的多念多想，不断优化。让文章更清晰、准备得把想法传达给读者。</p>
<h3 id="文字的“好”与“不好”"><a href="#文字的“好”与“不好”" class="headerlink" title="文字的“好”与“不好”"></a>文字的“好”与“不好”</h3><p>写文章要有所为，意思是文章要有主旨，要有想表达的意思，写完没有语病等错误可能只算写“通”，还需要最求写“好”，讨论比较了文章的“好”与“不好”，指出文章准确、鲜明、生动的“好”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要你能说话，你就能写作，不需要给自己太大的压力。</p>
<p>写作和说话一样，最重要的是立诚。</p>
<p>阅读是写作的基础，读的不只是书，还是生活，学的不止是写作，还是认真对待生活的态度。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>剑道：九型十三刀</title>
    <url>/p/9b0f50e8.html</url>
    <content><![CDATA[<p>九型十三刀又可被称之为九刀十三式。</p>
<p>此属于木刀的剑道基本技术训练法,双人对练型。</p>
<p>所谓的剑道的基础招式，应该称“剑道基本技” 基本罗列如下：</p>
<ul>
<li>一本技：Ippon waza（正击面 Shomen-uchi、击手 Kote-uchi、击胴 Do-uchi、刺击 Tsuki） 攻击型招式：Shikake waza</li>
<li>连续技（又称二三段技）：Nisandan waza</li>
<li>拂击技（又称扫击技）：Harai waza</li>
<li>退击技（又称引技）：Hiki waza 应对反应型招式：O-ji waza</li>
<li>拔击技：Nuki waza</li>
<li>擦击技：Suriage waza</li>
<li>出端技：Debana waza</li>
<li>返技：Kaeshi waza</li>
<li>打落技：Uchiotoshi waza</li>
</ul>
<a id="more"></a>

<h2 id="1-一本技"><a href="#1-一本技" class="headerlink" title="1. 一本技"></a>1. 一本技</h2><h3 id="正面"><a href="#正面" class="headerlink" title="正面"></a>正面</h3><p>双方以右脚以”送足”向前前进３步，进入”一刀一足的距离”之后，攻方在大声喊出”ＭＥＮ（面）”的同<br>时，打击守方的正面。</p>
<p>１、在踏出右脚的同时，双手高高举起剑，此时双肘应打开至能看到对方全身的程度，刀身要正。 并且，在举剑时，不要让剑尖的高度低于双拳的高度。</p>
<p>２、守方在给予攻方打击机会时，剑尖稍稍向右偏一点。</p>
<p>３、打击完毕后，攻方后退一步作出残心，然后再后退一步回到”一刀一足的距离”。</p>
<h3 id="小手"><a href="#小手" class="headerlink" title="小手"></a>小手</h3><p>从”一刀一足的距离”开始，攻方在大声喊出”ＫＯＴＥ（小手）”的同时，打击守方的小手。</p>
<p>１、打击小手前举剑时，双肘应打开至能看到到方右手小手的程度。</p>
<p>２、守方在给予攻方打击机会时，刀尖应稍稍抬高一点。</p>
<p>３、打击完毕后，攻方后退一步作出残心，然后再后退一步回到”一刀一足的距离”。</p>
<h3 id="胴（右胴）"><a href="#胴（右胴）" class="headerlink" title="胴（右胴）"></a>胴（右胴）</h3><p>从”一刀一足的距离”开始，攻方在大声喊出”ＤＯ（胴）”的同时，打击守方的右胴。</p>
<p>１、高高地举起剑后，双手从头顶滑下进行打击，注意刀身要正。同时，打击时身体在前进的同时要始终正对对手。</p>
<p>２、守方在给予攻方打击机会时，要抬起双臂。</p>
<p>３、打击完毕后，攻方后退一步作出残心，然后再后退一步回到”一刀一足的距离”。</p>
<h3 id="刺击"><a href="#刺击" class="headerlink" title="刺击"></a>刺击</h3><p>从”一刀一足的距离”开始，攻方在大声喊出”ＴＳＵＫＩ（刺击）”的同时，刺击守方的咽喉部位。</p>
<p>１、关于刺击技，初学阶段要尽量掌握基本技术，不要用手击打，而要以腰为中心使整个身体前进，刺击<br>对方的咽喉部，然后迅速收回手。</p>
<p>２、守方在给予攻方打击机会时，剑尖稍稍偏向右下，同时后退一步让对方刺击。</p>
<p>３、刺击完毕后，攻方后退一步作出残心，然后再后退一步回到原位。</p>
<p>同时守方配合攻方前进一步回到原位。</p>
<h2 id="2-连续技"><a href="#2-连续技" class="headerlink" title="2. 连续技"></a>2. 连续技</h2><h3 id="“小手→面”"><a href="#“小手→面”" class="headerlink" title="“小手→面”"></a>“小手→面”</h3><p>双方由右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、攻方右脚踏出一步的同时举起剑，打击守方的右手小手，守方后退时右?再踏出一步打击对方正面。</p>
<p>２、受击时，守方先将剑尖稍稍抬起使对方打击右手小手，然后左脚后退一步同时剑尖稍稍向右打开，使对方打击自己正面。</p>
<p>３、打击完毕后，攻方后退一步作出残心，然后再后退一步回到”一刀一足的距离”。之后，攻方后退一步，同时守方前进一步回到原位。</p>
<p>上述动作结束之后双方解除架式，从左脚开始以”步足”后退５小步回到立会的距离，恢复中段式。</p>
<h2 id="3-拂击技"><a href="#3-拂击技" class="headerlink" title="3. 拂击技"></a>3. 拂击技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、攻方右脚踏出一步，同时以木刀的表镐向上扫拂，破坏对方的架式后直接打击对方正面。</p>
<p>２、打击完毕后，攻方后退一步作出残心，然后再后退一步回到原位。扫击方式向上扫拂的动作在向上扫拂的同时向前进攻打击对手正面</p>
<p>上述动作结束之后双方解除架式，从左脚开始以”步足”后退５小步回到立会的距离，恢复中段式。</p>
<h2 id="4-退击技"><a href="#4-退击技" class="headerlink" title="4. 退击技"></a>4. 退击技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、攻方右脚踏出一步的同时打击守方正面，守方以表镐格挡，随后双方稍稍前进互相交锷，此时攻方将对方的刀锷向下压 。对此守方回抬刀锷将手抬起的时候，攻方乘机撤回左脚同时举剑,再撤回右脚同时打击对手的右胴。</p>
<p>２、打击完毕后，攻方后退一步作出残心，然后再后退一步回到原位。守方防御攻方正面打击的动作（侧面）交锷状态（侧面）压 下对手的刀锷，趁对方抬手之际收回脚同时打击对方右胴（侧面）上述动作结束之后?方解除架式，从左脚开始始以”步足”后退５小步回到立?的距离，恢复中段式。</p>
<h2 id="5-拔击技"><a href="#5-拔击技" class="headerlink" title="5. 拔击技"></a>5. 拔击技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、守方右脚踏出一步同时打击攻方正面。攻方右脚稍稍向右前方斜进同时举剑打击对方右胴，刀身要正。此时眼神应开始终注视视方。</p>
<p>２、守方打完面后停止动作，并保持打完面的姿势，攻方打完右胴后停止动作并保持打完胴的姿势。</p>
<p>３、打击完毕后双方正对对方同时后退一步，攻方作出残心。然后双方同时向左移动回到原位。</p>
<h2 id="6-擦击技"><a href="#6-擦击技" class="headerlink" title="6. 擦击技"></a>6. 擦击技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、守方右脚踏出一步同时打击攻方右手小手。攻方左脚后退一步同时用自己木刀的里镐向上擦击对方木刀的里镐，然后抓紧机会右脚踏出一步打击对方正面。</p>
<p>２、守方被擦击的小手打的剑尖自然地偏离对手体侧。</p>
<p>３、打击完毕后攻方作出残心，双方后退一步回到原位。</p>
<h2 id="7-出端技"><a href="#7-出端技" class="headerlink" title="7. 出端技"></a>7. 出端技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、 守方右脚略微向前迈出作出即将打击的样子，稍稍抬起剑尖”起刀”、此时攻方右脚踏出一步以小动作准确迅速地打击对方右手小手。</p>
<p>２、 ２、打击完毕后攻方后退一步作出残心，然后再后退一步。同时守方收回右脚回到原位。</p>
<h2 id="8-返技"><a href="#8-返技" class="headerlink" title="8. 返技"></a>8. 返技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、守方右脚踏出一步同时打击攻方正面。攻方右脚稍稍向右前方斜进，同时用木刀的表镐迎向对方的木刀，然后抓紧时机转动手腕，向右前方斜踏出的同时打击对手的右胴，刀身要正。此时眼神应始终注视对方。</p>
<p>２、守方打完面后停止动作，并保持打完面的姿势，攻方打完右胴后停止动作并保持打完胴的姿势。</p>
<p>3、打击完毕后攻方后退一步作出残心，然后再后退一步。然后双方同时向左移动回到原位。</p>
<h2 id="9-打落技"><a href="#9-打落技" class="headerlink" title="9. 打落技"></a>9. 打落技</h2><p>双方从右脚起以”步足”前进３步，进入”一刀一足的距离”后动作开始。</p>
<p>１、守方右脚踏出一步同时打击攻方右胴。攻方左脚稍向左斜后方移动，同?用自己木刀刀刃部分”物打”附近的部位向右斜下方打落对方的木刀，然后抓紧时机斟酌距离踏出右脚打击正面。</p>
<p>２、打击完毕后双方正对对方同时后退一步，攻方作出残心。然后双方同时向右移动回到原位</p>
]]></content>
      <tags>
        <tag>kendo</tag>
      </tags>
  </entry>
  <entry>
    <title>医生的修炼：不确定性</title>
    <url>/p/76c5c48.html</url>
    <content><![CDATA[<p>从外科医学生到住院医生总是要经历很多，像是第一次手术时，需要实践学习过的理论，手术刀的对象从标本变成活生生的人，内心有多少动摇和不安？到了医院后直接面临生死，从震撼到接受要经历多久？医生平时工作和生活的压抑有多少人了解？</p>
<p>《医生的修炼》作者本人就是一名战斗在一线的外科医生，本书记录了从学生、实习、正式从医等过程，让读者看到冰冷冷的白大褂后医生真实的经历。</p>
<h2 id="修炼"><a href="#修炼" class="headerlink" title="修炼"></a>修炼</h2><p>医学，从人类历史记录以来就一直发展的学科，毕竟所有人都会生病、受伤，到了现在，医学行业知识繁多并且有大量分支，再优秀的医生也只能精通某几个领域。同时，学医的要求也变得更高，技术知识的发展要求学生掌握更多的知识体系，加上医学本身对医生技术的极高的容错要求，也提高了医学的门槛，试想：你在报考医学前想成为救死扶伤的医生，但你可能得先解决有你身高那么厚的书籍资料，到了实操环节，血淋淋的人体组织是你要面对的一个问题，解决心理问题后，你要面对后面漫长的手术，每台手术都是对你能力、判断和体力的考验！</p>
<h2 id="不确定性"><a href="#不确定性" class="headerlink" title="不确定性"></a>不确定性</h2><p>只要从医的时间够长，总会遇到毫无头绪的病症，人体是如此复杂，而个人在这个系统出错时又是那么得无助，医生们在不断总结和尝试中解决了很多病症，但没有哪个医生敢保证知道精通的领域里所有病症的原理，这很无奈但这是现实。</p>
<p>每天，外科医生都要面对变化莫测的情况—-信息不充分，科学理论含糊不清，一个人的知识和能力永远不可能完美。即使是最简单的手术，医生也不可能向病人保证术后状态一定会比原来好。</p>
<h2 id="天赋与刚毅"><a href="#天赋与刚毅" class="headerlink" title="天赋与刚毅"></a>天赋与刚毅</h2><p>一般人也许常常认为，必须要有一双完美的手才能作外科医生，实际上天赋这种东西也是存在的，但医生们更欣赏苦干、实干的人 —- 细心、认真、努力，日日夜夜、经年累月地勤练同一套技术的人。</p>
<h2 id="完美"><a href="#完美" class="headerlink" title="完美"></a>完美</h2><p>医学界已经大量引入医疗机械化设备，毕竟电脑比人更接近“完美”。人容易受他人意见的影响，此外，看事情的角度、最近的经验、注意力的分散以及信息的传播方式都影响着医生的判断。一个好的电脑程序则不一样，它总是自动而平等地关注每一个因素。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>十七岁的悬崖 -- 《死人经》</title>
    <url>/p/cb922651.html</url>
    <content><![CDATA[<p>[转载]十七岁的悬崖——关于《死人经》三主角的解构与重筑</p>
<p>作者：浪的传人</p>
<p><a href="https://tieba.baidu.com/p/3078330714" target="_blank" rel="noopener">https://tieba.baidu.com/p/3078330714</a></p>
<p>对我来说，读过《死人经》，印象最深的画面莫过于第一卷结末处，顾慎为与霍允两人逃离金鹏堡的瞬间。列作人墙的金鹏杀手们整齐逼来，十七岁的少年扬头望望，然后自悬崖上纵身跃下，在红顶大鹏自天顶垂下的羽翼上面缓缓升起，就此离开改变他一生的地方。</p>
<p>　　上官如还是霍允，其实是个蛮没有意义的话题。死人经不是一部从头到脚充斥象征与隐喻的小说——当然也可以说是，取决于你愿不愿意去穿凿附会——如你所知，对于一部小说而言，可供穿凿附会是最美好的品质。那么我可以说，上官如代表顾慎为的过去——遥远的记忆、美好的憧憬和消逝的梦想；霍允代表顾慎为的现在——压抑的神经、伤痕累累的躯体，以及些许莫名其妙的遗憾，这些遗憾是指向上官如的。连接过去与现在之间的则是顾慎为本人。有时是一点期许——这是通向上官如的一端；有时是一点指望——这是通向霍允的一端。无论期许还是指望，这个人物都看不到未来。事实上没有人看得到未来。</p>
<p>　　上官如。这是汤姆叔叔式故事当中的人物。当然，这样说起来就像是某种刻板的套路与定式——显而易见，一种套路的生命力能够顽强持续两百年，就一定是有道理的。这种定式在老时代是桦木屋里的老黑奴，在新时代是办公室里的新白领，天平另一端则由白人少爷换成了霸道总裁——如你所见，这两者之间并无不同。所以你看，非洲的炎夏和腰缠草裙手执长矛的老酋长，桌凳摇摇晃晃的破烂酒吧和面目模糊的黑黢黢人群，皇宫上空高来高去的女飞贼和另一个因遥远而显得微微可爱的江湖……太阳底下并无新事，十一岁的上官如趴在十四岁的顾慎为肩膀上面听到的那些故事，和印第安先民们奔驰过的土地上、满脸褶子的老汤姆给小主人讲过的没有一个字不同，那些关于一个截然不同世界的日光和鲜血，有如同质一样流淌着，因其遥远而不再令人惊怖。然后这些故事撞在那座悬崖上面戛然而止，寂静的夜里，一个人背着另一个走在狭窄的石梁上，数着满天的星辰多如繁星，这样一幕本身定格成为日后会被不断提起的故事。</p>
<p>　　某种意义上，上官如就是过去的顾慎为。十四岁，十一岁——需要抱歉地说，顾慎为在他十一岁的时候，不会有上官如这样的决断、凶狠与万众瞩目的魅力——十四岁的时候仍然没有。所以对于另一条世界线上的小少爷顾慎为而言，十公子是他难以企及的模板，素未谋面的邻家孩子，但毫无疑问，那时的他是小心翼翼走在这条路上的。韦小宝与康熙的游戏扭打纯属天然，顾慎为与上官如的接近则是刻意而为。他当然会这样做。书中提过吧，顾慎为直到见过十公子后才真正开了窍，“我不知道怎样做一个好奴才，但我知道主人喜欢怎样的奴才”，灵光一现，有什么东西从天灵盖上喷薄而出，因为他看见上官如的同时就看见了自己，如果不是家破人亡被掳走为奴，他本该努力成为那样的人。从这个意义上讲，上官如不仅是他的过去，还是他的理想——很多时候这两样事情难以分开。</p>
<p>　　我小时候常喜欢回忆过去，长大后这种情绪才慢慢淡忘。中间的变化大概是从三五年前开始的，充分证明了走上社会这件事情是多么操蛋而又令人无从抗拒。起初，在横跨两栋楼房之间的消防梯上穿梭来去、为抄一点回家的近路而翻越两三座高墙是美好的，这就是说，曾经拥有自由、勇气、莽撞以及夜晚来临时啸叫回旋于整个城市楼群中间的风；那个时候我十一岁。后来，在隆冬雪后结冰的道路上纵车飞驰、在炎夏的操场上把皮球射入两辆自行车搭成的球门中间是美好的，这就是说，曾经拥有疯狂、精力、执着以及跑道边上为你加油呐喊的一群小姑娘；那个时候我十六岁。然后，在夕阳西下的操场上寻找某个身影、春天来临的时候在墙角的树荫下折断一根柳枝是美好的，这就是说，曾经拥有青涩、懵懂、未来以及晨起早读时穿越窗子和一叠成绩单的扑啦啦的风；那个时候我十九岁。再后来，在午夜的插线板、小台扇和啤酒瓶子中间看西班牙夺冠、平安夜莫名其妙收到冻得冷硬的苹果是美好的，这就是说，曾经拥有青春、理想、死党以及宿舍阳台上把巢筑在破纸箱里的一对白鸽；那个时候我二十三岁。最后，所有上述过程好像那种老式显像管电视突然断了电，化为一团模糊的白斑消失在一片雪花的正中央，这就是说，虽然如上所说，曾经几乎拥有过可供列举的一切，那些已经不够重要，或者不够可爱；这个时候我二十六岁，在读完一本题为《死人经》的小说后泛起一些不那么清晰的想法，迫切地要把它们诉诸笔端。我讲这些是为了证明，过去或曰回忆，往往同所谓理想是一码事，因你对它们的所有权和支配权而被任意创造和重铸，最后你就被这个天底下最庞大的骗局紧紧攫住，无力自拔。十几年前，十岁不到的我在两栋大楼之间的消防梯上面辗转腾挪时，决不会承认那一刻如上文描写般美好，事实上我的双手在颤抖，掌心在流汗，因为一旦失足落下，不管三楼或是五楼，都足够把我摔到屁滚尿流，说不定小命不保——这种感觉听起来熟悉，实际上很久没有过了。</p>
<p>　　所以对于顾慎为来说，上官如是类似回忆与理想糅合在一起的事物，但这些回忆和理想都因为曾经存在、与无法再现，而显得格外惹人厌憎。这是有关少年心事的小秘密，他不会讲给你听，没有任何人会讲给你听。这就是为什么有人说上官如像活在另一条故事线上——她简直是活在另一个平行时空里，带着男主角本该和期待实现的二三四五种可能性，一点点掰开揉碎给你看。任性，倔狠，率直，信任，圣母心……顾慎为必须被她吸引，因为那些全都是曾经在他面前展开的羊肠曲径。顾慎为也必须同她分道扬镳，因为彼时的顾慎为，是斩断了所有那些可能性后的产物，他成功避开了上官如出没的所有平行时空，坚定不移地选择了最后一个，不是因为荷女就在里面，而是他们殊途同归。</p>
<p>　　荷女，或者叫霍允，这样区分不见得有什么意义，因为她是顾慎为的现在，或者说她比顾慎为更加顾慎为，这两种说法之间也不见得有什么不同。就在那座命运的悬崖边上，红顶大鹏负着顾慎为飞向天空，荷女沿着曾经的敌人、今后的同伴们留下的钉痕落向大地，而上官如被他们轻易遗落在金鹏堡的回忆当中，从此不再和母亲说一句话——我以为这是不可思议的关于十七岁的喻示，赶在任何人发现这一点之前。往生崖前，升天入地，这是最重要的第一卷的结尾，是男主角对于少年时代的全部告别，是传说中他向读者最后一次露出微笑的地方，下一次出场将是三年之后，他将变为无笑无泪亦无惧的西域之主，雪山龙王，横扫所有胆敢横亘在他路上的敌人，然后失去全部向往爱的能力。三年后，十年后，十六年后——上一个以这样的笔法取得巨大成功的人是金庸，往往作者愿意这样宕开一笔的时候，就是他希望稍微偷一下懒的时候，唱一支温柔的摇篮曲，曲子一结束，读者一醒来，主角就变身，从眼角眉梢尽是稚气戾气的青涩剑客蜕变成名满天下的神雕侠，比巴拉巴拉仙小魔女更夸张。侠而不是大侠，这一切还要留待他第二次在千军万民的欢呼声中进入那座襄阳城，就此打通朝往五绝登基路上的最后一道障碍。对于顾慎为，金鹏堡就是他的襄阳城，他需要以第二次的进入彻底结束成人礼，进入而不是摧毁，所以他不需要亲手杀死仇人独步王，不需要毁弃承载他前半生最不堪记忆的石堡，因为成就不是否认，新生无需弑旧——然而在那之前，在归来之前，他首先需要离开。</p>
<p>　　顾慎为无法离开，因为红顶大鹏不会在那一瞬间出现在他的身下。或者他早已在上官雨时第一次暗算他的时候死去，因为不会这样巧，落崖人直直摔进大鹏鸟的巢穴。甚而至于他面朝青空，遥远地方有鹰唳滑过，耳畔风声劲急，他期待的奇迹并不见踪影，因为根本没有大鹏这样的神物存在于世，这东西存在这件事情的本身，就和外挂一样不对头。</p>
<p>　　那一年上官如十四岁，顾慎为十七岁，站在十七岁的悬崖边上，他决心要抛离成长为真正男人之前的一切过往——所以他将上官如抛在身后，那是他的过去。同时被丢弃的还有许许多多不切实际的指望与可能——那也是上官如，从此他再不会在梦中成为顾家大少，应酬唱和，承欢膝下，考进清华或者北大——最后一件是我十七岁时的指望，和顾慎为一样，我自悬崖跳下的时候，把它们随手扔得不见影踪，直到现在看来，那不见得有什么帮助。</p>
<p>　　往生崖畔，离别之前，顾慎为遭遇了有生以来最严厉的一场背叛，来自霍允——或者说，来自他自己，在我们的文章里，对于顾慎为和霍允这两个人并不作区分。实迷途其未远，觉今是而昨非，人们最熟悉的背叛者恰恰是自己，这本是理所当然的事情，年轻人经常在一早醒来后变成另外一个人，虽然这一般来说难以察觉。来自十七岁的背叛像一把锋快的剑，干净利落地将另一个顾慎为由他身体里斩了出去。这个顾慎为来自现在，他的身体里面同样没有了上官如的存在；他漂浮在虚空当中，眼看就要坠下去，难以生存，那么他的身体里面一定多出了什么沉浊的东西，令他重逾巨石——我猜那东西叫做信仰，信念，理想，或者其他任何乱七八糟的名字，十七岁，怀揣沉重信仰的少年，愚蠢，冲动，像喝下整瓶闷倒驴一样容易上头，于是他如同炸弹一样落下去，在遥远的山脚砸出轰鸣和巨大的火光——在一个没有红顶大鹏的正常世界里面，这就是顾慎为最后的结局。老实说，我不喜欢这样的结局，尽管相同的事情每时每刻都在发生——但或许正是因为每时每刻都在发生，我们才需要一点小说来提供不一样的场景，不然的话，这个世界未免太面目可憎。</p>
<p>　　所以，在那个命运的三岔路口，最终也只有一个人能够逃脱。这个人抛掉了光怪陆离的过去与不切实际的理想，背叛了写在印花纸笺上的诺言，挥刀斩飞了残留的一点点信仰，在十七岁的悬崖上，以最低的姿态匍匐而下，双手紧紧锁死粗不盈指的细小岩洞，每一次呼吸都伴随魂飞魄散的深重危机，那意味着从两栋楼房中间的消防梯上翻滚着坠下，然后靠轮椅与导尿管度过余生。他是顾慎为，是霍允，是荷女，是千万人——都一样的，那根本无关紧要。他抬起眼，望见那头红顶大鹏翼若垂天之云，抟扶摇而上九万里，背上有人单腿支拄，影在北溟，身至万里，朝发而夕返，然后望向他说：夏虫不可语冰，蟪蛄岂知春秋。</p>
<p>　　这样说的时候，那个人衣不沾尘。</p>
<p>　　嗯，这么看起来感觉就正常一点了。大鹏鸟出现在悬崖前的那一刻顾慎为完成了他的蜕变，从此长出一张标准的主角脸，我身带光环哟，走三关，举手投足间都是八奇领域，我知道你知道我知道你知道我知道你不知道——小说嘛，大家都是这么写的。而唯一逃脱的霍允，此时正匍匐尘埃，真正的顾慎为一退再退，最后退缩在她蜷起的身上，眼望向高远天空上那个光芒万丈的主角顾慎为，那原本是他的指望，想成为主角的指望。每个人都曾有过，可不是每个人都曾实现。</p>
<p>　　返回来说霍允。</p>
<p>　　双女主很难写，不仅是因为其中一个会不打招呼地变成女二，根本的问题出在大部分人写出来的故事根本没有女主——不要说女主了，有人连男主都不会写呢，不要苛求他们。我要夹带私货了，将夜里叶红鱼简直一万个好顶赞，没有抱上床真是太可惜了。顺便，我觉得一个角色能让读者产生“谁他妈要看主角啊快把XX叫出来”的念头，是对作者最美好的褒扬，以上。用这个标准比划一下的话，上官如某几个瞬间达到了，霍允始终像差着一口气，不大清楚差在哪里了。当然这也不重要。一个人物能达到怎样的高度是由情节推动的，从作者开始谋篇布局的时候就能看出很多人物最终能走到哪里，这种地方往往最考较功力。</p>
<p>　　所以，就不难理解为什么上官如和霍允拥有数量同样庞大且互相看不大对眼的粉丝——都写在人设里呢。上官如代表顾慎为的过去，象征某个因其消逝而被无限美化的世界，那个世界里的顾慎为十七岁，每天晚上洗凉水澡，冬天不穿秋裤，一顿饭吃两个半馒头，一口气跑五千米，百米十二秒五，立定摸高两米七，在床上像一部上足了发条的打桩机，在球场上不知疲倦地奔跑，晃过三个人射门，而球场边上……有一个纤细的身影开心地替他保管衣服和矿泉水，微笑着看他睥睨万物。</p>
<p>　　而另一个世界里，天色暗下来，操场上方的灯光渐次熄灭，顾慎为一个人坐在空荡荡的人工草皮上面，脱下球鞋，费力地控着灌进鞋帮的黑色胶粒。白花花的汗碱浮起在他消瘦的后背上，手指甲刮过去，刺拉拉地响。</p>
<p>　　我不是很清楚更喜欢上官如的都是什么人，因此只能尽自己的能力去揣想和描摹——但是说实话，如果上述第一个世界曾经存在，我也不会太喜欢第二个，除非我自己现在正是一部打桩机——可惜又不是。那即是说，虽然前一个世界里有高来高去、专盗皇宫物件的女飞贼和午夜时分升起在石梁上方的星辉，我还是可以将它们全部舍弃，并不是因为后一个世界里我不用在地铁里挤出一身臭汗，也不是因为后一个世界里我可以坐在三百平米的阳台上端着茶碗看夕阳慢慢掉下远处的小山，只是因为我就生活在后一个世界里，仅此而已。当我不发神经的时候，会觉得这比什么都重要。</p>
<p>　　霍允代表顾慎为的现在，大致就是这么个意思。相似的人生，相似的经历，相似的武功，战斗中互相倚为后背——我以为最后一条是个不尴不尬的暗示，关于人如何对待一个不那么完美的自己。顾慎为给出的答案是：你要发疯，我陪你；你跑丢了，我追你；你要砍我，给你砍——前提是不能当真砍死了。我要有这么一个女朋友，早二百年给她踹飞，省得三辈子内再见到——顾慎为就不能。但我既不佩服也不同情他，因为你总不可能早二百年把自己踹飞，早一刻钟都做不到。在草屋里面对坐编席，时刻提防着对面的女人突然一刀砍过来的时候，顾慎为大概就是这样的心情。这一点上我对他完全理解，很少人能够给自己打出十全十美的分数，但出于种种原因，首先还是得学会接受。比如我也想做一部那种两层楼高、长着一百万个齿轮的隧道掘进机，但是生活还是要继续，不可能某一天发癫去做手术——其实真的去做也不是不可以的事，不过这样一来就扯远了。</p>
<p>　　所以，就我个人而言，不发神经的时候，会更喜欢霍允一点；但是也有发神经的时候，这个时候就更喜欢上官如。大部分曾经历过前后两个世界的人想必也是这样的——我指的不是发神经。两个世界中间是一条名为不忿的细而敏感的线，有时这个世界用的力气大一些，这个时候顾慎为就会和上官如拉拉手，亲亲嘴，把灯关上做一些不害臊的事情；有时那个世界用的力气大一些，这个时候顾慎为就会在失忆的霍允身边一待六年，喂喂鸡，养养狗，然后看着它们慢慢老死，在花园的墓碑上面一笔一划镌刻下它们的名字。全部的不同不过是那段时光里的执着。如你所知，回忆过去这件事情并不总像字面上那么美好，我会为迟到忐忑，为作业烦恼，被从座位上轰起来回家拿习题册子，在路上被小腿那么高的京巴撵得满世界跑，之后连打了二十天的狂犬疫苗——可是看着顾慎为背着熟睡的上官如缓缓走在浸过脚趾的夜雾中，我就把它们全部忘掉啦。</p>
<p>　　故事的最后，上官如一个人笑着离开，去追寻儿时浪迹江湖的愿望，因为“没有我你也能过得很好”。霍允呢，和顾慎为一起，继续走在他们未知的路上，一辈子这样相爱相杀下去，可是“所有人都知道，他们不会结婚”。在这一个瞬间，作者脱出了所有可见不可见的束缚与隔膜，将一切交给早已写定的命运，对过去、现在与未来作了一次精准的切割。就在那座十七岁的悬崖上，猎猎风啸，苍鹰啼鸣，江天似海，白云如野，我们的主人公第一次学会了与一个不完美的自己永远生活下去，那是每个人穷极一生要去完成的任务，允生允死，谁都无法放弃。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>剑道：剑道型一本目至七本目详解</title>
    <url>/p/f2d25080.html</url>
    <content><![CDATA[<h2 id="第一式-面拔击面"><a href="#第一式-面拔击面" class="headerlink" title="第一式 面拔击面"></a>第一式 面拔击面</h2><p>打太刀（上位、攻方）双手左上段 – 仕太刀（下位、守方）双手右上段</p>
<p>一、 攻方举双手左上段，左脚向前。守方举双手右上段，右脚向前。</p>
<p>二、 双方同时向前三步，在正确的距离出现时，攻方迈出右脚击面。</p>
<p>三、 守方左足稍退促使身体自然向后，将双手拉至更后方，越过攻方的剑尖，迈出右足，以充份的气势打击正面。此时攻方因被守方躲避攻击，会因进击面落空而失去正常体势而前倾。</p>
<p>四、 守方压下剑尖，斩切攻方前额，在剑尖达至攻方眉间时，迈出左足，双手举剑呈左上段，表示残心。</p>
<p>五、 攻方回至下段，守方收回左足而双方同时回至中段。</p>
<h3 id="剑理的陈述：距离"><a href="#剑理的陈述：距离" class="headerlink" title="剑理的陈述：距离"></a>剑理的陈述：距离</h3><p>剑道形看的不是剑技，而著重在剑理。从剑道形第一式：上段对上段，就可以揣摩攻防的意涵。在第一式中，所表现的并非上段对打的技巧（わざ），而是揣测距离（间合）的方法。</p>
<p>一般在教导距离的掌控时，依据中段剑尖的交错位置，会有远、近，以及一足一刀之距离的分别。但是一但剑尖没有在中段交错时，反而会容易失去距离感。所以在第一式中，会因双方持起上段，而正确地揣摩上位攻方与下位守方间的距离。</p>
<p>此时上位的指导者攻方採左上段，而守方仅使用如中段举剑般的右上段姿势，是以守方可以以击面姿势，在动态间掌握正确的距离。且右上段具有接招的功能，这也是何以双方的上段架构有所不同的原因。所以，守方必须好好思考距离和情况，即使剑尖不交错也能抓到正确的距离。</p>
<p>如果守方能够确实掌握间距，当看准时机出剑时，便能够在最佳的位置击中攻方的前额。当攻方攻入时，守方退半步后以送足做出最大挥面距离，其剑尖刚好斩切攻方的额前，而攻方因为体态崩溃，身体前倾。此时，守方仅仅偏离攻方已失势的剑尖，并且产生「敌远我近」的巧妙间距。因此，剑道形第一式在剑理上主要陈述乃距离的奥妙。</p>
<h3 id="心法与意涵"><a href="#心法与意涵" class="headerlink" title="心法与意涵"></a>心法与意涵</h3><p>至于第一式的心法，乃架构于「断敌之命」，双方乃各执「正义」而战。不论这个正义是为了道德伦理，或是捍卫私产，其出发点都在保有自我与意念。在掌握间距的背后，其实是表示了对战需具备知己知彼的基础，是故可藉此习得「先先之先」的意涵。</p>
<p>守方在第一式的过程中，要先取得正确的距离，看破对方攻击的心态（左上段时手部位于前方呈诱敌之姿），并在攻方攻入时，改变距离的情况而在一放一收间，再抓得时机立即反扑、瞬间斩切攻方，取得胜利。</p>
<p>在斩切后，守方会往前一步，切入攻方颜面并做出一个举剑的动作，这个动作就是所谓的「残心」。因为敌人被斩切头颅后，不一定会马上绝命，可能还有呼吸并会反击，所以守方再次升起剑尖，等于是表明了尚未放鬆、带有畏惧、不疏忽大意的预备心。</p>
<p>至于这个切入颜面的动作，在第一式的形上面，仅仅压下一点剑尖。实际上的意涵，却是希望将攻方彻底绝命。</p>
<p>攻方已死，没有残心，在守方做斩切与表现出残心的时候，仅仅回到下段姿势而已。</p>
<p>井上范士说明这个「正」，并不只代表了胜利而已：「纵使为了正义而战斗，人们认为杀人就是坏事。如果为了申张正义，不得不犯下杀人的举动，也需因此感到忏悔。所以守方在最后举起上段时，同时也表现著忏悔与为自己所夺性命祈祷的心情。」正因这样的「忏悔」的心，会衍生出第二式的「仁」的理念。</p>
<h2 id="第二式-手拔击手"><a href="#第二式-手拔击手" class="headerlink" title="第二式 手拔击手"></a>第二式 手拔击手</h2><p>打太刀（上位、攻方）中段 – 仕太刀（下位、守方）中段</p>
<p>一、上位攻方与下位守方皆为中段，皆以右脚始动前进。</p>
<p>二、双方前进至两剑相交时，攻方取时机打击守方手部。</p>
<p>三、守方以左后开足，落低剑尖，在攻方的剑下以半圆的弧度划开后，大步迈出右脚攻击攻方右手。</p>
<p>四、守方不可将剑尖压于攻方面前、亦不表现明显残心。</p>
<p>五、守方开右足，双方回至中段。</p>
<h3 id="剑理的陈述：中心线"><a href="#剑理的陈述：中心线" class="headerlink" title="剑理的陈述：中心线"></a>剑理的陈述：中心线</h3><p>在剑道形第二式中，以中段对峙时，攻方攻击守方手部，守方以左后开足再前进击打攻方手部。</p>
<p>然而，一般在打击对手手部时，攻方会稍往对手的右足切入，用意为避开对方的剑锷以打击手部。在第二式中，攻方却是直直地攻入，延著守方的剑身切进去（所以守方剑锷的保护作用变得很明显）。考虑到锷的因素，会发现攻方不一定在做一个全然的「攻击手部」的动作。</p>
<p>攻方所斩切者乃「中心线」也。所谓的「中心线」，包含了自己的位置、面对的方向、与对手间的距离…等等。以对手全身的体态作为基准，并在两人间产生敌我之感。配合的间距，「中心线」即为剑道形第二式欲呈现的剑理。</p>
<p>攻上乃上位，以手部为目标进行的攻击，乃在表现出自己中心线的攻击，下位的守方以最小的左后开足，离开此一中心线，再凭藉著自己的中心线加以反击。这一式的「攻」，不在于是否能成功击中手部，而是是否掌握的中心线的改变。</p>
<p>跟「间距」差别最大的在于，中心线表现出敌我间左右位置的概念。守方脱离攻方的中心线，并重置中心攻击，这就是本式攻防上的重点。</p>
<h3 id="心法与意涵-1"><a href="#心法与意涵-1" class="headerlink" title="心法与意涵"></a>心法与意涵</h3><p>剑道形第二式，中段为「仁」的象徵。所谓的「仁」，乃将心比心、慈悲为怀的仁爱之心也。比较第一式重视绝对胜利的主张来说，第二式更加重视与对方的互动，并显现攻防一致的作为。</p>
<p>将避免战斗的仁心，表现在外。仅切断敌人的手腕，而不给予夺命的一击，仅仅取胜而已。</p>
<p>然而避免战斗，并非只守不攻或是逃跑。即使保持著平静的姿态，依然注视著敌人的举动，一但发生事端，则先机立断、击破敌人，而有「先先之先」的气度。所以，也可以很容易理解中段如鸭子划水的意思。<br>身为上位的攻方，要斟酌守方的中段，看准时机切破之。</p>
<p>守方以左后开足，再向前打击。如同第一式一样，双方是以正面交战，且即使力量不如对手，也能够获得胜利。第二式的守方因避开的攻方的中心线，建立了自己的中心，在这一个时刻下可以取得压倒般的胜利。<br>在武术中堪称基本，就是以身体取得优势。当体势佔于上风时，心力亦会有馀裕。在第一式中，以向苍天祈求的忏悔之心，在第二式已转化为将心的馀裕以「慈悲为怀」展现出来的「仁心」。</p>
<p>井上范士认为第一式为「战胜之方」，而第二式即表达了「以剑技通向剑理」的方向。从战胜的策略至战胜的剑道，第三式将会更加阐明「道」的部份。</p>
<h2 id="第三式-刺击后反刺"><a href="#第三式-刺击后反刺" class="headerlink" title="第三式 刺击后反刺"></a>第三式 刺击后反刺</h2><p>打太刀（上位、攻方）下段 – 仕太刀（下位、守方）下段</p>
<p>“攻方”和”守方”均保持采用”下段姿势”，从右脚开始踏出，向前跨进三步，进入适当的距离内对峙着，交接时似无意识的上提成为中段姿势，在此一瞬间， “攻方”喊”呀”！刺击、直入”守方”的心窝。”守方”由左脚后退一大步、闪开身体，同时，把对方的刀身轻轻地往左边拔开，向前逼进一步，喊”拓”，反刺 “攻方”的心窝。</p>
<p>此时，”攻方”要将右脚向后退，同时把刀从”守方”的刀下方拔开，然后，双方稍稍地伸直，把对方的刀，向右侧压住。”守方”则一边踏出左脚，一边把对方的刀向右压住。</p>
<p>“攻方”再度地退后左脚，同时把刀从下方反拔过来，将”守方”的刀，向左压住，”守方”再度地踏出右脚，以自己的刀，压住对方的刀，此时，”攻方”遭瓦解攻势后，做出解除攻击的姿势，向后退二至三步。</p>
<p>“守方”立刻趁机由左脚，向前踏进二至三步，把刀尖对淮”攻方”的脸部中心，表示残心，给予警告。再稍微后退，变成对峙的中段姿势。接着，两人都回到[中**央]部位，解除姿势，（退后五步）回复到自己原来的位置上。</p>
<h3 id="剑理的陈述：抢中心线、攻"><a href="#剑理的陈述：抢中心线、攻" class="headerlink" title="剑理的陈述：抢中心线、攻"></a>剑理的陈述：抢中心线、攻</h3><p>在开始讲解第三式前，就不能不提到居合道中的小常识…「水月」。「水月」一词在日本武术中，代表了人体的胸口或是胃部，而剑道形中即採用前者的意义，表示胸口的要害，更明确地说来，即为「鸠尾」，乃胸口近横膈膜处。胸口被强劲地攻击时，会因衝击而无法呼吸，中止呼吸是攻击此处的要点。</p>
<p>在剑道形第三式中，攻方向守方「水月」刺击，守方如引诱攻方一般，将左手收进怀中，但剑尖保持在中心线上，再深深向前刺回。在剑理的阐述上，本式在中心线的争夺上，表达了出「进攻」的模式。</p>
<p>教导剑道时，中心线被视为最重要的一部份，在一足一刀的距离，双方的剑尖相互横向压制以取得中心。但在第三式中，守方在攻方刺击的时候，先以剑尖偏左并押住对方的剑，再让剑尖回到中心直直攻入。这个动作一开始时，守方并没有佔据住中心线的位置，而是尔后才再由中心线不断攻入。</p>
<p>去〝取得〞这个中心线的攻防，就是剑道形第三式的基本原则。</p>
<p>不论是间距、中心线、抢中心线，都是剑道基础中最重要的部份。加上上段的构形与刺击等技法，可以帮助初学者习得良好的动作。</p>
<h3 id="心法与意涵-2"><a href="#心法与意涵-2" class="headerlink" title="心法与意涵"></a>心法与意涵</h3><p>剑道形第三式持下段，是「勇敢」的象徵。</p>
<p>所谓的「勇敢」，意指身体有充沛的精力，什麽事情也不会有所畏惧，而有颗坚强的心。然若只是蛮勇外显，虽表现强悍，却容易沦为无谋之勇。真正的勇敢为「大勇」，不会被任何的事物动摇心神，凡事能沉著应对，乃「不动心」也。</p>
<p>我们常认为下段的构形似有若无，无法判定是否有战意，也无法揣测胜负。正因其不被意念所拘束，反而成为「无心之构」，或是「自然之姿」。这种安宁应对、不惊慌抢夺的「无心」之心，表现出的就是不被动摇的「不动心」，不动心并非僵止的「止心」，而是将对手的一举一动正确补捉，无时不刻观察形势的变化。<br>当双方以下段前进，慢慢升起剑尖至接触时，攻方应测试守方的「不动之心」，稍稍提高剑尖，发现守方并没有出现动摇的状态，则瞬间做出击刺以杀其不动之心。</p>
<p>（请注意，攻守间因模拟反应的进退，两者之间必有时间差，守方的动作会出现宛如慢了一点的表现。但是慢了一点也还是守方得胜，因为没有人被杀了以后还可以做杀人的呀！不过也不要慢太多，要宛如〝如影随行〞。）</p>
<p>这时，守方不只没有受到动摇，而改变距离、以退为进，一边守护著自己的中心线，再刺回攻方。</p>
<p>原先想要攻击对手的攻方，反被逼迫回来，以自然的体势一边左右勉强阻挡守方的反刺，一边后退。但守方不为所动，持续攻击并切入攻方的中心。</p>
<p>最后，守方将剑尖抵至攻方的脸中心，表示出攻方已经完全地战败。这一完美而显著的胜利，并没有伤害到攻守任何一方的身体。也因此，不同于第一式的面部攻击与第二技的手部攻击，剑道形第三式并非比赛技法，在现代剑道比赛规则并无法得分。</p>
<p>井上范士将此式视为剑道中，体育竞赛与武道的分界线。剑道形第三式的练习中，已由剑技演进为「道」。</p>
<p>有趣的是，以一般国际运动赛事的标准来看，或许致对方于死的第一式应强过第二式，然后又强过完全不会受伤的第三式。但从武道的观点来看，不需致对方于死地便能得胜的第三式，反而优于必须伤害对手来取胜的前二式。武道与竞赛的差异和心态的判断，不论我们是否要推行剑道进入奥林匹克竞赛项目，都属于难以解析的部份。</p>
<p>目标在于得胜，而不伤害敌手，与「活人剑」的概念产生的呼应。然日本刀是杀人的武器，并非单纯的防身术，在修行的尽头，却从「捨己身」进入到保护敌人身体的思维，值得多加玩味。</p>
<h2 id="第四式-面拔击右面"><a href="#第四式-面拔击右面" class="headerlink" title="第四式 面拔击右面"></a>第四式 面拔击右面</h2><p>打太刀（上位、攻方）八相 – 仕太刀（下位、守方）脇腰</p>
<p>一、 攻方持八相，守方持脇腰，相互前进三步。</p>
<p>二、 抵达适当的距离时，攻方观察著守方，双方变化为左上段后，相互大大迈出右脚击面。但因为两刀交<br>锋，所以不分胜负。（左上段为：可以从两腕中间看见对方的高度。）</p>
<p>三、 双方刀身相交、不分胜负时，以对等的气度展开，成为中段。此时若距离过近，由攻方调整距离。</p>
<p>四、 攻方将剑尖稍稍转向守方之左面后，右足推进，双手刺向守方的右肺位置。刺击的时候，剑尖以刀身的左侧压入，由于守方会做出反挡的动作，攻方上身变得稍微前顷，剑尖低于水平。</p>
<p>五、 在攻方刺入的时候，守方左足往左前，右足后移，并同时以大动作返击面部。返击面部的举剑需让剑尖到后上方，在一拍子内完成。</p>
<p>六、 双方一边表达著残心，一边回到中段。</p>
<p>剑道形第四式，在经过前三式「间距」、「中心线」、「抢中心线」后，以互击面的练习表现出技之形。此式阴阳双构互攻，守方为「后之先」的代表。</p>
<p>与现代剑道惯常练习的技法来看，本式除了有左脚开足的动作外，最明显的就是构形的差异。</p>
<p>攻方持八相，守方持脇构，相互接近。此时，双方都不清楚对手的剑长，保持著警戒的态度小心靠近，然后较远的间距时双方击面，剑在两者头上相交。</p>
<p>但是，纵使不明白对手的剑长，也应该瞭解自己剑的长度，不应该在过远的间隔就予以出剑，不只浪费力气，也造成危险的处境。尤其当对方的剑若是比自己的长时，等于进到对手的攻击范围内。</p>
<p>因此，正确的第四式动作中，攻方应该一足一刀的间距向守方击面，务必做到朝向守方眉间的确实打击。守方对于攻方的击面，不但维持著自己的体势，更灵活掌握自己的距离，开左足，刀身通过自己的中心线，反击攻方的面部。唯初学者需考量安全因素，在揣摩捨身的打击时，也应採取适当的距离。</p>
<p>当双方的剑在空中相交时，双方一边拉开，一边以刀身相互争夺中心线。此时若是距离过近，攻方一边回到中段重新衡量距离，注意呼吸的节奏。</p>
<p>第四式的守方，接下来会表现出取中心线的做法，并不会因为攻方的攻击而被压抑，反而转、压、擦攻方的刀身。由于守方可以抓住返击的瞬间，才使得攻方失势而战败。</p>
<h3 id="构形的介绍"><a href="#构形的介绍" class="headerlink" title="构形的介绍"></a>构形的介绍</h3><p>【八相】</p>
<p>举起双手左上段后，将右拳降下至右肩的位置，左拳约在中心线上，锷与口同高，与口相距约一个拳头宽。将前述动作结合，即为在中段时，将刀以双手举起，越过左上段的位置后架起。</p>
<p>此时刀刃朝向对手，刀身倾斜约45度。 右足略开。</p>
<p>【脇构】</p>
<p>将右脚收到后方，只剩下左半身朝前。刀身藏于右半身，剑尖朝后，比下段的位置再低一点点，刀刃偏右下方。综合前述动作，架起脇构时，务必自中段大动作架起，刀身不让对方看见。</p>
<p>左拳的位置约在肚脐右下方，左腕不弯曲。 双脚稍微外八.</p>
<h2 id="第五式-面擦击面"><a href="#第五式-面擦击面" class="headerlink" title="第五式 面擦击面"></a>第五式 面擦击面</h2><p>打太刀（上位、攻方）左上段 – 仕太刀（下位、守方）中段</p>
<p>一、 攻方持左上段，守方持中段（平青眼）。</p>
<p>二、 相互前进至适当距离时，攻方见机打面，守方左足稍退，格挡后迈出右足返击攻方面部。</p>
<p>三、 守方返击面部后，像弹开般收回右脚，举起左上段以表现残心。</p>
<p>四、 双方回到中段，向攻方方向同时并进三小步，解剑。</p>
<p>擦（摺上），请注意擦击位置。</p>
<p>举剑返击（攻方为动态，注意距离）</p>
<p>在剑道形第四式后，已开始呈现出具体的剑技与练习的方法，以做为学习的策略与目标。剑道形第五式乃在第四式「掌握机会」的「互击面→返技」后，进阶为「佔领优势」的应对技「擦击面」的练习。</p>
<p>擦击，除了包含返击技中利用对手崩溃的体态击败之，更加以阻止对手再度的连击。不论是返击或擦击，知瞭刀身的「镐」是非常重要的部份。什麽是镐？初学者可以刀身试想之，有段者请详查日本刀结构。</p>
<p>由剑道形可以发现，应对技并非单纯的等待，一开始的姿态便需取胜。但是初学者容易在习得时机的掌握前，就先接触了技法的动作，所以常出现面对 高段 老师也不积极进攻，或是身体出现逃跑意识的心态和动作。为了避免不当的动作，养成良好的习惯特别重要。就算是拉到比赛剑道的层面，能使出高超的应对技常是克敌致胜的关键（特别推荐胴技、刺击百选）。</p>
<p>所以，在有段者的修鍊中，时时需仰赖师长的指导与严格的规范，才不致于打出偏离正道的剑。</p>
<h2 id="第六式-手擦击手"><a href="#第六式-手擦击手" class="headerlink" title="第六式 手擦击手"></a>第六式 手擦击手</h2><p>打太刀（上位、攻方）中段 – 仕太刀（下位、守方）下段</p>
<p>一、 攻方持中段、守方持下段，前进至适当的距离。</p>
<p>二、 守方观察时机，以气势攻入攻方的两拳之间，因而慢慢将剑尖提高为中段。</p>
<p>三、 攻方揣测著守方的动作而刀尖略低，在双方刀尖快要相交时，退右脚举起左上段。</p>
<p>四、 此时，守方立刻跟进一步。攻方马上退左足回到中段，并观察时机打击守方手部。</p>
<p>五、 守方开左足，划出很小的半圆，以刀的右侧擦开攻方的刀，迈出右脚攻击攻方的手部。</p>
<p>六、 攻方退左足呈斜后位置，守方迈出左足，持左上段表现残心。</p>
<p>七、 双方从右足回到中段。</p>
<h3 id="三杀法的表现"><a href="#三杀法的表现" class="headerlink" title="三杀法的表现"></a>三杀法的表现</h3><p>剑道形第六式，在第五式的「应对技」的展现后，进入到剑道最重要的「攻」的教导。当有良好的应对技能时，面对对手的攻击便不再感到害怕而心有馀力。此时不只是要活用自己的剑去破坏对方攻击的体势，更加要破坏对方的构形与心态。</p>
<p>在第六式的开始，攻方持中段、守方持下段。在剑道形中，以攻方为始动者，但第六式却让守方开始降低剑尖而成下段，为什麽呢？乃因中段为阴之构，所以守方才採取性属阳的下段应对之。且大日本武德会制定之剑道形第六式中，攻方乃持「睛眼」，揣摩其位置可察觉，刀尖仍有提高。这个动作可追本溯源得知原因。<br>在双方刀尖快要相触时，守方从下段提高攻击的气势而不断逼入，使得攻方无法制止成功，而产生上段的动作，表现出已受动摇的心境。而且，即使攻方已举起上段，守方仍不放过他，像流水般一口气补进，使得攻方上段的攻击能力完全被封锁住。</p>
<p>攻方先输了「气势」，然后又输了「技能」，于是一边降为中段，一边引诱守方。如果这时守方躁进跳面，必然失去手部。但是守方以冷静沉著的应对，使其在对手进攻时，藉由擦技而反攻对手的手部。</p>
<p>此即为「杀其气」、「杀其技」，最后「杀其剑」而得胜的「三杀法」也。</p>
<p>其实在利用擦技来进行反击，不一定侷限在手部。这种「第二次攻击」前，会因第一次攻击结束而节奏稍微暂缓，这个转变的地方便是制压对手的剑的良机。在全日本剑道选手权中，宫崎正裕的面就有如此变化，掌握惊人的良机是让对手无法招架的重点所在。所以一边压、擦对手的剑，这种杀剑的技法，在猛烈的逼攻中是不可或缺的部份。</p>
<p>第六式中，守方打的kote不像第二式一样做很大的斩切，仅仅以制止为目的轻轻地伤害对手。攻方尚未屈服，退左后方后还欲整理体势打算尝试反击。因此，守方抓住了中心线，追上守方，掌握攻击的距离，以上段表示出不允许反击的意念。</p>
<p>持有对「先」的概念，留意持续进攻的重要性。即便敌人只受了轻伤，也能以「活人剑」之姿，得到胜利。</p>
<h2 id="第七式-面拔击胴"><a href="#第七式-面拔击胴" class="headerlink" title="第七式 面拔击胴"></a>第七式 面拔击胴</h2><p>打太刀（上位、攻方）中段 – 仕太刀（下位、守方）中段</p>
<p>面拔击腹(MEN-NUKI-DO)</p>
<p>“攻方”和”守方”两个人，均保持对峙的中段姿势，并且两者均从右脚开始起动，向前跨进三大步，进入中段距离的范围内。”攻方”经过深呼吸后，立刻刺向”守方”的胸膛，”守方”也伸直双手，反刺”攻方”的胸膛，随即，双方均恢复到中段的姿势。</p>
<p>“攻方”把左脚向前踏出，同时举刀右脚再跟进，喊”呀”！由上方用力地攻击”守方”的正面部。”守方”即将右脚向右斜前方展开，左脚跟前，双眼注视”攻 方”，趁其举刀向上时，喊”拓”！还击对方的右腹部，并顺势将刀拉到右侧，半跪右膝盖，持肋腰姿势，表示残心警告之意。</p>
<p>“攻方”伸臂举刀转身面向”守方”，将刀下移成中段姿势，”守方”也将刀高举，以右膝盖为轴，转向”攻方”正面，两方中段交剑，”守方”以充分之气势，将跪地之右足向前踏进一步起立。回复原为站立之中段姿势。</p>
<p>最后，两人均从右脚开始，退回到自己原来拔刀时的位置上，彼此挺起胸膛而蹲下收刀。然后，由左脚开始向后退五步，回到原来的位置，敬礼，退出道场。</p>
<h3 id="逼攻"><a href="#逼攻" class="headerlink" title="逼攻"></a>逼攻</h3><p>在「三杀法」的应用后，剑道形第七式展现了更高的技能：「逼攻」。</p>
<p>在第七式中，攻方为两段式的进攻，第一次进攻中，攻方攻入守方的中心线，如果守方没有反应，已可达到顺利击面的位置。但守方採取了「剑前体后」的姿势，使其跳脱攻方的打击距离。其后，让剑尖稍有偏高，是守方成功引诱攻方击面的重要动作。</p>
<p>而守方积极应对的心，是成功阻止攻方逼攻的重点。动作上将剑提前去阻挡，实则一边防守，一边准备反攻，也就是「悬待一致」的实行。成功地引诱出攻方的击面后，就可以以充份的馀裕打出漂亮的拔击胴。</p>
<h3 id="活杀自在"><a href="#活杀自在" class="headerlink" title="活杀自在"></a>活杀自在</h3><p>拔击胴，因为手上的刀、成功的逼攻，使得自己的双手，可以决定敌人的腰斩与否，是一种「活杀自在」、「生灭不二」的技法。简单来说，你必须掌握了对方的生死，所以才会有「不是你死就是我活」的讲法。这并非意指真正的生、死，而讲究著完全操控的能力。</p>
<p>攻方被击胴后，并没有失去生命，但也仅能回首一望，以残存的精力感谢守方的不杀之恩，毫无反击的能力。</p>
<p>诱敌、逼攻、操之在我、克敌而不取其性命，此为第七式完整的表现，也是大日本武德会制定剑道形第七式时，欲表现的意涵。</p>
]]></content>
      <tags>
        <tag>kendo</tag>
      </tags>
  </entry>
  <entry>
    <title>十三邀:带着偏见看世界</title>
    <url>/p/815619e8.html</url>
    <content><![CDATA[<p>《十三邀》，人物访谈节目，作家许知远做为不合格的主持人，带着没规矩的问题，去问不同行业的人，展示不同的人物之间的思想碰撞。</p>
<a id="more"></a>

<h2 id="信息负载、茧房和文化小丑"><a href="#信息负载、茧房和文化小丑" class="headerlink" title="信息负载、茧房和文化小丑"></a>信息负载、茧房和文化小丑</h2><p>在信息化的时代，新闻资讯的窗口不再掌握在传统电视台中，过去的平台影响力已经无力化，行业价值往人身上转，不再落在组织上。是个人文化创作的机遇，同时也是信息质量不可控的开始。</p>
<p>罗出来创业后，建立罗辑思维的栏目，同时也是在解决信息负载的问题：大量的信息流、信息平台带来的信息茧房，每个人都只看到自己想看的东西，整体的认知和扩展变得更困难。在这样的时代，很难知识的全面性，难以培养看待事物的多面性，信息平台用信息流夺走了用户的思考时间，让信息走向自闭。</p>
<p>大众需要一个来打破封闭的人，罗辑思维将知识打碎，糅合进娱乐元素，通过大V音频解说的方式来在茧房中打开一扇小门，罗自嘲是小丑，在别人的世界中表演着，但内心更像是定位为点灯人，想多带来一些光。</p>
<p>信息过载的问题我也很有体会，在2012～2014年，国内的知乎、澎湃、简书等新信息平台都是质量和颜值担当，但在大众创作的自媒体时代，文章的数量和质量让我信息消化不良，在切换过多个信息平台也无法解决问题后，放弃传统信息平台采用自建 RSS 订阅系统。</p>
<h2 id="姚晨的自我认知"><a href="#姚晨的自我认知" class="headerlink" title="姚晨的自我认知"></a>姚晨的自我认知</h2><p>一个科班出身的演员，却因为一个喜剧角色出名，该骄傲吗？该高兴吗？不该吗？</p>
<h2 id="刘姥姥逛大庄园，许知远来二次元"><a href="#刘姥姥逛大庄园，许知远来二次元" class="headerlink" title="刘姥姥逛大庄园，许知远来二次元"></a>刘姥姥逛大庄园，许知远来二次元</h2><p>投入到二次元中的人是在逃离吗？也许是一种主动的融入，二次元团体性格都比较单纯，价值观更容易达成一致性，也许有人会觉得这个世界肤浅，但依然是现实世界的一个延伸。</p>
<p>现实世界太真实了，而在二次元的世界，有些东西你能想，而且你还能去做。</p>
<p>如今社会发生了巨大的变化，但是新生的一代人看到了变化的结果，却并没有看到变化的过程。</p>
<h2 id="冯小刚的创作"><a href="#冯小刚的创作" class="headerlink" title="冯小刚的创作"></a>冯小刚的创作</h2><p>做为一名电影导演，冯小刚创作了很多票房出色的电影，但其中有很多喜剧片被认定为格调肤浅，没内涵，现在，这么一个成功的导演该如何面对激情、年龄等难关。</p>
<p>面对多年来的创作，讨论创作的可能性，也觉得其中有说不出的苦，对于自己想拍的电影和观众想看的电影间的选择依然会很压抑。</p>
<h2 id="享受生活的蔡澜"><a href="#享受生活的蔡澜" class="headerlink" title="享受生活的蔡澜"></a>享受生活的蔡澜</h2><p>享乐主义，活在当下。</p>
<p>蔡澜，现在的放松和自由，也是放下了很多东西，许知远的很多问题，对时代的焦虑等问题都被轻轻带过，这种自在的背后是否付出了什么代价呢？</p>
<p>但实实在在地享受美食、旅游、情人，这也是真实的快乐。</p>
<p>很多时候想通了什么都可以，就在于敢不敢想</p>
<h2 id="俞飞鸿的美"><a href="#俞飞鸿的美" class="headerlink" title="俞飞鸿的美"></a>俞飞鸿的美</h2><p>俞飞鸿是一个美人，一个有气质的美人，一个从小美到大的人，大学期间就参演好莱坞电影《喜福会》，导演过自己的电影《爱有来生》，多么美好的设定。</p>
<p>但这不是一切，气质来源于自小严格的家教，在独立生活后，也认识到自己自我表达能力不足，性格中缺少主动的部分，自我约束力的强大，也让生活缺少某种激情。</p>
<h2 id="陈嘉映谈哲学"><a href="#陈嘉映谈哲学" class="headerlink" title="陈嘉映谈哲学"></a>陈嘉映谈哲学</h2><p>哲学是希腊的，最初的哲学是追求卓越。追求知识、追求明白，穷理，追求终极真理，来满足精神追求。这是最初的哲学。</p>
<p>但现在的时代，并不追求这种理智。</p>
<p>时代的悲哀是，在这个时代，我们认为最牛逼的人，只不过是成为一个正常人，大家都没有意识到在你之外，有一个更伟大的东西存在，他们可能是学者、作家可能是演员，他们那些有辉煌的，有深刻的东西，但大家都还没有能力去欣赏这些东西。如果有营养的知识太少，那我们的时代本质上，是一个非常匮乏的时代。</p>
<p>这个时代有明显的功利主义，但平民社会嘛，老百姓的追求本来就是如此，平平安安、快快乐乐不好吗？</p>
<p>但把功利主义放在那些杰出的哲学家身上又不一样，柏拉图的和亚里士多德为雅典做过什么？如果说做过什么的话，那是我们现在还知道有雅典。反过来雅典能够为柏拉图和亚里士多德做点什么？那是人类精神最美的花朵！</p>
<p>追求真理并不容易，因为真理是有可能危害我们生存的，因为生活中有很大的不确定性，当我们认识到这种不确定性后，我们想通过哲学去理解它，但最后的真理可能并不会解决这种不确定性。</p>
<p>哲学给了我很好的角度去理解世界，但又阻止自己更深入地了解世界。<br>良好的实践就是目的本身。<br>真实，该真实到什么程度？有些问题不去过问也能继续过下去，过得也不差，专研下去结果也不一定美好，因为真实不代表美好。<br>拷问出真实下面的虚伪，接着要拷问出虚伪下面的真实。</p>
<h2 id="贾樟柯的小众电影"><a href="#贾樟柯的小众电影" class="headerlink" title="贾樟柯的小众电影"></a>贾樟柯的小众电影</h2><p>贾樟柯的电影挺不错的，淳朴而真实，充满了生活的气息，但在 2018 年之前我完全不知道这个人的存在，到了 2019 年才看过他的作品，做为一名电影爱好者，我看的电影也不少，他的电影真的挺小众的。</p>
<p>看了《二十四城记》，这种七十年代的集体生活对于一名南方的九零后来讲完全是另一个世界，那种集体、团队、大家庭的生活缺少个人、隐私、娱乐，但也有很多人情、同龄人和安全感，这是不同时代的人的生活，如果早几年我想我也看不下去，可以理解为什么这么小众。</p>
<p>那段历史不一定是美好的历史，但那也是一代人的记忆，能有人去记录这么一段时光本身就很有价值，这段时光的好与坏又有什么关系呢？</p>
<h2 id="金承志的艺术"><a href="#金承志的艺术" class="headerlink" title="金承志的艺术"></a>金承志的艺术</h2><p>我们生活在一个大众的时代，这个时代渴求个性，但不能容许异端。</p>
<p>上海彩虹室内合唱团，因为《张士超你到底把我家钥匙放在哪里了》在网络上大火。</p>
<h2 id="白先勇的选择"><a href="#白先勇的选择" class="headerlink" title="白先勇的选择"></a>白先勇的选择</h2><p>俗雅共赏的红楼梦，古典中国文化的大作，我在16岁的时候看了2页就没看了，不同时代的人们是怎么看到这种中国文化呢？</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>十三邀离不开许知远，带着偏见看世界，个人对世界、时代、信息的焦虑和担忧，在当代人中寻找对答案思考。</p>
<p>我很喜欢其中的“偏见”，不一定正确的言论比一定正确的问题和答案更有趣，更能带来思考。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>千与千寻：个人与世界</title>
    <url>/p/3bd7a3e9.html</url>
    <content><![CDATA[<p><img src="/images/blog_qyqx_cover.jpg" alt=""></p>
<p>千与千寻，一个饱满的世界，一个奇妙的童话，一段神奇的冒险，一群迷失的承认，一个纯真的小孩。</p>
<p>2007 年，我最先关注到的动漫电影作者是新海诚，《秒速五厘米》把距离、思念、离别的哀思刻画得无比细致，电影那种刹那的的美，细致的风景，擦身而过的爱恋，难以相聚的思念；关注着爱情的细致和美好，同时笼罩着离别的无奈和悲伤。</p>
<p>而宫崎骏的电影，是画师们的笔下的众生，主角作为一个视窗，展示着世界的奇妙和复杂，现实而充满想象，美好又布满艰辛；</p>
<p>其中的人物立体而饱满，在千与千寻中，大量配角都是活着的“人”，锅炉爷爷的对小千的推脱和袒护，小玲的刀子口豆腐心都让各自的人格立体化，而这些人物，无一面对生活的压力，在社会和自我的矛盾做着抉择；</p>
<p>工作，在小镇中有着独特的意义，没有工作的人会化作家禽成为食材或看着自己一点点透明然后消失，这同样是现实社会对个人约束，没有贡献、没有能力的人没有存在意义！而融入社会的人则不断改变着自己避免被大潮抛下，签下汤婆婆的契约，放弃自己的名字，不再以个人而是以社会的一部分存在，在劳动中创造自己的价值，在人群中获得一份淡淡的安宁，在欲望中交换遗忘日常的苦恼，这也是一种生活。</p>
<p>但有些人，总是无法接受这种安宁，或者说他们无法忍受自己的不完整，白龙、无脸男面都在追求自我缺失的部分，一个不惜伤痕累累命在旦夕，一个化作饕餮吞食欲望，但最后，千寻找回名字让白龙的过去不再迷茫，吐尽污秽让无脸男的无言不再只是寂寞，千寻在其中又是怎样的存在呢？</p>
<p>我觉得是真，真实的自我，是害怕小路的胆小，是拒绝美食的礼貌，是面对汤婆婆的坚持，是处理汤屋的手忙脚乱，是面对河神的主动，是对无脸男的同情，是对白龙命危时牺牲，她是一个良善的人，这种向善的力量，是这个欲望的世界中不可磨灭的光彩。</p>
<p>这份真和善不是小孩独有，但在成长的旅途中能够保留它的人太少。</p>
<blockquote>
<p>“去吧，记住，一定不要回头！”</p>
</blockquote>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>医生的精进：进步</title>
    <url>/p/36b46cbb.html</url>
    <content><![CDATA[<p>这个世界躁动、无序、动荡不安，作为其中的一部分，医学不可能独善其身。更和况，医学界不过是由我们这样一群普通人组成的而已。人类易受迷惑、身心脆弱、眼界狭隘的弱点，我们身上一个都不少。尽管如此，选择医生这个职业，就意味着我们要过负有责任的生活。那么，问题在于，接受这份责任之后，我们该怎样做好这份工作。</p>
<h2 id="改革推行"><a href="#改革推行" class="headerlink" title="改革推行"></a>改革推行</h2><p>有些问题可能看到了结果但很容易忽略了过程，在第一线的人员并非没有注意到这些问题，有时向他们咨询意见可以让新措施推进得更顺利。</p>
<p>比如书中在提倡多洗手防止医生携带细菌感染病人的事情上，有很多医生推荐过很多流程和设备，但结果都不理想，最后反过来收集医院的医生、护士的意见，针对性地推进才有进展。</p>
<h2 id="记录规律"><a href="#记录规律" class="headerlink" title="记录规律"></a>记录规律</h2><p>越忙碌越要追求效率，有些问题在单个案例是表现不出来，通过大量记录提供了一个总结、回顾的机会。</p>
<p>在 “战地医生” 一章中，有外科医生分析外伤日志后，发现眼部受伤的发生率更高。原来是早先分配的护目镜太丑士兵不愿意戴，随后更新了时尚的防爆太阳镜，眼伤的发生率就下降了。</p>
<h2 id="实用的改革"><a href="#实用的改革" class="headerlink" title="实用的改革"></a>实用的改革</h2><p>有些改变比想象中的简单，但可能会多拯救千万条生命。</p>
<p>有些问题可能是技术上暂时无法解决的，但人需要面对的问题不只是技术，灵活变通，一样可以不断提高效能。</p>
<p>“产房的故事” 一章，讨论了顺产、剖腹产的发展，但最印象深刻的还是 “阿普伽新生儿评分表”，根据直观的生理反应评估新生儿的状况，能够有标准得针对性记录和照顾新生儿，直接将当时的新生儿夭折率从 1/30 下降到 1/500，简单但影响巨大。</p>
<p>阿普伽新生儿评分表后来闻名世界。护理人员根据 0～10 的等级标准对新生儿的状况进行评估。婴儿浑身显粉红色可以打 2 分，有啼哭可以得 2 分，进食良好可以得 2 分，呼吸有力得 2 分，四肢都能移动得 2 分，心率超过 100 得 2 分。10 分表示新生儿出生时状况最佳，4 分或以下代表婴儿不健全，体制虚弱。</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>下面是作者对如何在事业上不断精进的建议</p>
<ul>
<li>即兴发问</li>
<li>不要抱怨</li>
<li>勤于统计</li>
<li>笔耕不辍</li>
<li>勇于求变</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>只狼：堕入修罗</title>
    <url>/p/cb349d4a.html</url>
    <content><![CDATA[<h2 id="堕入修罗"><a href="#堕入修罗" class="headerlink" title="堕入修罗"></a>堕入修罗</h2><p>武艺高强，但连名字都没有的忍者</p>
<p>要知道，只狼亲手杀了他的忍术老师，被父亲背叛并杀死一次，一个人囚禁三年，出狱后在苇名城内掀起腥风血雨,那些飘洒的鲜血，临死的呻咛，不甘的面孔，这些关于死亡的记忆有几个人能忍受？</p>
<a id="more"></a>

<p>更可怕的是只狼是不死的，在经历被小兵围殴，狂犬撕咬，雷劈，跳崖等等死亡体验后，他注定不能解脱，唯一坚持的是拯救他的主人，这是他的责任，何尝不是他保持理智的一点光明，在生死错乱的深渊里支持他？</p>
<p>但当弦一郎这个明面上的敌人也被击败，少主得到解放，却要求只狼寻找杀死自己，解放不死诅咒的时候，只狼该选择守护少主的生命还是意志？</p>
<p>当枭给只狼一个选择，但在我看来是只狼对自己的叩问，选择生命还是意志？</p>
<p>我敬佩选择守护意志的人，但我也同情选择守护生命的人</p>
<h2 id="佛与鬼"><a href="#佛与鬼" class="headerlink" title="佛与鬼"></a>佛与鬼</h2><p>没有爱人，没有朋友，没有敌人，那种空洞，进一步成佛，退一步成鬼</p>
<h2 id="一心"><a href="#一心" class="headerlink" title="一心"></a>一心</h2><p>所以当狼化作嗜杀的恶鬼，一心说“你是个很讨人厌的家伙，但我却不恨你”。衰老的剑圣还有一战之力，炽热的血液再度充盈老迈的身躯，传奇的长刀从腐朽的鞘中闪出。当年那个举世无双的剑豪又回到了这个老人身上。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>口琴：口琴的历史</title>
    <url>/p/43947dc4.html</url>
    <content><![CDATA[<h2 id="口琴-（Harmonica-harp-Mouth-organ）（小型吹奏乐器）"><a href="#口琴-（Harmonica-harp-Mouth-organ）（小型吹奏乐器）" class="headerlink" title="口琴 （Harmonica / harp / Mouth organ）（小型吹奏乐器）"></a>口琴 （Harmonica / harp / Mouth organ）（小型吹奏乐器）</h2><p>用嘴吹或吸气，使金属簧片振动发声的多簧片乐器；在乐器分类上属于自由簧的吹奏乐器。其发声源是长度介于1.5～3.5cm的簧片而非空气柱（如长笛）。</p>
<p>口琴主要分为独奏口琴和合奏口琴，各自又有不同种类。其音域依种类、调性不同而略有差异。作为旋律性乐器，口琴可以吹奏至少两种和弦，高水平的乐手可以在口琴在遵循口琴结构的前提下同时吹出两个相对独立的声部。因其小巧的体积被称为“口袋里的钢琴”</p>
<a id="more"></a>

<h2 id="口琴历史"><a href="#口琴历史" class="headerlink" title="口琴历史"></a>口琴历史</h2><p>口琴的由来有一段饶有兴味的逸闻。1821年的一天，德国有个名叫布希曼的音乐家，在托斯恩小城散步，偶然发现一个农家女孩坐在门口玩耍，一双胖乎乎的小手拿着一把贴着一张硬纸的木梳放在嘴边吹着。布希曼心里一亮，回去后，根据中国古代笙和罗马笛的发音和吹奏原理，用象牙雕刻成“药丸筒”似的口琴，这就是世界上最早的口琴。1857年，布希曼和托斯恩创立专制口琴的公司，制造出第一批口琴，并很快销售到欧美各地。到了1885年经过不断的改进，口琴才具备了现代的特点。口琴追溯其根源其实是调律用的工具。自由簧气鸣乐器。为小型的吹奏乐器。琴身呈长方形，其大小、长短各不相同，形制甚多。常见的为十孔口琴。此外还有半音阶口琴、复音口琴、贝斯口琴、和弦口琴等。 口琴源于中国，早期称为笙，由竹片发声的乐器，当时风靡亚洲；十八世纪后期，笙传入欧洲，流行于整个音乐界，并形成了当代口琴的构架。</p>
<p>比起其他正统乐器而言，口琴的沿革其实相当的短浅，而且世界各地的版本不一，这也是个人为何在此仅能浅论而难能深究的主要原因。在参考过许多版本后，有些记载看法倒是放诸四海皆一致：「笙」为我国古乐器八音之一，是一种具有自由律动的簧乐器，也为最早的一种具有和声的乐器，所以它被认为是近代口琴的先驱。笙在十八世纪时，流传到欧洲，经过一段不算短的时期渐渐地人们从它的结构而研究发明了口琴，簧风琴(Reed Organ)和萨克斯风 (Saxophone)，因而笙也被公认是它们的鼻祖。</p>
<p>最早的簧片型乐器源于中国，大约数千年前，被称为笙“Sheng”。这种由竹簧片发声的乐器很快风靡亚洲，在传统音乐中占据重要地位。18世纪后期，Sheng传入欧洲，很快在音乐界流行开来。远在3000多年前的商代，我国就已有了笙的雏型。在出土的殷（公元前1401～前1122）墟甲骨文中有“和”的记载。“和”即是后世小笙的前身。《尔雅·释乐》记载：“大笙谓之巢，小者谓之和。”</p>
<p>19世纪，欧洲乐匠们开始尝试用金属簧片来代替Sheng中的木质簧片。大约在1820年，一名叫Christian Friedrich Buschmann的年轻乐匠打造出了第一支采用金属簧片的口琴（当时称为Aura）。这种Aura以它独特的魅力而受到音乐家们的广泛好评；但当时的Aura却只有吹音，而没有吸音。</p>
<p>大约在1825年，欧洲人Richter发明了一种乐器，成为了现代口琴的雏形。该乐器拥有10个吹孔和两张簧板，每张簧板上由10片簧片。这样，在每个吹孔上通过吹气和吸气都可以发音，Richter所选择的这些音符也就是现在全音阶口琴（Diatonic Harmonica）的音阶排列，有时也叫做标准Richter音阶。<br>口琴的大量生产是在1829年的Vienna，很快在其他城市也出现了口琴制造厂。在德国小镇Trossingen，钟表匠Christian Messner和他的表兄Christian Weiss利用业余时间来制造口琴，但很快他们的口琴生意便红火了起来。几年后，当地另一位钟表匠Matthias Hohner开始拜访 Messner和Weiss，并学到了口琴的制作工艺，同时也开始了自己口琴生意。</p>
<p>显然，Matthias Hohner并不是一名很棒的口琴手，但他却是一位出色的商人。在市场是，Matthias击败许多竞争者，并且开始向美国出口口琴，很快美国便成了他最大的市场。1900年，Matthias将生意移交给了5个儿子管理。</p>
<p>在20世纪的前半叶，口琴的流行度继续扩展延伸，与此同时口琴乐队也发展迅速。Hohner发展了半音阶口琴（Chromatic Harmonica），通过控制一个按钮可以演奏出所有的音符。1930年，Larry Adler 成为最著名半音阶口琴手，这项荣誉一直保持到2001他去世后。</p>
<p>在美国，口琴作为蓝调乐器而闻名于世。二十世纪30年代以及40年代前期的代表为John Lee “Sonny Boy” Williamson。二次世界大战之后，Chicago成为蓝调音乐的中心，这里聚集了许多杰出乐手，如Rice Miller (Sonny Boy Williamsom II)和Little Walter。许多人一直认为Little Walter是最著名的蓝调口琴乐手。Little Walter于1968去世。</p>
<p>在口琴作为蓝调乐器而极度流行的同时，也有许多人通过Bob Dylan的民俗音乐开始熟悉口琴。许多杰出口琴手像Kym Wilson和Jerry Portnoy继续发展蓝调口琴风格，而其他像Howard Levy和Brendan Power则形成了一种新型且富有激情的口琴演奏风格。</p>
<h2 id="口琴构造"><a href="#口琴构造" class="headerlink" title="口琴构造"></a>口琴构造</h2><p>布鲁斯口琴每孔装有一对簧片，演奏者呼气时发一音，吸气时发另一音；半音阶口琴每孔装有两对簧片，有按键与呼吸配合发出4个不同的音。而复音口琴相邻的上下两格音高相同，通过换孔吹吸来吹奏不同的音。口琴19世纪在德国发明，它是以从亚洲带入欧洲的某些口风琴为基础改进的。</p>
<p>口琴的演奏可以有很高的艺术性，技艺精湛的演奏家可以通过改变簧片的发音和气流的压力来制造多种效果。口琴多用于蓝调音乐及乡村民谣中，也在摇滚乐中使用，随着半音阶口琴和10孔口琴的超吹技术的出现，口琴也可以吹奏古典音乐以及一些爵士音乐。此外，严肃音乐作曲家也对口琴产生兴趣，并为之创作音乐，其中有D.米约的《口琴与乐队组曲》和沃恩·威廉斯的《口琴与乐队浪漫曲》等等。</p>
<h2 id="口琴分类"><a href="#口琴分类" class="headerlink" title="口琴分类"></a>口琴分类</h2><p>按用途，口琴大体可以分为独奏用口琴和合奏用口琴两大类。前者主要包括布鲁斯口琴，半音阶口琴和复音类口琴（包括重音、回声口琴）等；后者则有贝司口琴、和弦口琴、铜角口琴等。</p>
<p>按发音方式，又可分为单簧片发音和多簧片发音两种。半音阶、布鲁斯口琴等属于单簧片发音，而复音类、和弦、贝司口琴则属于后者。</p>
<h2 id="布鲁斯-Bruce-口琴"><a href="#布鲁斯-Bruce-口琴" class="headerlink" title="布鲁斯(Bruce)口琴"></a>布鲁斯(Bruce)口琴</h2><p>这是欧美十分流行的一类口琴。由于最常见的类型具有十个孔的缘故，十孔口琴「10-Holes Harp」又叫布鲁斯口琴/蓝调口琴。此类口琴一孔两个音，多使用Ritcher调音方式——低音没有4和6，却又有两个5。这样的设计原本是考虑到民族音乐的需要同时可以演奏一些和弦而产生。但是压音（Bending）技术的出现，使得原本缺失的音能够演奏，同时也给布鲁斯口琴增添了独有的魅力，甚至可以说，这是布鲁斯口琴之所以成为布鲁斯口琴的原因。这恐怕是设计者当初万万没有想到的。此类口琴的特色在于它的小巧和独特的音色，是一种极为“人性化”的乐器。在布鲁斯音乐中，此类口琴具有和吉他比肩的地位。除此之外，布鲁斯口琴还很适合演奏一些具有民族风味的曲子。此类口琴学习的难度比复音也要大一些，一个重要的原因是压音技术的灵活运用需要长期的练习，同时布鲁斯口琴独特的乐理也需要花一些精力来学习。</p>
<p>随着布鲁斯在欧美地区的流行，继压音技术之后又出现了超吸和超吹（Overdraw、Overblow，统称Overbend），这两种技术可以在布鲁斯口琴上获得压音无法得到的升、降半音。自此，通过Bend技术和Overbend技术的结合，演奏者可以在任意一个调式的布鲁斯口琴上，都可以演奏出12个调性。</p>
<p>全音阶口琴有十个吹孔，每孔吹吸产生两个音，故称十孔口琴，又可以称为民谣/蓝调口琴。这种口琴在欧美极为流行，可以认为它是口琴爱好者中最大的族群。十孔口琴体积很小，携带容易，其音色具有相当的模仿能力，优美中带点忧郁，因此适合蓝调(blues)、摇滚(rock)、乡村(country)、民谣(folk)、爵士(jazz)等风格，也是影视娱乐配乐最常用的口琴。</p>
<h3 id="标准全音阶口琴-Richeter-System"><a href="#标准全音阶口琴-Richeter-System" class="headerlink" title="标准全音阶口琴(Richeter System)"></a>标准全音阶口琴(Richeter System)</h3><p>这是标准音阶排列的十孔口琴，估大部分热爱十孔口琴的人士都选用该种口琴，每孔两个音，共20个，约有3个八度。一般十孔口琴有一个共通的特性，就是低音部没有F和A，高音部没有B，这是为了和声上的考虑而特意设计的。吹奏者依然可以运用压音（banding）技术来吹奏出欠缺的音阶。关于这样的音阶设计其实要追溯到1825年一位波希米亚的乐器工匠Richter，改良并创新出现这种音阶排列系统。吹气时发出1、3、5一组音为C和弦，而吸气时发出2、4、6或5、7、2、4一组音构成G7和弦，对于演奏当时的民谣音乐非常适合，尤其适合演奏蓝调音乐。</p>
<p>由于richter system的音阶排列低音部没有F和A，对于演奏民谣或流行音乐时常采用低音部F和A的旋律，会有较大影响。所以口琴爱好者通常会依照自己的喜好和演奏风格自行定制口琴，这类口琴称之为调音全音阶口琴。<br>口琴半音阶</p>
<h3 id="半音阶口琴-Chromatic-Harmonica"><a href="#半音阶口琴-Chromatic-Harmonica" class="headerlink" title="半音阶口琴(Chromatic Harmonica)"></a>半音阶口琴(Chromatic Harmonica)</h3><p>这种口琴包含完整的半音音阶，可以用一只口琴演奏任何调的乐曲。半音阶口琴包括所有升降半音的12个音的半音音阶。半音阶口琴每个孔4个簧片，其中两个正常音高，两个为半音。通过在口琴一边的按钮切换正常音与半音。半音阶口琴适合演奏爵士乐（jazz），古典音乐(classic)，布鲁斯音乐(blues)与流行音乐。</p>
<h3 id="半音阶口琴"><a href="#半音阶口琴" class="headerlink" title="半音阶口琴"></a>半音阶口琴</h3><p>半音阶口琴是比十孔口琴更加严肃一些的乐器。完整的半音阶，最大可达四个八度以上的音域，使得诞生时间并不算长的半音阶口琴在正规乐器中占有一席之地。虽然不是传统交响乐团中的正式成员，但在许多口琴大师的努力下，半音阶口琴在室内乐等领域已有一定地位，国内外亦有以半音阶口琴为主音，由和弦、贝司口琴等组成的乐团活跃。常见的半音阶口琴为一孔四音，吹吸音成二度关系，按下变音键则每个音都升高半音。至于孔数则有8、10、12、14、16等多种，音域为二到四个八度，大部分为C调。由于可以演奏音域内的所有半音，此类口琴适合演奏比较复杂的乐曲。半音阶口琴的学习门槛比复音琴要高一些，一方面是乐理上的难度要大一些，另一方面也有吹奏难度上的原因：演奏半音阶对气息控制的要求比复音高得多，同时要求用气、移琴与按键的严格配合。另外，由于生产工艺、成本等原因，也有部分厂家生产一孔两音的半音阶口琴。常见的有国产的24孔48音琴，日本产的17孔、22孔琴等。还有一类独特的半音阶口琴，类似复音琴有两排孔，上面一排比下面一排高半音。一般认为，一孔四音的设计比较正规。据我所知，比较知名的演奏家中尚无选用后面两种琴的先例。</p>
<h2 id="复音类口琴"><a href="#复音类口琴" class="headerlink" title="复音类口琴"></a>复音类口琴</h2><h3 id="复音口琴（Tremolo-Harmonica）"><a href="#复音口琴（Tremolo-Harmonica）" class="headerlink" title="复音口琴（Tremolo Harmonica）"></a>复音口琴（Tremolo Harmonica）</h3><p>复音口琴又称震音口琴，是由双排吹孔构成的全音阶口琴，其上排簧片和下排簧片的音高（pitch）会被调整至有些微差距，每个音由相同音高的两个簧片发出。由于这两个簧片同时为吹孔或吸孔，演奏时两个簧片同时共鸣震动，两个簧片音高的细微差别会产生一种动听的震音效果。这种口琴较适合演奏民谣（folk）和乡村音乐（country），如拉丁美洲（Latin America），亚洲（Asia），欧洲（Europe）民歌。</p>
<p>复音口琴一般有16到28孔，其中以24孔为国内最常见。日本复音琴又常见21孔。复音琴孔分为上下两排，一般吹奏时，同一孔中上下两个簧片同时发声。由于两个簧片振动频率有细微差别，同时振动会产生物理上叫做“拍”的现象，表现为声音强弱的周期性变化，也就是所谓的“震音”。国外被称为“Tremolo”。复音口琴的优点是结构简单而固定，也不需要复杂的技巧，且复音口琴种类、调性齐全，音色清脆嘹亮，音量大，具有很强的穿透力，适合一些民族风格，是初学者的一个好选择。重音、回声口琴可认为是复音口琴的变种，同属于复音类。前者上下两个簧片成八度关系，音色丰满圆润；后者具有筒形的琴盖板（琴壳），具有独特的共鸣效果。</p>
<h3 id="重音口琴（Octave-Harmonica）"><a href="#重音口琴（Octave-Harmonica）" class="headerlink" title="重音口琴（Octave Harmonica）"></a>重音口琴（Octave Harmonica）</h3><p>重音口琴与复音口琴机构相同，有着同样的簧片排列和音阶排列。不同之处在于同一个音的两个簧片音高相差一个八度。音色饱满浑厚靓丽，十分动听，并没有震音效果。适合演奏古老的民俗（folk）音乐和爱尔兰（Old Ireland）音乐。</p>
<h3 id="小中音口琴（Bariton-Harmonica）"><a href="#小中音口琴（Bariton-Harmonica）" class="headerlink" title="小中音口琴（Bariton Harmonica）"></a>小中音口琴（Bariton Harmonica）</h3><p>中音口琴即是BARITON（BR），中音口琴亦与复音口琴相仿，其音比高音口琴（即复音口琴）全部低了八度，在大合奏中它多用做伴奏和表现音色较沉重的旋律。中音口琴在大和奏时，其地位相当于管弦乐中的中提琴部份。 中音口琴是口琴家族的主要成员，它既能在合奏时使乐声溶合，又能像独奏乐器般善于表达感情。</p>
<h3 id="回音口琴（Echo-Harmonica）"><a href="#回音口琴（Echo-Harmonica）" class="headerlink" title="回音口琴（Echo Harmonica）"></a>回音口琴（Echo Harmonica）</h3><p>用来合奏或作为某些曲子专门独奏的复音口琴，拥有桶形的盖板使得它有一种特殊的回音效果。它的内部结构和复音口琴一样，差别在于外面的盖板，回声口琴外面的盖板很大很宽，可以底部是封住的，两端开口，这样一来只要堵住一端，然后扇动另一端就能制造出一种特殊的像回声一样的效果，音色优美独特。</p>
<h3 id="重音回声口琴（Octave-amp-Echo-Harmonica）"><a href="#重音回声口琴（Octave-amp-Echo-Harmonica）" class="headerlink" title="重音回声口琴（Octave &amp;Echo Harmonica）"></a>重音回声口琴（Octave &amp;Echo Harmonica）</h3><p>重音口琴与回声口琴的结合体，既拥有回声口琴的外形且同一个音的两个簧片音高相差一个八度的口琴。</p>
<h2 id="口琴合奏类"><a href="#口琴合奏类" class="headerlink" title="口琴合奏类"></a>口琴合奏类</h2><h3 id="贝司口琴-Bass-or-Double-Bass-Harmonica"><a href="#贝司口琴-Bass-or-Double-Bass-Harmonica" class="headerlink" title="贝司口琴(Bass or Double Bass Harmonica)"></a>贝司口琴(Bass or Double Bass Harmonica)</h3><p>贝司口琴比较特殊,所有的孔均为吹孔，贝司口琴主要担任乐队内低音的部分，又被称为低音口琴。贝司口琴较重，有单音簧</p>
<h3 id="低音口琴"><a href="#低音口琴" class="headerlink" title="低音口琴"></a>低音口琴</h3><p>或双音簧发声的型号。倍低音（double bass）是双簧音的那种，其上下簧片音高相差八度。类似于钢琴，上排孔相当于钢琴的黑键，下排孔相当于钢琴的白键。较一般口琴低一个或两个八度。贝司口琴的音色低沉、浑圆、厚重，负责衬托旋律和稳定乐曲的节奏及速度。是口琴社团和乐队的必备乐器，就像乐队中的节拍器一样的作用，能与和旋口琴相互配合成为一个完整的小节。</p>
<h3 id="和弦口琴-Chord-Harmonica"><a href="#和弦口琴-Chord-Harmonica" class="headerlink" title="和弦口琴(Chord Harmonica)"></a>和弦口琴(Chord Harmonica)</h3><p>和弦口琴是所有口琴中长度最长的种类。这种口琴的每一个孔都是有一个和弦组成。即每一个孔由若干</p>
<p>簧片组成以形成和弦。例如，C和弦由C、E、G 组成。这类口琴用于合奏中的伴奏。这种口琴能造出独奏类口琴如何苦练技巧也无法媲美的和声效果，是口琴社团、乐队的必备之一。 但是由于不能吹奏旋律所以几乎无法用来独奏，也几乎没有以和弦口琴为主乐器的曲目，少数和弦口琴能简单的代替低音口琴的作用，能与低音口琴相互配合成为一个完整的小节。</p>
<h3 id="铜角口琴（Horn-Harmonica）"><a href="#铜角口琴（Horn-Harmonica）" class="headerlink" title="铜角口琴（Horn Harmonica）"></a>铜角口琴（Horn Harmonica）</h3><p>从外形上铜角口琴兼具低音口琴的壮与和弦口琴的长。铜角口琴分为高音铜角（soprano horn）和中音<br>铜角口琴</p>
<p>铜角(alto horn)两种，单音簧发声，只有吹气音而没有吸气音，琴格分为两排，上排孔相当于钢琴的黑键，下排孔相当于钢琴的白键，管状的盖板与木格琴身营造出像木管或法国号似的音色，甚至有编曲者把管乐部分编给铜角口琴来吹奏，但它并不适合吹奏快速的旋律。这种口琴音色清亮而圆润，纯净而特殊，可用手做振音效果，是口琴社团、乐队的必备之一。</p>
<h3 id="大中音口琴（Bariton-Harmonica）"><a href="#大中音口琴（Bariton-Harmonica）" class="headerlink" title="大中音口琴（Bariton Harmonica）"></a>大中音口琴（Bariton Harmonica）</h3><p>大型中音口琴即常说的大中音口琴，它的构造分上下两格，上面一格的音比下面的一个高半度。中音口琴是复音口琴中比较特殊的琴，它比普通复音低了八度，除此之外，其余特点与普通复音口琴无异。在大合奏中较常见到。在大合奏的配置中，相当于管弦乐团的”中提琴”的地位，当然有时也有例外。中音口琴比普通复音耗气。故更需注重气的使用。中音口琴琴壳有Bariton字样，可作为辨别中音口琴与普通复音的标识，口琴合奏谱常以”Br.”的缩写记之。大中音口琴音色厚重、优美，在口琴合奏中是不可缺少的一个声部，有时候也在重奏中担任重要的声部。大中音口琴是单孔发音，和半音阶口琴很合得来，而且音色浑厚，在重奏中担任第二或第三声部非常适合。在以往口琴合奏曲谱中中音声部大都是配和声，跟着重音或和弦声部走，很少给个主旋律，在口琴队中很不起眼，往往不受重视，基本上是由吹奏技巧一般或是新队员担任，这就很“委屈”大中音口琴了。 大中音口琴的鼻祖是程明德先生，他在口琴总厂担任技师时研制的。程先生大中音口琴吹得非常好，气息控制收发自如，发音洪亮，音色优美。我听过他和学生们一起演奏的“旧友进行曲”，程先生用大中音口琴吹中音声部，穿透力很强。</p>
<h3 id="笛声口琴"><a href="#笛声口琴" class="headerlink" title="笛声口琴"></a>笛声口琴</h3><p>笛声口琴有高音微声和中音笛声两种。这是一种大型的单音口琴，也只有吹音没有吸音。它的音色很好听。只是由于面积大，音孔距离较远，音阶大跳比较困难。</p>
<h3 id="迷你口琴"><a href="#迷你口琴" class="headerlink" title="迷你口琴"></a>迷你口琴</h3><p>(Mini Harmonica)<br>也被称作“项链口琴”，可以说这种口琴应该是所有乐器当中最小巧的一种，通常为4孔8簧片结构。由于只能吹出一个完整的八度。所以可以吹奏的曲目十分有限。国外大厂的项链口琴都做的很华丽，所以首饰价值要比实用价值大。</p>
]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的意义</title>
    <url>/p/8e41d96f.html</url>
    <content><![CDATA[<p>事到用时方恨少，想来还是记录下来靠谱；</p>
<p>开始写博客大概是2013年，那时候是在CSDN上写写博客，不过那时候还在上大学，更新文章基本看心情，而且大多文章也不过是转载看到的一些技术博客，原创记录基本很少；现在回头看来那时就是浮躁，肚子里没点墨水却硬要去写，矫情啦！</p>
<p>现在，大学毕业，会想过去四年的确发生了很多事情，有些事情很有趣、有些事情很悲伤，但还有很多事情已经没什么印象；</p>
<p>现在建立个人博客，想记录下生活感想，想分享下技术心得，一点点的记录，用时间和文字来见证自己吧。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>口琴基础：嘴唇、口腔、气息</title>
    <url>/p/76928c39.html</url>
    <content><![CDATA[<p>口琴的吹奏离不开基础的三要素：嘴唇、口腔、气息</p>
<h2 id="嘴唇"><a href="#嘴唇" class="headerlink" title="嘴唇"></a>嘴唇</h2><p>金鱼吐泡型，人在深吸一口气后，慢慢吐出的那种“呼～～”的嘴形</p>
<p>注意：</p>
<p>嘴唇微微凸出，显圆形</p>
<p>不要紧张，导致左右两边裂开</p>
<h2 id="口腔"><a href="#口腔" class="headerlink" title="口腔"></a>口腔</h2><p>发’呼～～’的口型</p>
<p>舌头不要用力，脸颊不要用力、喉咙不要用力，口腔中空</p>
<h2 id="气息"><a href="#气息" class="headerlink" title="气息"></a>气息</h2><p>腹式呼吸，不要用嘴巴和喉咙，想象气息像水流一样从身体流出和流入，平缓而悠长</p>
<h2 id="标准单音"><a href="#标准单音" class="headerlink" title="标准单音"></a>标准单音</h2><p>一切的基础是为了发出标准单音</p>
<p>干净/饱满/圆润/平稳</p>
<h2 id="长音练习"><a href="#长音练习" class="headerlink" title="长音练习"></a>长音练习</h2><p>do、re、mi、fa、sol、la、xi do i</p>
<p>B=blow（吹） D=draw（吸）</p>
<p>4B=吹第四孔 4D=吸第四孔</p>
<p>4B-4D-5B-5D-6B-6D-7D-7B</p>
<p>7B-7D-6D-6B-5D-5B-4D-4B</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>蓝调口琴网</p>
]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学家们都干了些什么?:哲学家的哲学史</title>
    <url>/p/3e367285.html</url>
    <content><![CDATA[<p>哲学有一个特点，按照时间顺序排列哲学家，就可以形成哲学史。</p>
<p>《哲学家们都干了些什么？》这本书笔风通俗、幽默，避开直接描述晦涩的哲学观念，通过描述直观的哲学家，串联起整个哲学史，作为哲学入门读物非常推荐，同样的哲学入门读物我还推荐《苏菲的世界》，再进一步可以了解下《哲学九讲》和《西方哲学史》。</p>
<h2 id="怀疑论"><a href="#怀疑论" class="headerlink" title="怀疑论"></a>怀疑论</h2><p>柏拉图 亚里士多德</p>
<p>理性、逻辑和思考的开始。</p>
<p>怀疑过去的经验，通过理性的讨论不断探索真理。</p>
<h2 id="经院哲学"><a href="#经院哲学" class="headerlink" title="经院哲学"></a>经院哲学</h2><p>罗马的崛起，基督教的普及，宗教与哲学的矛盾在于宗教不能质疑，只能相信。</p>
<h2 id="理性主义"><a href="#理性主义" class="headerlink" title="理性主义"></a>理性主义</h2><p>笛卡尔 斯宾诺莎</p>
<p>我思故我在。</p>
<p>形而上学，metaphysics，研究高于物理学的、看不见、摸不着的学问。</p>
<p>理性主义，数理与演绎推理。</p>
<p>二元论，心灵世界和外界，相互独立、平等并且互相影响，但不能完全决定另一个。</p>
<p>一元论：</p>
<p>唯物主义，精神世界不过是大脑胜利活动的结果，精神是从物质中诞生的。</p>
<p>唯心主义，世界本质是精神的，外面的世界是心灵的产物。</p>
<h2 id="实体论"><a href="#实体论" class="headerlink" title="实体论"></a>实体论</h2><p>经验主义</p>
<p>洛克、莱布尼茨</p>
<p>理性主义</p>
<p>牛顿、霍布思</p>
<p>机械唯物主义、决定论</p>
<p>休谟</p>
<p>因果论的疑惑</p>
<p>康德、费希特、谢林</p>
<p>物自体，先天认识形式，表象，先验。</p>
<p>理性认识的极限，无法认识的物自体世界。</p>
<p>黑格尔</p>
<p>辩证法，矛盾的统一。</p>
<h2 id="悲观主义"><a href="#悲观主义" class="headerlink" title="悲观主义"></a>悲观主义</h2><p>叔本华</p>
<p>统一的物自体“生命意志”，欲望与痛苦。</p>
<p>尼采</p>
<p>“权利意志”</p>
<p>克尔凯郭尔</p>
<p>形而上学与自由意志的矛盾</p>
<p>逻辑实证主义</p>
<p>罗素、维特根斯坦</p>
<p>逻辑哲学论</p>
<h2 id="逻辑实证主义"><a href="#逻辑实证主义" class="headerlink" title="逻辑实证主义"></a>逻辑实证主义</h2><p>实用主义、实证主义</p>
<p>波普尔</p>
<p>证伪</p>
<p>先有理论，再有观察</p>
<p>科学是建立在经验主义基础上的、以实用主义为原则筛选出来的、可以被证伪的理论。</p>
<p>我们并不能证明世上存在普遍的规律，但是人类为了生存，为了便于使用理论，必须要在各种混乱的经验中总结出规律来。换句话说，人类是带着“总结经验”的目的去观察、去总结经验的，因而发现了各种普世的规律。</p>
<p>大样本随机双盲实验</p>
<h2 id="存在主义"><a href="#存在主义" class="headerlink" title="存在主义"></a>存在主义</h2><p>萨特、加谬</p>
<p>存在先于本质</p>
<p>自由和责任</p>
<p>西西弗的神话</p>
<p>世界的荒诞</p>
<p>故事性的理性信息接收。</p>
<h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>形而上学走不通，形而上学的问题都没有答案。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>四月是你的谎言：献给理想的赞歌</title>
    <url>/p/4da21e7c.html</url>
    <content><![CDATA[<p><img src="/images/blog_sysndhy_cover.jpg" alt=""></p>
<p>在攀爬理想的高峰时，有肉体的疲惫和平静，有精神的重压和忘我，有他人对自己的期待和污蔑，有面对挑战的恐惧和兴奋，有追逐着对手的不甘和高兴，有对自我的迷惑和肯定，有对社会赋予的标签欣喜和厌恶，有寸进的乐和停滞的苦，有互相陪伴的温暖，更多时候是独自专研的寂寞，这一路有眼泪，也有笑容，谁也不知道谁能走到顶峰，但最开始的感动依然在心头。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CocoaPod的Swift组件化开发</title>
    <url>/p/c19912ca.html</url>
    <content><![CDATA[<h2 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h2><p>私人Repo的构建和组件发布，相关资料可以看Cocoapods创建私有podspec,基本流程类似，但由于Swift在CocoaPod中是动态库形式存在，有些问题需要处理</p>
<h2 id="2-组件化，Swift4-2"><a href="#2-组件化，Swift4-2" class="headerlink" title="2. 组件化，Swift4.2"></a>2. 组件化，Swift4.2</h2><p>目标是基于CocoaPod封装基础的组件，暂不讨论项目架构</p>
<h3 id="2-1-Module-‘xxx’-has-no-member-named-‘yyy’"><a href="#2-1-Module-‘xxx’-has-no-member-named-‘yyy’" class="headerlink" title="2.1 Module ‘xxx’ has no member named ‘yyy’"></a>2.1 Module ‘xxx’ has no member named ‘yyy’</h3><p>1.文件没有对应方法，实际是引用出现错误，点击对应.swift文件，展开Xcode右边工作栏，在’file inspector’（文件图标）分类下的Target Membership，选上对应的项目包即可。</p>
<p>2.类的权限错误，检查是否要用public修饰，因为在 target 外只能调用到 public 的代码</p>
<h3 id="2-2-dyld-lazy-symbol-binding-failed-Symbol-not-found"><a href="#2-2-dyld-lazy-symbol-binding-failed-Symbol-not-found" class="headerlink" title="2.2 dyld: lazy symbol binding failed: Symbol not found:"></a>2.2 dyld: lazy symbol binding failed: Symbol not found:</h3><p>开发的组件依赖了其它第三方库，在’file inspector’（文件图标）的Target Membership取消第三方文件的引用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://swifter.tips/property-access/" target="_blank" rel="noopener">https://swifter.tips/property-access/</a></p>
<p><a href="https://www.jianshu.com/p/18db54655246" target="_blank" rel="noopener">https://www.jianshu.com/p/18db54655246</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法：二维数组的查找</title>
    <url>/p/aea6943c.html</url>
    <content><![CDATA[<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>假设数组如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[] &#x3D; &#123;</span><br><span class="line">    1,2,8,9,</span><br><span class="line">    2,4,9,12,</span><br><span class="line">    4,7,10,13,</span><br><span class="line">    6,8,11,15</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现一个规律，如果我们从右上角开始排查，即row=0，每一列的第一个数字是该列的最小值，如果该值大于查找的整数，那么该列的值都可以排除；如果该值小于查找的整数，则所在的行的值都小于该值，都可以排除；通过不断缩小查找范围，找到要查找的数字或者为空。</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int bool;</span><br><span class="line"></span><br><span class="line">#define true 1</span><br><span class="line">#define false 0</span><br><span class="line"></span><br><span class="line">bool Find (int *matrix, int rows, int columns,int number) &#123;</span><br><span class="line">  bool found &#x3D; false;</span><br><span class="line">  if (matrix !&#x3D; NULL &amp;&amp; rows &gt;0 &amp;&amp; columns &gt;0) &#123;</span><br><span class="line">    int row &#x3D; 0;</span><br><span class="line">    int column &#x3D; columns-1;</span><br><span class="line">    while (row &lt; rows &amp;&amp; column&gt;0) &#123;</span><br><span class="line">      if (matrix[row*columns+column] &#x3D;&#x3D; number) &#123;</span><br><span class="line">        found &#x3D; true;</span><br><span class="line">        printf(&quot;row:%d,column:%d\n&quot;, row,column);</span><br><span class="line">        break;</span><br><span class="line">      &#125;else if(matrix[row*columns+column]&gt;number)&#123;</span><br><span class="line">        column--;</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        row++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a[] &#x3D; &#123;</span><br><span class="line">    1,2,8,9,</span><br><span class="line">    2,4,9,12,</span><br><span class="line">    4,7,10,13,</span><br><span class="line">    6,8,11,15</span><br><span class="line">    &#125;;</span><br><span class="line">  bool b &#x3D; Find(a,4,4,7);</span><br><span class="line">  printf(&quot;%d\n&quot;, b);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法：字符串转换整数 (atoi)</title>
    <url>/p/1524e441.html</url>
    <content><![CDATA[<h1 id="你来实现一个-atoi-函数，使其能将字符串转换成整数。"><a href="#你来实现一个-atoi-函数，使其能将字符串转换成整数。" class="headerlink" title="你来实现一个 atoi 函数，使其能将字符串转换成整数。"></a>你来实现一个 atoi 函数，使其能将字符串转换成整数。</h1><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42</p>
<p>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
<p>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p>
<p>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) </p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line"></span><br><span class="line">int myAtoi(char* str) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;void?</span><br><span class="line">  if (*str &#x3D;&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;long long 32</span><br><span class="line">  long long llnum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  int sign &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#39; &#39; and void handle</span><br><span class="line">  while (*str !&#x3D; &#39;\0&#39; &amp;&amp; (*str &#x3D;&#x3D; &#39; &#39;) ) &#123;</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;%c\n&quot;, *str);</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; +&#x2F;-</span><br><span class="line">  if (*str &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">    sign &#x3D; -1;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;else if(*str &#x3D;&#x3D; &#39;+&#39;)&#123;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;number</span><br><span class="line">  while (*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">    int i &#x3D; *str - &#39;0&#39;;</span><br><span class="line">    llnum &#x3D; llnum*10+i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; max&#x2F;min</span><br><span class="line">    if (llnum*sign &gt; INT_MAX) &#123;</span><br><span class="line">      llnum &#x3D; INT_MAX;</span><br><span class="line">      break;</span><br><span class="line">    &#125;else if(llnum*sign &lt; INT_MIN)&#123;</span><br><span class="line">      llnum &#x3D; INT_MIN;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (int)(sign*llnum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  char* a &#x3D; &quot;asb   987&quot;;</span><br><span class="line">  int result &#x3D; myAtoi(a);</span><br><span class="line">  printf(&quot;%d\n&quot;, result);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>外国电影里的幽默-王小波</title>
    <url>/p/992e470f.html</url>
    <content><![CDATA[<p>近来和影视圈里的朋友谈电影，我经常要提起乌迪·艾伦。这些朋友说，艾伦的片子难懂，因为里面充满了外国人的幽默。幽默这种东西很深奥，一般人没有这么大的学问，就看不懂。我说，我觉得这些片子很好懂。他们说：您是个最有学问的人哪。就因为能看懂艾伦的电影，我赚了这么一顶高帽。艾伦有部电影叫做《傻瓜》（Banana），写的也是个傻瓜，走在街上看到别人倒车，就过去指挥，非把人家指挥到墙上才算；看到别人坐在桥栏杆上，就要当胸推上一把，让人家拖着一声怪叫掉到水里——就这么个能把人气乐了的家伙，居然参加了游击队，当了南美的革命领袖？当然，这部电影想在中国上演是不容易的，但也没有什么高深的学问在内。</p>
<p>艾伦还有部片子，叫做《性——你想知道又不敢问的事情》，从名字就能看出来，这片子有点荤，不在引进之列，但也不难懂。我在街道工厂学过徒，我估计我们厂的师傅看到这部片子都能笑出来；但也会有人看了不想笑。有位英国演员得了奥斯卡金像奖之后，仅仅因为他是男的，追星族的少女就对他很热情。他感慨道：我现在才知道，原来四十多岁、秃顶、腆着个大肚子（这就是他老兄当年的形象），这就是性感的标志啊。我也有同样感慨：原来“傻瓜”、“想知道又不敢问的事”，这就是高深的学问啊。</p>
<p>最近看过美国电影《低级小说》（又译《黑色通缉令》），里面有个笑话是这样的：一次大战时，有个美国军人给爱人买了一块金表，未来得及给她，就上了前线。他带着这块表出生入死，终于回来，把表交给了她，两人结婚生子，这块表就成了这一家的传家宝。这家的第二代又是军人，带着金表去越南打仗，被越共逮住，进了战俘营。越共常常搜战俘的身，但此人想道：我要把这传家宝藏好，交给我儿子，就把它藏在了屁眼里，一连藏了五年，直到不幸死去。在临终时，他把表托付给战友，让他一定把表给儿子。这位战友也没地方藏，又把它藏在了屁眼里，又藏了两年，才被释放。最后，这家的第三代还是个孩子时，有一天，来了一位军官（就是那位受托的战友），给他讲了这个故事，并把这件带有两个人体温，七年色、香、味的宝物，放到孩子手心里。这孩子直到四十多岁，还常常在梦里见到这一幕，然后怪叫一声吓醒。</p>
<p>鲁迅先生也讲过一个类似的故事：民国时，一位前清的遗少把玩着一件珍贵的国宝——放在手里把玩，还拿来刮鼻子，就差含在嘴里——原来这国宝是古人大殓时夹在屁眼里的石头。从这两个故事的相似之处可以看出幽默是没有国界的，用不到什么高深学问就能欣赏它；但你若是美国的老军官，就不喜欢《黑色通缉令》；你要是中国的遗老，就会不喜欢鲁迅先生的笑话。在这种情况下，人就会说：听不懂。</p>
<p>除了不想懂，还有不敢懂的情形。美国的年轻人常爱用这样一句感叹语：Holyshit！信教的老太太就听不懂。holy这个词常用在宗教方面，就如中国人说：伟大、光荣、正确。shit是屎。连在一起来说，好多人就不敢懂了。</p>
<p>在美国，教会、军队，还有社会的上层人物，受宗教和等级观念制约，时常犯有假正经的毛病，所以就成为嘲讽的对象。这种幽默中国没有，但却不难理解。中国为什么没有这种幽默，道理是明摆着的：这里的权力不容许幽默，只容许假正经。开玩笑会给自己带来麻烦，我喜欢说几句笑话，别人就总说：你在五七年，准是个右派。五七年有好多漫画家都当了右派。直到现在，中国还是世界上少数几个没有政治漫画的国家。于是，幽默在这个国家就成了高深莫测的学问。</p>
<p>有一部根据同名小说改编的电影《玫瑰之名》，讲了这么一个故事：中世纪的意大利，有座修道院，院里藏了一本禁书，有很多青年僧侣冒着生命危险去偷看这本书，又有一个老古板，把每个看过这本书的人都毒死了。该老古板说道，这本禁书毒害人的心灵，动摇人的信仰，破坏教会在人间的统治——为此，他不但杀人，还放了火，把这本禁书和整个修道院都烧掉了。这是个阴森恐怖的故事，由始至终贯穿着一个悬念——这是一本什么书？可以想象，这书里肯定写了些你想知道又不敢问的</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>大国大城:逃回北上广</title>
    <url>/p/14a1bcee.html</url>
    <content><![CDATA[<p>#《大国大城》</p>
<p>作者：陆铭</p>
<p>阅读难度：★★★☆☆，话题深度：★★★★☆</p>
<p>城市化过程中产业、经济、环境变化和人员流动；</p>
<hr>
<p>全文分两部分：</p>
<p>第一部分，通过规模、人口、产值等数据说明城市化的现况，比较中国沿海和内陆的投资所表现出来的资源的流动，分析了最近几年大城市的人口流入流出，对政府的政策导向进行分析和评价;</p>
<p>第二部分，讨论了城市化过程中吸纳人口的重要性；根据各地特色引入合适的资源；同时对人口的不均匀提出不同的看法，鼓励聚集效果弱的区域让人口流出，空闲出来的土地发展集体农业，闲置出来的自然资源发展旅游业等；分析了城市化中空间、资源、人口的三足鼎立；比较了工业和服务业的价值产出和社会影响；</p>
<p>开发规划，招商引资，落户限制，人才引进等政策和规划之后，大城市应该聚集更多的人，同时让他们都找到一片栖息地。</p>
<h2 id="摘录："><a href="#摘录：" class="headerlink" title="摘录："></a>摘录：</h2><p>在集聚中走向平衡</p>
<p>如果你不相信地理的作用，就会把产业搬迁到中西部去，甚至搬到山区去。但是你要知道，企业家的目的是挣钱，他们不是传教士，也不是扶贫机构。在全球经济高度整合的今天，与中国的中西部相比较，企业为什么不去工资大大低于中国的东南亚国家？那里的深水港并不比中国差，而且离欧洲更近，还节省运费呢。所以，如果脱离中国的实际劳动生产率，通过行政干预的手段来“腾笼换鸟”，结果就可能是笼子腾出来了，新的鸟却没来，而被赶走的鸟却可能飞到了东南亚，没有飞到中国中西部去。</p>
<p>在“动钱”和“动人”两种区域间平衡发展的路径下，如果忽略地理对于经济增长发展的重要性，简单地依靠动钱，这样的发展是背离市场经济规律的。如果发展的目标是为了提高人的收入水平，为什么不能让欠发达地区的人流动到相对发达的地区呢？我们一边在讲沿海地区劳动力短缺，一边又阻碍劳动力流动。不让劳动力流动起来，地区间发展水平是更平衡还是更不平衡？有了前面的知识准备，大家应该能够自己找到答案了：劳动力不自由流动的结果是，在人均意义上地区间发展水平更不平衡了。所以，如果你相信国际贸易和市场接近度对于经济发展是重要的，地理就是重要的。如果地理是重要的，发展政策和追求区域间发展水平差异收敛的正确选择应该是“动人”为首选，“动钱”只能是建立在“动人”的基础之上。</p>
<p>在追求“平衡”的过程中，人们严重混淆了规模的平衡（经济资源的均匀分布）和人均的平衡两个概念，认为只有把经济资源往欠发达地区和人口流出地移动，才能实现平衡发展。但根据“在集聚中走向平衡”的道理和国际经验，在市场力量的主导下，人口向少数地方集中才能够最终带来人均意义上的平衡。通过政府力量干预资源流向，追求的是规模上的平衡，这样做的结果恰恰与目标南辕北辙。</p>
<p>从世界各国的发展经验来看，随着城市化水平不断提高，人口集中在少数地区，城市人口的空间分布会出现不平衡的现象。以此为依据，可以推出统一、效率、平衡之间的关系：在一个由市场主导、兼具政府干预的城市体系，一定在统一、效率、平衡之间存在某种冲突。</p>
<p>显然，让高铁经过全国的每一个城市，甚至每一个县、每一个村，肯定会形成公共资源的巨大浪费，这并不是最优的结果。我对律师朋友说，这个问题是有解的，这个解就是，在高铁主要连接大城市这一看似“不公平”的结果的同时，保证其他两个“公平性”条件：第一，允许人口自由流动，这样，其他地区的人口如果想获得高铁的效益，可以自由迁徙到有高铁的地方；第二，财政转移支付向欠发达地区倾斜，也就是说，如果一个地方没有直接享受到高铁的好处，那么，就应该通过财政转移支付的方式让它分享国家发展的成果。<br>偏离当地比较优势的投资不仅不会有效地帮助欠发达地区提高经济发展水平，而且可能使这些地方背上沉重的财政负担</p>
<p>不少人认为，这种意义上的“土地（使用权）换保障（户籍）”是对农民的一种剥夺。但这种反对声音却忽略了一个最基本的事实，那就是，土地（或其使用权）作为农民最为重要的资产如果不能交易，那它本质上就不是一种资产。当前要反对的是借助政府行政力量对于农民土地使用权的剥夺，而不是要反对借助市场机制使得农民的土地使用权得到符合其市场价值的补偿</p>
<p>同步的GDP总量增长速度呢？黑龙江能够安心做好全国人民的大粮仓，保护好它的黑土地和森林，让全国人民能够有个林海雪原的梦想，夏天去乘凉，冬天去滑雪，不是很好吗？要那么多人常住在半年下大雪的地方，又何苦呢?</p>
<p>他们面临的就是我说的两种产业升级。一种情况是，企业面对劳动成本上升，用资本替代劳动，但他们用的人却没有变得更能干，劳动工资虽然上升了，却未见得比生活成本上升得快，所以，待遇还是太低。另一种情况是，一部分（可能只是少部分）企业真的升级了，甚至走上了国际市场，但他们雇佣的人戴眼镜、讲英文，农民工适应不了这样的岗位。</p>
<p>资本深化过度”一直是计划经济的显著特征，而这条路带来的就是大量的资源错配，以及经济增长与人民福利的脱节。</p>
<p>每一个地方政府采取的地方主义的理性行为，都导致了巨大的集体非理性，那就是体现为产能过剩、妨碍竞争和产业小规模化的各种效率损失。</p>
<p>因为当他们回家的时候，收入将大幅度下降，对孩子的教育投入可能更差。既要发展城市，满足大量低技能劳动力的需求，提高农民收入，还要解决留守儿童的问题，实现这样多赢的目标，只有一个办法，就是让他们进城。不仅要让他们进城，而且随着时间的推移，逐渐增加教育的投入，让他们能获得跟城里孩子一样的教育，这才是最终能解决问题的出路。</p>
<p>几乎所有反对城市发展的论点都严重忽略了城市扩张的好处，而与城市扩张的坏处相比，那些好处往往并不直接可见。城市发展的好处最重要的来源就是所谓“人力资本外部性”。这个词的意思是说，一个人的教育水平提高了，不仅能使自己的收入有所提高，而且，在他与其他人的交往中，还能够相互学习和影响，促进知识的传播和生产，于是，别人的收入也能够有所提高。</p>
<p>城市规划不是像人们想像的那样，似乎把路建得越宽越易于行车，城市拥堵就减少了；恰恰相反，高密度、马路多而窄的模式反而可以引导服务业多样性、生活的便利性和出行需求的减少，出行也更偏好步行和自行车。</p>
<p>在不同的城市之间，通常是更大的城市劳动生产率和工资水平更高，那么，是不是大城市需求的低技能劳动者更少呢？不是这样的。我们的数据分析显示，恰恰是因为高技能劳动者在生产和生活中带动了对于低技能劳动者的需求，总体上来说，更大的城市中从事体力型服务业的劳动者比重更高。</p>
<p>外来高端人才的太太和孩子的生活当然是受到多方面因素的影响，比如空气质量、外语服务、双语教育。但不可忽略的是，价廉物美的生活服务业是提高生活质量的重要方面，这是人才公寓之类的硬件不能替代的。一个定位为国际大都市的城市，要吸引人才，靠的应该是服务和生活环境，这样的城市需要花力气吸引的人才不会住不起公寓。</p>
<p>不管怎么样，中国特大城市的人口继续增长，这是一个阻挡不了的趋势。如果一个城市的公共服务和基础设施按过去规划的人口规模来提供，而实际的人口规模远远超过曾经的规划，就会造成公共服务和基础设施的短缺。这时，我们是应该去科学预测人口，调整城市规划，增加公共服务和基础设施的供给，还是通过控制人口来控制需求？答案应该是很显然的吧？我但愿城市的管理者不要把一个主观想像的人口规模凌驾于普遍规律之上，延误了增加城市公共服务和基础设施供给的时机。</p>
<p>很多事情的发生有它的规律，我们要做的是尊重科学和规律，而不是以我们的好恶去看待它、以我们的利益去衡量它、以我们的权力去扭曲它</p>
<p>移民带来互补性和多样性，这对经济社会发展是好事，尤其是文化和科技领域，文化和民族多样性有益于产生重大的思想。特大城市的真正挑战在于，如果移民的融合做得不好，多样性就可能转化为冲突。如果移民是经济社会发展所必需的，那么，促进移民在人口流入地的融合就是必需的。在西欧，问题不是出现在移民本身，问题是有移民、缺融合。中国今天的特大城市如何去应对大量增长的国内和国际移民所带来的各方面影响，促进社会融合，这应该立即提上议事日程，不能再拖了</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>奇特的一生：与时间相伴</title>
    <url>/p/6a4d0908.html</url>
    <content><![CDATA[<p>奇特的一生，讲述了苏联昆虫学家柳比歇夫56年如一日对个人时间进行定量管理。</p>
<p>柳比歇夫（Alexander Alexandrovich Lyubishchev），以独特的方式实现对时间的准确预判和管理，在长达 56 年的时间里坚持优化自己的时间，向着自己的伟大目标背驰。</p>
<blockquote>
<p>对于时间，却由于我总是用文字为她拍照，因此可以时常伴我左右。她原本无情，我却可以把她当作朋友，因为她曾经让我明白，后来也总是经常证明，无论做什么事情，只要我付出耐心，她就会陪我甚至帮我等到结果，并从来都能将结果如实交付与我，从未令我失望。正是因为有了时间作为朋友，我才可能仅仅运用心智就有机会获得解放。</p>
</blockquote>
<a id="more"></a>
<h2 id="伟大目标"><a href="#伟大目标" class="headerlink" title="伟大目标"></a>伟大目标</h2><p>如果你没有一个伟大的目标，很难做到如此自律。 </p>
<p>别问我的伟大目标是什么，我的伟大目标也许对你不值一提，但它是我的梦想。要活出你的伟大，而不是到处打听别人的伟大目标是什么。<br>我们想搞清楚自己想成为怎样的人，然后想搞清楚要成为这样的人应该如何利用时间，效率才最高。 </p>
<p>家庭：和家人在一起，或为家人服务的时间 人际：主动地和朋友见面，建立和增进联系 事业：包括工作或自己想做的，可以称之为事业的事情 财富：理财、创建被动收入系统，等等 健康：锻炼身体、调节饮食等 心智成长：学习新技能、读书、参加课程 灵性：禅修、冥想、皈依、修行 贡献：自我价值的实现，包括微梦想、公益活动等 </p>
<h2 id="怎样才能生活得更好。"><a href="#怎样才能生活得更好。" class="headerlink" title="怎样才能生活得更好。"></a>怎样才能生活得更好。</h2><p>有人问到著名的组织学家聂佛梅瓦基，他怎么能一生都用来研究蠕虫的构造，他很惊奇：“蠕虫那么长，人生可是那么短！ </p>
<p>他，我们同时代的人，一生干了那么多事，产生了那么多思想，这是用什么方法达成的？最后几十年（他是82岁时去世的），他的工作精力和思维效率有增无减。关键不是在数量上，而在他是怎么样，用什么方法做到的。 </p>
<p>噢，路齐利，一切都不是我们的，而是别人的，只有时间是我们自己的财产，<br>我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事。” </p>
<p>一生忠于一个目标，柳比歇夫自己是幸福的；在别人眼中，也是令人羡慕的.</p>
<p>我们的记忆是靠什么？靠事件。我们的生活是拿事件来做标志的。它们仿佛是路标，路标之间却是一片空白…… </p>
<p>他能够叫时间服从他，但不能左右环境。他无非是个凡人，激情、爱、挫折都能叫他分心，连幸福也会影响他的专心致志。 </p>
<h2 id="谁同现实妥协，谁就是对未来没有信心"><a href="#谁同现实妥协，谁就是对未来没有信心" class="headerlink" title="谁同现实妥协，谁就是对未来没有信心"></a>谁同现实妥协，谁就是对未来没有信心</h2><p>1.我不承担必须完成的任务；<br>2.我不接受紧急的任务；<br>3.一累马上停止工作去休息；<br>4.睡得很多，10小时左右；<br>5.把累人的工作同愉快的工作结和</p>
<p>在他身上没有那种吞噬一切的、除了科学没有其他的着迷现象。科学、学术活动不能，也不应当是最高的目标，应当还有比科学、比时间更为珍贵的东西…… </p>
<p>……你是你自己最高的审判者； 你对自己劳动的估价会比任何人都严格， 你满意自己的劳动吗？苛求的艺术家。 </p>
<p>这样的自我修养在许多人看来是没有必要的，甚至令人愤慨。最普遍的是，大部分人认为首先应当是环境和社会作用于人，社会有责任培养人的个性，使个体的个性臻于完善，并对个人的个性提出要求等，所以大部分人顺其自然，不对自己提要求。 </p>
<p>决定人的精神品质的，不是他的行为本身，而是他的意图。 </p>
<p>古希腊唯物主义哲学家德谟克利特有句话：“决定人的精神品质的，不是他的行为本身，而是他的意图。” </p>
<h2 id="生活就是透辟地理解"><a href="#生活就是透辟地理解" class="headerlink" title="生活就是透辟地理解"></a>生活就是透辟地理解</h2><p>但只要作者不带任何情绪对比一下事实，那他就能看得很清楚，柳比歇夫在这同样的50年中，比作者多读了多少书，多去了多少次剧场，多听了多少场音乐，多写了多少东西，多干了多少事。与此同时，他对周围发生的一切，要比作者理解的好得多，领悟的深得多。 在这一意义上，完全可以把加缪的“生活就是透辟地理解”这句话应用到柳比歇夫身上。 </p>
<p>“事情不会是这样的。看起来，您的主人公是一个只有一种，然而是一种非常炽烈的激情的人。这么说，他就不是一个和谐的人。这就是怪事了：我们希望人全面和谐地发展，然而大家都知道，对于哺育人类的历史，最可爱的却是一生专注于一种激情的人……” </p>
<p>“一种，然而是一种非常炽烈的激情”会排除和谐的发展。激情妨碍人全面发展——这倒是一个令人惬意的处世秘诀。最好没有激情，这样要保险得多。什么都要有一点，似乎一切为人称道的志趣的总和就构成了和谐，似乎真的存在着没有激情的和谐一致的人。</p>
<p>问题就在于：一个人只有向自己提出远大目标时，这个时间统计法才能成立。 </p>
<p>最使人感兴趣的自然还是现实生活本身。我甚至可以说得更过分一些：使人最感兴趣的是生活的非典型性——即个别性。譬如柳比歇夫，一个不典型的人，完全是独一无二的，是一个罕见现象，一个奇迹、一件怪事。可是他的生活是司空见惯、普普通通的，难道不是这样吗？ </p>
<p>如何能做得更多、更快、更好——如果只用这种观点对待时间统计法，那么得到的好处也只是附带的。这自然也很好，但还不够。关键在于一个人希望从生活中得到什么。也有人的生活目标是把道德意义完全排除，这样的人使用时间统计法就会损人利己，不知会搞出什么名堂来。这如同武器一样，看掌握在谁手里。 </p>
<h2 id="应当学会计算一切时间"><a href="#应当学会计算一切时间" class="headerlink" title="应当学会计算一切时间"></a>应当学会计算一切时间</h2><p>柳比歇夫清楚自己活着的目的，在28岁时就设立了人生目标。 </p>
<p>他把一昼夜中的有效时间即纯时间算成10个小时，分成3个单位，或6个“半单位”，正负误差不超过10分钟。 </p>
<p>除了最富于创造性的第一类工作外，所有规定的工作量他都竭力按时完成。 第一类工作包括中心工作（写书、搞研究）和例行工作（看参考书、做笔记、写信）。 第二类工作包括做学术报告、讲课、开学术讨论会、看文艺作品，不属直接科研工作的活动都包括在内。 </p>
<p>计划的复杂性在于如何安排一天的时间。他决定，用去的时间应该同他从事的工作相称。也就是说，比方写一篇有独特见解的论文吧，占用的时间既不能太少，也不能太多。 计划就是挑选时间、规定节律，使一切都各得其所。头脑清醒的时候应当钻研数学，累了便看书。 应当学会不受周围环境的干扰，用在工作上的3个小时应当是真正做工作的3个小时，不想不相干的事，不听同事的谈话，不听铃声和笑声，也不听收音机。 </p>
<p>他的总结看起来挺枯燥，研究起来却很有味儿。 人在一年内能干多少事，能见识多少东西啊！太多了！每一份总结都显示了人有多大的潜力，每一份总结都使我们为人有那么充沛的精力。 </p>
<p>时间统计法成了他即兴演奏的乐器，用这乐器，他爱演奏什么就演奏什么。 他如此精打细算地统计时间，可他把时间都浪费到什么上去了？</p>
<h2 id="柳比歇夫"><a href="#柳比歇夫" class="headerlink" title="柳比歇夫"></a>柳比歇夫</h2><p>了解一个人——这就是要看到他的矛盾。 我明白倒是明白了，就是解释不清楚。明白和理解可不是一回事。然而这些矛盾并未削弱他的力量。他对生活、对自己、对科学所做的种种思考并未减少他的积极性。行动的渴望在增长。思维在督促着他。他不怕别人向他询问他那不知疲倦的写作和他那精力充沛的活动，其意义何在。有一点他知道得非常深刻，而且曾多次向别人说起过：谁同现实妥协，谁就是对未来没有信心。 </p>
<p>要说他最不能容忍的是什么，那就是无可争辩的真理、不可动摇的信仰、绝对的结论。 </p>
<p>柳比歇夫的时间永远是够用的。时间不会不够用——时间不管多少，总够用来做一件事。 </p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地提问？</title>
    <url>/p/ac32e52b.html</url>
    <content><![CDATA[<p>学习、工作中经常遇到一些问题，向别人询问时，应当注意不要问“太蠢的问题”。</p>
<p>“蠢”，不是指问题的需要的智商度数，而是自己是否了解这个问题，是否已经通过一些常用的方法去尝试过了？如果能用搜索引擎解决的问题，你硬要让别人给你解答，那么谁都不会欢迎这种蠢问题吧。</p>
<p>问题，其实可可以进行多次分隔：如想实现什么？想如何实现？能如何实现？</p>
<a id="more"></a>

<p>在这里，系统总结下：</p>
<p>1、确定核心问题。</p>
<p>明白要做什么，难点在哪里，是否是必须的，是否偏离自己想要的目的？</p>
<p>2、百度、谷歌、搜狗、必应</p>
<p>搜索也是一门学问，明白如何使用关键字，谷歌使用英文效果更佳，反正用关键字，语法什么的也用不上。</p>
<p>3、正确的提问地点</p>
<p>不在贴吧、Q群等地方提问，花时间，养成习惯不好</p>
<p>4、精确描述问题，自动尝试，记录关键代码</p>
<p>50%的问题，在你试着精确复述问题的过程中就已经解决了</p>
<p>5、记录、分析</p>
<p>记录，让你下次遇到能够花最小的时间解决它，不要以为下次不会遇到，也不要相信自己记忆有那么好。</p>
<p>分享，让其他人能少走弯路，明白不容易，所以要更努力。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>如何看病</title>
    <url>/p/ed922cec.html</url>
    <content><![CDATA[<p>转载于<a href="https://www.douban.com/note/209781665/,感谢@夏虫不语冰的分享" target="_blank" rel="noopener">https://www.douban.com/note/209781665/,感谢@夏虫不语冰的分享</a></p>
<p>今天和我一个有理科硕士学位的朋友聊天，他愤愤说起自己落枕排队就医等了2小时的事情。他好像完全不知道“作为病人，如何有效的看病”这门学问。</p>
<h2 id="我的心得："><a href="#我的心得：" class="headerlink" title="我的心得："></a>我的心得：</h2><ul>
<li>不能化妆，不要穿带亮片的衣服，不要穿袖子太紧不好脱的；</li>
<li>最好不要吃早饭；</li>
<li>第一次看普通号，完善检查以后再看专家号；</li>
<li>不要带小孩子（非病人）；</li>
<li>最好网上预约专家号；</li>
<li>8点前到医院，或者干脆下午来（绝对不合适的时间段是早上9-10点）</li>
<li>尽量带上以前个人一切的病例，检查结果，透视片子（不要卷起来，要平铺！！），出院小结，诊断证明，自己记录的血压单，血糖单或者体温单等，服用的药物清单，还有身份证，小孩带户口本原本</li>
</ul>
<a id="more"></a>

<h2 id="如何看病（－）：该看不该看"><a href="#如何看病（－）：该看不该看" class="headerlink" title="如何看病（－）：该看不该看"></a>如何看病（－）：该看不该看</h2><p>我不想讨论医疗制度如何如何，只是在现有的条件下，尽可能帮助需要医疗救助的人，使人们看病的效率更高。</p>
<p>请质疑任何从网络上获取的医学知识，包括本blog</p>
<p>欢迎传播</p>
<h3 id="问题1-该看不该看"><a href="#问题1-该看不该看" class="headerlink" title="问题1: 该看不该看"></a>问题1: 该看不该看</h3><p>人的身体是有自我修复能力的。而且这种能力很强，显然比电脑和汽车厉害。有些疾病并不需要治疗，有些疾病是有“自限性”的——也就是时间到了自己就好了。</p>
<p>不过，能够发生在人身上的疾病，也是伴随人类进化了同样长的时间，也不是等闲之辈。</p>
<p>如果自己身体不适，是扛着，还是去医院就诊。这是个问题。</p>
<p>如果器官的功能受损，需要立即就诊：</p>
<p>眼睛的功能是用来看东西的，突然看不见了，应该马上看医生。同理，突然听不见了，四肢运动突然出现障碍。。。值得注意的是，人类有许多器官是双份的，比如眼睛、耳朵。。有些人一只眼睛的视力突然下降，另一只却完好，有可能忽略了坏眼的问题。</p>
<h4 id="不能忍受的疼痛。"><a href="#不能忍受的疼痛。" class="headerlink" title="不能忍受的疼痛。"></a>不能忍受的疼痛。</h4><p>疼痛是身体发出的火警，不要去挑战疼痛。如果遇到不能忍受的疼痛，应该尽快就诊。比如腹痛、胸痛、眼痛。需要提示的是，即使你到了医院，通常医生也不会立即给你止痛。疼痛是火警，是了解身体状况的重要信号，没有人会在消灭火灾之前，先把附近的电话线都砍了。</p>
<h4 id="反复发作的不适"><a href="#反复发作的不适" class="headerlink" title="反复发作的不适"></a>反复发作的不适</h4><p>老毛病了，忍忍就过去了——大部分的癌症就是这样度过了无人骚扰的童年期。对于反复出现的不适，应该认真注意诱发的原因、缓解的方式。<br>对了，最重要的是——自己的年龄，&gt;50岁的，最好去看看，免除后患。</p>
<p>已经处于某个疾病进程中，但是感觉突然发生了变化。</p>
<p>大夫可能已经告诉你这个病没什么，过几天自己就能好，开始的时候，感觉也是一天比一天好，可是今天突然恶化了，那么最好再去复查一下。</p>
<h4 id="别人看出来的疾病"><a href="#别人看出来的疾病" class="headerlink" title="别人看出来的疾病"></a>别人看出来的疾病</h4><p>通常不用着急，人类的身体有发达的自我检测系统，如果自己没有什么不舒服的感觉，多半没有太大的问题。（注意：医生经过身体检查发现的除外，比如身体上的包块之类的）</p>
<p>典型的是结膜下出血。一般是“白眼珠”上有鲜红的血迹，自己毫无感觉，不疼不痒视力不降，通常是照镜子或者是被其他人发现，这种不是“眼底出血”，这种是“白眼珠”上的细小血管破了，跟磕青了没什么区别。咳嗽、便秘、揉眼睛。。。都可能引起。</p>
<h4 id="定期体检是必要的。"><a href="#定期体检是必要的。" class="headerlink" title="定期体检是必要的。"></a>定期体检是必要的。</h4><p>自己的身体只有自己保护，兄弟靠不住、组织靠不住。</p>
<h2 id="如何看病（二）：急诊还是门诊？"><a href="#如何看病（二）：急诊还是门诊？" class="headerlink" title="如何看病（二）：急诊还是门诊？"></a>如何看病（二）：急诊还是门诊？</h2><p>一般医院都有急诊和门诊。</p>
<p>急诊是给紧急需要救治的病人准备的。</p>
<p>门诊则是给不那么紧急的病人准备的。</p>
<p>急诊的设置是为了使病人在短时间内脱离危险，因此配备的药品都是应急的、速效的，配备的检查手段也是基本的，能够快速做出判断的。</p>
<p>所以，如果你得的是不那么紧急的病，甚至是慢性病，其实在急诊，并没有针对你的病的疗效好副作用小的药品，而且化验检查并不是很全，辅助检查的设备也不是都能做的。</p>
<p>不要仅仅因为白天上班，不好请假，而在晚上去看急诊。你得不到最好的药物，不能完成最好的化验检查和辅助检查。身体是自己的，工作是国家或者资本家的。仅仅为了不请假而在晚上看急诊，你为了节省一天的工资而放弃给自己最佳的诊断和治疗，又侵占了分配给急症患者的医疗资源，是损人不利己。</p>
<h3 id="需要去急诊看的病："><a href="#需要去急诊看的病：" class="headerlink" title="需要去急诊看的病："></a>需要去急诊看的病：</h3><p>刚刚发生的疾病。</p>
<p>一个病已经得了三天了，还跑到急诊去看，医生可能会态度很好的在心里痛骂。</p>
<p>这个疾病可能在8小时内使器官的功能造成不可逆的损害。</p>
<p>严格一点，需要急诊处理的眼病只有：视网膜中央动脉阻塞（需要在10分钟内救治）、眼球破裂伤、急性闭角型青光眼急性发作。（补充下，还有化学伤、烧伤等等。）</p>
<p>突然发作的腹痛、胸痛、眼痛、头痛，还是应该到急诊看看先。</p>
<h2 id="如何看病（三）：看门诊的时间"><a href="#如何看病（三）：看门诊的时间" class="headerlink" title="如何看病（三）：看门诊的时间"></a>如何看病（三）：看门诊的时间</h2><p>我国是地大物博人口众多，很小的可能性，乘以13亿，都是无比巨大的数字。</p>
<p>任何你觉得合适的时间，一定是门诊人多的时间。</p>
<p>一定要避开三个的时间：</p>
<p>星期一上午，星期一上午，星期一上午</p>
<p>只能用人海茫茫来形容。</p>
<p>为了您和家人的健康，请不要在星期一上午看病</p>
<p>请转告您周围的人，“为了您和家人的健康，请不要在星期一上午看病”，并请他们也转告周围的人。</p>
<p>通常来说上午看病的人多，下午少，周一多，周五少。到了周五的下午，基本看病的人就很少了。看来辛勤的工作有益于身体健康。</p>
<h3 id="季节性"><a href="#季节性" class="headerlink" title="季节性"></a>季节性</h3><p>放假了去配个眼镜吧——老老实实排队吧</p>
<p>等天凉快了再做这个手术吧——老老实实排队吧</p>
<p>等放假休息有时间了再去看这个病吧——老老实实排队吧</p>
<h3 id="恶劣的天气"><a href="#恶劣的天气" class="headerlink" title="恶劣的天气"></a>恶劣的天气</h3><p>刮风下雨是看病的最佳时机，雨越大，人越少。其实，天气对许多人的出行，并没有太大影响，如果工作很忙，需要在短时间内看个病，然后赶紧回去上班，最好是在下雨的天气去看病。</p>
<h3 id="如何看病（四）：看病前的准备"><a href="#如何看病（四）：看病前的准备" class="headerlink" title="如何看病（四）：看病前的准备"></a>如何看病（四）：看病前的准备</h3><p>相信您已经选择好了看病的日期，下面介绍一下看病前的准备。</p>
<h3 id="回顾历史："><a href="#回顾历史：" class="headerlink" title="回顾历史："></a>回顾历史：</h3><p>请在看病之前，回顾一下您的病史，从什么时候开始发病？发病的时候自己有什么感觉？如果有时间，请用本子和笔写下来。</p>
<p>回想一下是否对药物过敏。药物过敏史对于医生非常重要。如果您在以前用某种药物出现过严重的不良反应，请记录下来，在看病的时候向您的医生咨询是否属于药物过敏，如果是的，请医生在您最常用的病历封面上写下过敏的药物名称。</p>
<p>回忆一下曾经接受过的治疗，以及正在使用的药物，和它们的商品名称。如果您还能找到药物的说明书或者空的药瓶或者剩余的药物，请带上它们。</p>
<p>带齐以前的病历记录，曾经做过的检查结果。每次看过病后，也请收好所有的检查结果和病历，有些检查结果是由热敏打印，时间久了容易褪色，请复印一份保存。</p>
<h3 id="准备行政用品："><a href="#准备行政用品：" class="headerlink" title="准备行政用品："></a>准备行政用品：</h3><p>带上信用卡和足够的现金，有些医院不支持刷卡，而取款机前面排队的人可能很多。注意看管好自己的随身财物。如果您是小偷，盗亦有道，请勿在医院行窃。</p>
<p>带好身份证、社保卡、医疗蓝本、退休证、离休证、医院的就诊卡等等一切跟医保可能有关系的东西。平时除了身份证，这些东西最好专门使用一个透明塑料文件袋放在一起。</p>
<h3 id="安排好病假当天的事务："><a href="#安排好病假当天的事务：" class="headerlink" title="安排好病假当天的事务："></a>安排好病假当天的事务：</h3><p>请好病假，安排好当日的工作。工作是国家的或者资本家的，身体是自己的，只要不给同事添麻烦，离开工作岗位是没有问题的。</p>
<p>如果是去看急诊或者自觉比较严重的器官功能问题，比如严重的心前区疼痛、视力突然丧失等，带上手机和充电器，您有可能会需要住院或者留院观察。</p>
<p>最好能够找个比您更健康的伙伴陪同您去看病。</p>
<p>预计前往的时间，不要在上午11点以后，或者下午4点以后才去医院挂号。因为，恐怕没有号了，或者虽然看了医生，但是到需要做检查的时候，已经过了下班时间，其他的科室已经没人了。</p>
<p>估计一下交通情况，选择合适的交通工具。最好不要自己开车或者骑车，请打车前往医院。一是医院附近很难停车，停车费高昂，二是您接受的某些治疗可能再不适合开车或者骑车。</p>
<p>查询一下当日的天气。天气越恶劣，看病的人越少。</p>
<h3 id="选择合适的医院："><a href="#选择合适的医院：" class="headerlink" title="选择合适的医院："></a>选择合适的医院：</h3><p>如果您已经具有相当的医学知识，您可以根据自己的病情来选择医院。</p>
<p>一般社区医院和二级医院都非常的清净，去看病取药会很舒适。建议您首先去社区医院或者临近的二级医院就诊，至少可以获得相应的医学建议和转诊建议。如果您对这些医院的医疗质量不放心，也可以事先咨询一下有医学背景的朋友，去哪里看比较好。</p>
<p>当您选择了三级甲等医院看病，也就意味着选择挂号难、看病难。</p>
<h3 id="挂号"><a href="#挂号" class="headerlink" title="挂号"></a>挂号</h3><p>没什么好说的，太难了，甚至对于医生自己看病也很困难。如果是外地病人到另一个城市看病，而且要看某个特定的专家，试试提前在网上预约之类的方法，免得到了以后挂不上号，要等几天甚至一周，在北京最低的生活费也是100元/天，一旦等起来消费惊人。</p>
<h3 id="调整心情"><a href="#调整心情" class="headerlink" title="调整心情"></a>调整心情</h3><p>得病不是一件愉快的事情。但是人总是会生病的，迟早也是要病死的。所以疾病降临到自己身上，也没什么好抱怨的。</p>
<p>去医院看病，并不能一定能够治好。实际上，给您看病的医生，最后一定看不好他自己的病，100%是病死的。</p>
<h3 id="与您的医生合作，共同对抗您的疾病。"><a href="#与您的医生合作，共同对抗您的疾病。" class="headerlink" title="与您的医生合作，共同对抗您的疾病。"></a>与您的医生合作，共同对抗您的疾病。</h3><p>《史记•扁鹊仓公列传》“故病有六不治：骄恣不论于理，一不治也；轻身重财，二不治也；衣食不能适，三不治也；阴阳并，脏气不定，四不治也；形羸不能服药，五不治也；信巫不信医，六不治也。”翻译成白话文就是：一是狂妄、骄横、不讲道理的人；二是只重视钱财而不重视养生的人；三是对服饰、饮食、药物等过于挑剔、不能适应的人；四是体内气血错乱、脏腑功能严重衰竭的人；五是身体极度羸弱、不能服药或不能承受药力的人；六是只相信鬼神、不信任医学的人。对于属于上述六种情况之一的人，他们的疾病不论中医还是西医都很难治好。</p>
<h3 id="穿着打扮"><a href="#穿着打扮" class="headerlink" title="穿着打扮"></a>穿着打扮</h3><p>不要化妆。也许您会有面色苍白、黑眼圈。这些都没关系，这些恰恰是医生需要看到的。即便是去看那个很帅或者很漂亮的医生。</p>
<p>尽量穿容易穿脱的衣物，比如上衣建议是开襟的衣服，而不是套头的衣服。</p>
<p>袖子要比较容易的挽起来或者脱下。比如冬天，最好穿厚实的大衣，而里面穿相对薄一些的衣服。</p>
<p>口罩。如果有的话戴上，医院是疾病最集中的地方。本来您就处于比较虚弱的疾病状态，不要再感染了其他的疾病。口罩从医院回来以后要清洗，手也要好好洗。</p>
<p>检查确认上面的各种准备事项，带齐所有的东西，出发。如果能战胜疾病，就借助医生的力量一起战胜它，如果不能战胜疾病，那么从医生那里学会如何与自己的疾病共存。</p>
<h2 id="如何看病（五）-怎样与医生交流"><a href="#如何看病（五）-怎样与医生交流" class="headerlink" title="如何看病（五） 怎样与医生交流"></a>如何看病（五） 怎样与医生交流</h2><p>您与门诊医生接触的时间</p>
<p>如前所述，当您选择了就诊于三级甲等医院的时候，您也就选择了挂号难和看病难。同时也意味着其他的病人也同样面临挂号难和看病难的问题。为了尽可能的缓解这些问题，一位医生会在出诊时间内看尽可能多的病人，特别是专家，有可能今天额定的挂号量是看20位病人，但是通常会因为外地病人、可怜的病人、重症的病人、有权有势惹不起的病人而加号到30甚至40个。如果上午的门诊是30人，从早上8点看到12点，共4小时，中间没有喝水上厕所的时间，那么平均接待每位病人的时间是4*60/30=8分钟。不错，这就是您凌晨爬起来，裹着军大衣在医院挂号室门外在寒风中等了三个小时以后挂上号，又从上班起等了3小时以后换来的就诊时间，8分钟，平均值。</p>
<p>还不够准确，这8分钟并不是您坐在诊室内和医生交流的时间，在形成初步诊断以后，医生会给您安排一些检查，大多数是当天就能够完成的，所以您拿着化验单检查单做完检查以后回到医生那里，还要再给他看结果。想必您已经注意到了，在您等候过程中，总有些人没拿着挂号条就冲进了医生的诊室，其实那些很可能是做完检查给医生看结果的病人。</p>
<p>也许您会非常好心地帮助医生维持就诊的秩序，坚决制止那些加塞儿的人。我建议尽可能在诊室外进行，也许您一把拽出来的是那个刚刚跑了几层楼憋了半天尿才做完B超想拿给医生看结果的病人，他也只有平均8分钟的时间与医生交流。</p>
<h3 id="与医生说话"><a href="#与医生说话" class="headerlink" title="与医生说话"></a>与医生说话</h3><p>不论您是看中医还是看西医，中医讲究望闻问切，西医讲究问病史和查体。医生都需要和您交谈才能够知道您的疾病是怎样的。我们的身体里布满了各种自检的信号线，它们会将身体的损伤通过它们自己的语言向您的大脑做汇报，比如疼痛、酸胀、无力、烧灼感、异物感。请向医生报告这些感觉，他才能帮助您。</p>
<p>中医不是仅仅切脉就可以摸出您是什么病，西医也不是仅仅靠CT、B超、化验单就可以知道您是什么病。诊断疾病就像是CSI做调查，全面的证据才能指认真凶。</p>
<p>虽然很少，但是确实有一些病人到医生面前一句话不说，手一伸或者脸一挺，医生要先猜出他的主要症状和不舒服，说对了以后，他才继续看病。从前我出门诊，在相对闲适心情也不错的时候会陪着他们玩一会，答对的话他们 会很心服口服的。</p>
<p>另一种人很多，他们会不断的陈述。比如，”我从20年前就开始胸闷了，那正是小平同志南巡的那一年啊，改革开放以来……”有时候这种倾诉是不自觉的，尤其是老年人。老年人必须依靠事件来回忆时间顺序，所以我在《看病前的准备》里写需要事先回忆一下病史，并且记录下来。当倾诉与疾病无关的时候，医生会打断您，或者是您的长辈，这不是不尊重或者态度不好，而是您只有8分钟。</p>
<h3 id="区分事实和判断"><a href="#区分事实和判断" class="headerlink" title="区分事实和判断"></a>区分事实和判断</h3><p>请尽可能学会区分陈述事实和判断，区分这两点是需要极高的知识和智力的，而且稍微不小心即使具有极高知识和智力的人也可能混淆。</p>
<p>如下是事实陈述：“我眼睛红”，“我发烧最高到39度”，“我嗓子疼”</p>
<p>如下是判断陈述：“我眼睛发炎了”，“我发烧很高”，“我上火了”</p>
<p>除非是在精神科或者心理门诊，否则请您尽可能陈述事实。</p>
<p>对于您的感受，请按照不舒服发生的感觉或者表现，以及它们发生的时间来描述，比如“尿尿尿不出来3天”是非常好的描述，而“尿不出来很久了”则仍然没有给医生提供足够的信息。我的建议是</p>
<p>慢性病请精确到年或者月，比如“运动后胸闷5年”，</p>
<p>近1-2年发病的，请精确到月，比如“双眼视力下降6个月”</p>
<p>近1个月内发病的，请精确到日，比如 “尿尿尿不出来3天”</p>
<p>急性病请精确到小时，比如“左眼前发黑看不见东西1小时”。</p>
<p>如果您有数字能够描述您的病情，请尽可能告诉医生数字。比如，“这个星期我的血糖最高到过13”，但如果您仅仅说“这个星期我的血糖很高”，那得看您跟谁比了。对于医生的提问，特别是有“多少”这样的关键词的提问，请尽量以数字回答。不过很遗憾，通常当我问起“您得高血压多少年了？” 80%以上的回答是“很久了”。</p>
<h3 id="疼痛与痛苦"><a href="#疼痛与痛苦" class="headerlink" title="疼痛与痛苦"></a>疼痛与痛苦</h3><p>看病，哪怕是急诊，医生不会马上给您解除痛苦。</p>
<p>疼痛，是大自然赐给人类的礼物，虽然那是无人想要的礼物。疼痛是身体发出的火警，是诊断疾病和判断疾病进展的重要信号，是您生病的身体部分直接向医生的报告。在没有明确诊断之前，医生是不能够帮病人止痛的，就好像没有查明报告火警的位置，我们不可能把火警的电话轻易挂掉。也许您或者您的家人在检查床上疼得死去活来，医生还是会冷漠的用手摸这摸那，甚至使劲压一下问您是否更疼，此时也请告诉医生您的感受。</p>
<p>另外，值得说明的一点，也需要向低年医生强调的一点是，那种显示出痛苦，大声叫嚷的病人，另一方面也说明他们有强大的生命力，而另一类苍白的悄无声息的病人，却更有可能有生命危险。所以当您在急诊看到医生不顾您大声叫嚷的同伴，而去看另一个悄无声息的病人时，不要去阻挡医生。</p>
<h3 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h3><p>如果您收入不高，生活不充裕，请直接跟医生说，相信很多医生会和我一样给您选择相对便宜的药品和治疗。不过同时相对便宜的药物也意味着疗效，特别是副作用的不同。</p>
<p>如果您在路上堵车，找不到停车位，在挂号室门前受冻，坐在门诊等候一上午无所事事，请尽量不要将怨气宣泄在那个为您看病的医生身上，他在上班路上一样堵车，一样找不到停车位，您在挂号室门前受冻的时候，他在病房检查住院的病人，您在门诊等候的时候，他在诊室里奋力看病。</p>
<p>很多时候医生的态度是由科室决定的，越是紧急和危急生命的科室，医生的态度越冷漠甚至恶劣，在急诊室不可能有医生和颜悦色地跟家属说话，有且只有厉声命令家属去做什么。医生不会也不应该把病人当作自己的亲人来对待，事实上很多医生不敢给自己的亲人做手术，因为感情因素可能会影响判断。</p>
<p>希望您能明白，医生的态度与医学水平没有直接的关系。</p>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>新闻或者报纸上出现的某个疾病的治疗“希望”，并不等于真正在医院就可以给您用上。医学是非常保守的学科，一种治疗方法要经过几年、十几年甚至几十年的研究才能确定下来，一种新药上市至少要经过十年的实验和审批才能够进入医院的药房。</p>
<p>即使是经过那么多年的研究确定下来的治疗方案，仍然不可能100%的保证治好您的疾病，绝对不可能。治病和修车不一样，不是您交了钱，就一定可以拿到一辆修好的车。</p>
<p>请您一定记住：花了钱，绝对不可能得到保证治愈，绝对不可能保证没有风险。</p>
<p>万一你得到了医生这样的保证，说明：</p>
<p>医生在安慰你；</p>
<p>跟你说话的压根就不是个医生。</p>
<h3 id="知情同意"><a href="#知情同意" class="headerlink" title="知情同意"></a>知情同意</h3><p>如前所述，您绝对不可能得到保证治愈，绝对不可能保证没有风险。在侵入性的操作治疗或者手术之前，医生会给您看一个知情同意书。这个知情同意书就像是您在购买股票、基金时听到的“入市有风险，投资需谨慎”一样，是要告诉您可能发生的危险的。</p>
<p>知情同意书上写的每一种风险，都是真实发生过的，至少有一个真实的病人，真真切切地经受过这样的痛苦。</p>
<p>知情同意书上写的出现的风险，一旦发生，医生也会继续全力地帮助您。</p>
<h3 id="不证自明的公理"><a href="#不证自明的公理" class="headerlink" title="不证自明的公理"></a>不证自明的公理</h3><p>人都是要生病的。</p>
<p>人都是要病死的。</p>
<p>也许从某种程度上来说，正常人和病人，甚至癌症病人之间的区别，只是5年生存率有所不同而已，而且都小于100%。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>实验：人性是什么？</title>
    <url>/p/108ae8e3.html</url>
    <content><![CDATA[<p><img src="/images/blog_shiyan_cover.png" alt=""></p>
<p>人性是什么？</p>
<p>是对美好的倾慕？</p>
<p>是爱人离去的悲伤？</p>
<p>是信仰背叛的愤怒？</p>
<p>是自己选择结束生命的自由？</p>
<p>是社会的定义？</p>
<p><img src="/images/blog_shiyan_001.png" alt=""></p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>常用SQL语句</title>
    <url>/p/b25a84ab.html</url>
    <content><![CDATA[<h2 id="SQL是什么"><a href="#SQL是什么" class="headerlink" title="SQL是什么"></a>SQL是什么</h2><p>SQL是一种结构化查询语言（或者说一种访问和操作数据库的语言）</p>
<h2 id="SQL的作用"><a href="#SQL的作用" class="headerlink" title="SQL的作用"></a>SQL的作用</h2><p>使用SQL对关系型数据库中的数据进行定义和操作的语言</p>
<p>SQL 面向数据库执行查询 在数据库中插入新的记录 更新数据库中的数据 从数据库删除记录</p>
<p>SQL 可创建新数据库 在数据库中创建新表 在数据库中创建视图</p>
<p>SQL 可以设置表、存储过程和视图的权限</p>
<a id="more"></a>
<h2 id="SQL的特点"><a href="#SQL的特点" class="headerlink" title="SQL的特点"></a>SQL的特点</h2><p>SQL语言简洁，语法简单，好学好用 SQL是一种结构化查询语言</p>
<p>SQLite 存储数据类型</p>
<p>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p>
<h2 id="数据类型-描述"><a href="#数据类型-描述" class="headerlink" title="数据类型 描述"></a>数据类型 描述</h2><p>NULL ( null )值是一个 NULL 值。</p>
<p>INTEGER ( integer ) 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</p>
<p>REAL ( real )值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</p>
<p>TEXT (text)值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</p>
<p>BLOB( blob ) 值是一个 blob 数据，完全根据它的输入存储。</p>
<p>SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。</p>
<h2 id="SQL语句的种类"><a href="#SQL语句的种类" class="headerlink" title="SQL语句的种类"></a>SQL语句的种类</h2><p>SQL语句主要分两部分，DDL DML DQL</p>
<h3 id="DDL-Data-Definition-Langunumber、数据定义语句"><a href="#DDL-Data-Definition-Langunumber、数据定义语句" class="headerlink" title="DDL(Data Definition Langunumber、数据定义语句)"></a>DDL(Data Definition Langunumber、数据定义语句)</h3><p>DDL是我们创建和删除数据库</p>
<p>DDL 创建，删除和修改数据库中的表 （create table或 drop table）</p>
<p>DDL用来创建 和删除索引（搜索键 ）</p>
<h3 id="DML-Data-Manipulation-Langunumber、数据操作语句"><a href="#DML-Data-Manipulation-Langunumber、数据操作语句" class="headerlink" title="DML(Data Manipulation Langunumber、数据操作语句)"></a>DML(Data Manipulation Langunumber、数据操作语句)</h3><p>DML是我们对数据库进行SELECT-获取数据，INSERT INTO-插入数据，</p>
<p>UPDATE-更新数据， DELETE-删除数据的执行语句</p>
<h3 id="DQL（Data-Query-Langunumber、数据查询语句）"><a href="#DQL（Data-Query-Langunumber、数据查询语句）" class="headerlink" title="DQL（Data Query Langunumber、数据查询语句）"></a>DQL（Data Query Langunumber、数据查询语句）</h3><p>可以用于查询获得表中的数据</p>
<p>关键字select是DQL（也是所有SQL）用得最多的操作</p>
<p>其他DQL常用的关键字有where，order by，group by和having</p>
<h4 id="DDL语句的基本使用"><a href="#DDL语句的基本使用" class="headerlink" title="DDL语句的基本使用"></a>DDL语句的基本使用</h4><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p>DROP TABLE IF EXISTS ‘表名’;</p>
<h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><p><code>CREATE TABLE IF NOT EXISTS ‘表名’ ( ‘字段名’ 类型(INTEGER, REAL, TEXT, BLOB)
NOT NULL 不允许为空 PRIMARY KEY 主键 AUTOINCREMENT 自增长,
‘字段名2’ 类型, … )</code></p>
<p>具体使用：</p>
<p><code>CREATE TABLE IF NOT EXISTS ‘t_people’
( “id” INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
“name” TEXT, “number” INTEGER, “height” REAL
)</code></p>
<p>语句说明</p>
<ul>
<li>CREATE TABLE:创建一张表</li>
<li>IF NOT EXISTS:不存在则创建</li>
<li>‘t_people’:表的名称</li>
<li>NOT NULL:不允许为空</li>
<li>PRIMARY KEY:主键</li>
<li>AUTOINCREMENT:自动增加</li>
<li>‘id’ INTEGER:有一个ID字段,类型是INTEGER</li>
</ul>
<h4 id="DML语句的基本使用"><a href="#DML语句的基本使用" class="headerlink" title="DML语句的基本使用"></a>DML语句的基本使用</h4><p>插入数据</p>
<p><code>INSERT INTO ‘t_people’ (name, number, height) VALUES (‘why’, 18, 1.88);</code></p>
<p>语句说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO: 插入数据</span><br><span class="line">‘t_people’: 在哪一个表中插入数据</span><br><span class="line">(数据的字段): 给哪些字段插入数据</span><br><span class="line">VALUES (‘why’, 18, 1.88): 插入的具体值</span><br><span class="line">更新数据</span><br><span class="line">UPDATE ‘t_people’ SET 字段 &#x3D; ‘值’ WHERE 条件判断;</span><br><span class="line">语句说明</span><br><span class="line">UPDATE: 跟新数据</span><br><span class="line">‘t_people’: 在哪一个表中更新数据</span><br><span class="line">SET 字段 &#x3D; ‘值’: 更新怎样的数据</span><br><span class="line">WHERE 条件判断: 更新哪些数据</span><br></pre></td></tr></table></figure>

<p>具体使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE t_people SET name &#x3D; ‘a’ WHERE number &#x3D; 14;</span><br><span class="line">UPDATE t_people SET name &#x3D; ‘b’ WHERE number is 20;</span><br><span class="line">UPDATE t_people SET name &#x3D; ‘c’ WHERE number &lt; 20;</span><br><span class="line">UPDATE t_people SET name &#x3D; ‘d’ WHERE number &lt; 100 and score &gt; 60;</span><br><span class="line">UPDATE t_people SET name &#x3D; ‘ly’;</span><br></pre></td></tr></table></figure>

<p>删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM t_people;</span><br><span class="line">DELETE FROM t_people WHERE number &lt; 30;</span><br></pre></td></tr></table></figure>

<p>语法说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM: 从表中删除数据</span><br><span class="line">t_people : 表名</span><br><span class="line">可以跟条件也可以不跟:不跟表示删除所有的数据</span><br></pre></td></tr></table></figure>

<h4 id="DQL语句的基本使用"><a href="#DQL语句的基本使用" class="headerlink" title="DQL语句的基本使用"></a>DQL语句的基本使用</h4><h5 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h5><p>基本查询(查询整个表格)</p>
<p><code>SELECT * FROM t_people;</code></p>
<p>查询某些字段（查询name和number两个字段）</p>
<p><code>SELECT name, number FROM t_people;</code></p>
<p>通过条件判断来查询对应的数据(年龄大于等于18)</p>
<p><code>SELECT * FROM t_people WHERE number &gt;= 18;</code></p>
<p>通过条件判断来查询对应的数据(名字以i开头),使用like关键字(模糊查询)</p>
<p><code>SELECT * FROM t_people WHERE name like ‘%i%’;</code></p>
<h5 id="计算个数"><a href="#计算个数" class="headerlink" title="计算个数"></a>计算个数</h5><p>计算一共多少列</p>
<p><code>SELECT count(*) FROM t_people;</code></p>
<p>计算某一个列个数</p>
<p><code>SELECT count(number) FROM t_people;</code></p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>升序 ASC (默认是升序)</p>
<p><code>SELECT * FROM t_people ORDER BY number;</code></p>
<p>降序 DESC</p>
<p><code>SELECT * FROM t_people ORDER BY number DESC;</code></p>
<p>按照年龄升序排序,如果年龄相同,按照名字的降序排列</p>
<p><code>SELECT * FROM t_people ORDER BY number,name DESC;</code></p>
<h5 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h5><p>给列起别名(as可以省略)</p>
<p><code>SELECT name AS myName, number AS mynumber FROM t_people;</code></p>
<p>给表起别名</p>
<p><code>SELECT s.name, s.number FROM t_people as s;</code></p>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p><code>SELECT * FROM t_people LIMIT 数字1,数字2;</code></p>
<p>跳过前9条数据，再查询3条数据</p>
<p><code>SELECT * FROM t_people LIMIT 9, 3;</code></p>
<p>跳过0条数据,取5条数据</p>
<p><code>SELECT * FROM t_people LIMIT 5;</code></p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>思考的深度：我为什么写作?</title>
    <url>/p/ad66c3e1.html</url>
    <content><![CDATA[<p>写作就是思考。</p>
<p>想法来得太快，而我的灵魂跟不上，</p>
<p>2018年，有太多故事、太多新闻、太多大事件，在这些刺激中，有种种想法萌生，但大多数的想法总是突然出现由转瞬离去，让我没有时间去思考这些想法，回忆中，经历过不少事情，又好像没经历过什么的真实感，不禁觉得是在梦中。</p>
<p>把想法提取出来，解刨它、观察它、分析它、刺激它、淬炼它</p>
<p>写作，一方面是记录，记录当时自己的想法，人的记忆太不靠谱，不如让文字来记忆。<br>另一方面，在写作的过程中，想法具备了形态，就想人出生到时，每一个文字都是它的形象，正篇文章则是它的全貌，把想法提取出来，解刨它、观察它、分析它、刺激它、淬炼它，这就是思考</p>
<p>看清自己、看清世界</p>
<p>写作就是想慢下来，让自己能看清自己、看清世界。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>寻梦环游记 -- 最终死亡与生命的延续</title>
    <url>/p/b25c254a.html</url>
    <content><![CDATA[<p>皮克斯作品里，总是一个有着些许缺陷，些许倔强，巨大梦想，和巨大孤单的孩子，这是皮克斯画布上永恒的底色，是渺小而无能的人们试图向着无垠世界发出的忧郁呐喊。这一次，来自墨西哥的普通男孩米格尔担起了这份忧郁的代言人，他用皮克斯主人公一贯的懵懂莽撞向着梦想天地发起了挑战，然后在一次次碰壁中告别了无忧无虑的童年，品尝到了成人世界的沉重苦涩。亡灵世界浪漫炫目得像个童话，可背景依然是一半梦幻一半哀伤的淡紫色。天人永隔的忧伤就算是载歌载舞的庆祝也无法完全抹去，更何况，被忘记意味着真正死亡，戳中了人类最深的恐惧。</p>
<a id="more"></a>

<p>有人说，皮克斯这次在讲一个歌颂传宗接代的故事。可被人铭记，哪里是靠繁衍后代就能做到的事情呢？</p>
<p>子孙满堂的赫克多依然遭遇了被家族遗忘的危机，CoCo分明是为了告诫世人，血缘的纽带是不够的，爱才是真正维系你我他的锁钥——这份爱既可以存在于家人之间，更可以存在于千千万万相爱的人与人、人与物、甚至人与世界之间。只要你热爱，就一定会留下爱的印记，像暗号一般，与无穷无尽的时间荒原，等待着懂你的人，拿着解码钥匙，开启关于你的回忆重见天日的时刻。</p>
<p>谁愿意被世界遗忘？再叛逆的浪子，也有渴望落叶归根的瞬间。再淡泊的诗人，也有希冀知音造访的时刻。没有尽头的孤独宇宙，人那脆弱的情感联系，却也成为了我们存在过的证明，你没爱过一草一木一人一物，你又谈何你曾活过？米格尔愿意回归现世，并不是放弃了梦想，而是他发现了比梦想更伟大的是爱，这是他做出的了不起的让步，因为他相信了在生死面前，爱是梦想生长的土壤，爱是梦想最终的归途。</p>
<p>有人问，那如果米格尔放弃了梦想，家人依然没有为他让步，又该怎么办呢？皮克斯用一贯的童话语调坚定地答道，爱一定能诞生奇迹。你包容了爱，爱会归还你更大的包容，正如恨了赫克多一辈子的伊梅尔达，在得知赫克多原来还爱着她和Coco之后，毅然决然地帮他讨还了被骗走的梦想。</p>
<p>也正如8年前的Up，垂垂老矣的Ellie在梦想日记本的最后满怀感恩地写到： Thanks for the adventures.</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>小狗钱钱:得与失</title>
    <url>/p/757d8569.html</url>
    <content><![CDATA[<p>做自己喜欢的事情，同时能够带来金钱的收益，这不是很好的事情吗？</p>
<p>阅读难度：★★★☆☆，话题深度：★★★☆☆</p>
<p>积极得追求生活，并敢于为之付出，知行合一，计算得失，拿得起，放得下，不在贫穷中束缚，不在富裕中迷失；</p>
<p>赚钱不是一件坏事，它可以为自己和他人带来好处。从小开始赚钱的人拥有对依赖思想的抵抗力，不会乐意让别人来养活自己。而且自己赚钱的人不会成为不断膨胀的消费欲望的奴隶</p>
<a id="more"></a>

<h2 id="你想要什么"><a href="#你想要什么" class="headerlink" title="你想要什么"></a>你想要什么</h2><p>完这份清单以后，我突然觉得“富裕”是一件很值得去争取的事情</p>
<p>金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望。</p>
<p>因为这是最关键的。知道如何去实现并不是目前最重要的事情。最重要的是，你真的有这个愿望，否则你一遇到困难就会放弃了。</p>
<p>一个人把精力集中在自己所能做的，知道的和拥有的东西上的那一天起，他的成功就已经拉开了序幕。这也使得一个孩子完全有能力比成人挣到更多的钱。</p>
<p>首先，你应该在自己遇到困难的时候，仍然坚持自己的意愿。当一切正常的时候，每个人都能做到这一点。可是当真正的困难出现的时候，才见了分晓。 只有少数人能坚定不移地贯彻自己的决定。那些非常成功的人，甚至有能力在他们困难最多的时候做出最杰出的成绩。</p>
<h2 id="逆境不可怕"><a href="#逆境不可怕" class="headerlink" title="逆境不可怕"></a>逆境不可怕</h2><p>情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。</p>
<p>在事情进展得非常顺利的情况下，你也应该做这些事情。</p>
<p>当你决定做一件事情的时候，你必须在72小时之内完成它，否则你很可能就永远不会再做了。</p>
<p>欠债的人应当毁掉所有的信用卡。 应当尽可能少地偿还贷款。 应当将不用于生活的那部分钱中的一半存起来，另一半用于还债。最好不要申请消费贷款。 每次借债前问自己：“这真的有必要吗？”</p>
<h2 id="赚钱不是目的"><a href="#赚钱不是目的" class="headerlink" title="赚钱不是目的"></a>赚钱不是目的</h2><p>为什么不能因为做了一件自己喜欢的事情而挣到钱呢？”</p>
<p>你定下了大目标的时候，就意味着你必须付付出比别人多得多的努力。</p>
<p>假如我没有了我的“鹅”，我就总是得为了赚钱而工作，但是一旦我有了属于自己的“鹅”，我的钱就会自动为我工作了。</p>
<h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><p>幸运其实只是充分准备加上努力工作的结果。</p>
<p>钱只令留在那些为之付出努力的人身边</p>
<p>大多数人当然都会说没问题。可并非所有的人都愿意做出必要的努力，因为他们不想付出代价。”</p>
<h2 id="积极"><a href="#积极" class="headerlink" title="积极"></a>积极</h2><p>你记成功日记的时候，你会对自身、对世界，还有对成功的规律做更深入的思考，你就会越来越多地了解自己和自己的愿望，这会使你有能力去理解别人。要彻底了解自己和世界上的所有秘密，是我们无法完全实现的一种理想。但我们可以一步一步地慢慢接近这个理想。”</p>
<p>你朝着积极的目标去思考的时候，就不会心生畏惧。”</p>
<p>恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就越害怕。而当你朝看积极的目标去思考的时候，就不会心生畏惧。</p>
<ul>
<li>确定自己喜欢获得财务上的成功。</li>
<li>自信，有想法，做自己喜欢做的事。</li>
<li>把钱分成日常开销、梦想目标和全鹅账户三部分。</li>
<li>进行明智的投资。</li>
<li>享受生活。</li>
<li>决定一件东西价值多少的惟一因素就是你愿意为它支付多少钱</li>
</ul>
<p>如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情</p>
<h2 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h2><p>基金应该至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那我们可以认为，它在未来也会运作良好。</p>
<p>应该选择大型的跨国股票基金，这种基金在世界各地购买股票，以此分做风险，所以十分安全。</p>
<p>对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终获利最好。</p>
<p>用72除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数。</p>
<p>不要为失去的东西而忧伤，而要对拥有它的时光心存感激。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>战争中没有女性: 一场被忽略战争</title>
    <url>/p/e2a0010e.html</url>
    <content><![CDATA[<blockquote>
<p>我不是在写战争，而是在写战争中的人。我不是写战争的历史，而是写情感的历史。</p>
</blockquote>
<p>S.A.阿列克谢耶维奇,对苏联二战女兵的访谈记录，展示战争中被忽略的一面。</p>
<p>我体验痛苦，品味仇恨，经历诱惑，既有温情又有困惑……我试图理解死亡与杀人之间的区别何在，人性与兽性之间的界限何在。人们怎么能与如此疯狂的想法彼此共存：他们竟然有权去杀死同类？而且是理直气壮的杀戮！</p>
<p>我那时还完全是个小姑娘，一边做梦一边长大，一边长大一边做梦。可是就在我做梦的年龄，战争爆发了。我甚至都有些舍不得让你听……</p>
<p>番号是什么，他全记得。可我不行，我只记得我自己，记得我自己的战争。虽然生活在人群中，但总是形单影只，因为在死亡面前，人永远是孤独的。我能记住的就是那种阴森恐怖的孤独感。”</p>
<a id="more"></a>
<p>我好几次从床上一个跟头栽下来，去抓外套……妈妈的声音让我恢复意识：“我是你的妈妈呀，是妈妈……”她轻声细语地哄我，生怕大声会吓着我……</p>
<p>为啥要有彩色的战争电影啊？战场上一切都是黑色的。要说有另一种颜色，那就是血色，只有鲜血是红色的……</p>
<p>我是在战火中长大成人的。妈妈在家里给我量过身</p>
<p>……我在战争中长高了十公分……</p>
<p>“这是哪儿来的拇指姑娘啊？你在这儿会做什么呢？要不，先回到妈妈身边去，再长长个头吧？” 可是我已经没有妈妈了……妈妈在轰炸中死掉了……</p>
<p>1941年年底，我收到阵亡通知书：丈夫在莫斯科保卫战中阵亡了，他是飞行中队长。我很爱我的女儿，但还是把她送给丈夫的家人抚养，自己就申请上了前线…… 上前线的前一晚……我在女儿的小床边上跪了一整夜……</p>
<p>当我从前线回到家时，妹妹给我看阵亡通知书……我已经被宣布阵亡……</p>
<p>“这个命令立即让我成年了。但我们甚至久久不敢回想那件事……是的，我们是打赢了，但胜利的代价又是什么！多么可怕的代价啊？！</p>
<p>打到了华沙……大家都像是散兵游勇了。用我们的话说，步兵是战争中的无产阶级。我们简直就是爬行前进……不要再多问我了……我真不喜欢战争书籍，不喜欢看英雄书籍……实际上我们都疾病缠身，咳嗽不断，睡眠不够，肮脏不堪，衣衫褴褛。饿肚子更是家常便饭……但是，我们胜利了！</p>
<p>我曾经在部队里做电话接线员。记得最清楚的，就是指挥官在电话中大嚷大叫：“援兵，我要援兵！我要求补充兵力！”每一天都是这样子……</p>
<p>我们游击队有个叫切尔诺娃的，已经怀孕了，还把地雷夹在腰里，紧靠着胎儿噗噗跳的心脏。通过这件事您就可以清楚地知道我们都是些什么样的人了。唉，我们是什么样的人，又何必说？我们从小就受这种教育：祖国就是我们，我们就是祖国。</p>
<p>我自愿站了一整夜的岗，一直到天亮，仅仅是想听听鸟叫。只有深夜能够让我想起以前的那种安宁的生活。</p>
<p>没有幸福感吗？我告诉您：突然在死人堆里发现了一个活着的人，那种感觉就是幸福……</p>
<p>我从炮火下一共救出了四百八十一名伤员。有个新闻记者算了算：整整一个步兵营……我们要把那些比自己重两三倍的男人背在身上，伤员就更沉重了，不但要背人，还要拖走他的武器，他们还有军大衣和大皮靴，都要带走……放下一个，立刻再回去背下一个伤员，又是七八十公斤……每次冲锋就要来回这样五六次，而我自己也就是四十八公斤，芭蕾舞蹈演员的体重。现在简直不能相信……我们那时怎么能做到这一点……</p>
<p>破旧的卡车拉着增援部队上来了，上面都是老人和男孩。发给他们每人两枚手榴弹就投入了战斗，根本没有枪，枪支只能用在正规的战场上。一仗打下来，没有谁还需要包扎抢救……全都战死了……</p>
<p>但我记得，当时我连续四天没睡觉，没坐下来歇口气，每个人都在喊我：“护士……小护士……救救我，亲爱的！……”我从这人跟前跑到那人跟前，有一次我绊倒了，倒在地上立刻就昏睡了过去。但叫喊声又把我惊醒。这时有个军官，是个年轻的中尉，也是伤员，撑起没有负伤的半边身子对他们喝道：“静一静！不许叫，我命令你们！”他理解我，知道我是精疲力竭了，可是其他的人还在叫喊，他们疼得厉害呀：“护士……小护士……”我一下子跳起，拔腿就跑——也不知往哪儿跑，要干些什么。这是我到前线后第一次</p>
<p>我们每个人都是通过自己所从事的事业，通过我们在生活中，或参与事件中的定位去认识人生的。</p>
<p>护士看到的是一种战争，面包师看到的是另一种战争；空降兵看到的是一种战争，飞行员则又是一种战争；冲锋枪排排长看到的也与别人不同……在战争中，每个人都有自己的视野半径。</p>
<p>有时打完一仗，谁也没活下来……热粥热汤全做好了，可就是没人来吃……”</p>
<p>“在前线的姑娘中，我见过很多美人，可是，我们从来没有把她们当女性看。尽管在我看来，她们都是相当出色的姑娘，但是我们一直把她们当作好朋友看待——是她们把我们从战场上背回来，救活我们，帮助我们康复。我两次负伤都是她们给背回来的。我怎么能对她们有非分之想呢？难道您能嫁给自己的兄弟吗？我们那时候都叫她们是小妹妹……”</p>
<p>这些正是我们实际上的为人，我们是由什么东西、什么材料构成的呢？我想要弄明白的是，这种材料为什么会那么坚硬。我就是为此来到这里的……<br>当我们抬起担架上的女孩 朋友，定要记住那淡淡的秀脸</p>
<p>“我只有一件事感到遗憾：我过早下命令叫全体成员离开燃烧的坦克，本来可以再打掉一辆德国坦克的，而小伙子们后来还是都牺牲了……” 这就是他一生中唯一的憾事……</p>
<p>在同一个人身上存在着两种真实：一种是被强行隐藏于地下的个人真实，还有一种是充满时代精神的整体真实，散发着报纸的气味。前一种真实很难抵抗后一种庞大势力的冲击。譬如，如果房间里除了讲述人之外，还有一些亲朋好友或者邻里街坊，那她就会讲得缺乏激情、缺乏可信度，远不如和我单独待在一起的时候。于是她的讲述就成了一种公共谈话，对观众的演讲，就不可能深入到她私人的体会中去，结果我发现的是一种坚固的内心自我保护意识和自我审查，而且还不断地进行修正。甚至形成了这样一个规律：听者越多，故事越枯燥无味，越顾左右而言他。<br>但我还是不能忘记在她家的厨房里无拘无束喝茶的情景。她一个人讲，我们两人一起哭。</p>
<p>“我们没有能力忘记，也没有权利忘记。”</p>
<p>这些你都理解吗？现在能够理解了吧？我希望你理解我的感情……没有仇恨你是不会想去开枪的。这是战争，而不是打猎。</p>
<p>我第一次穿上连衣裙时，泪水忍不住哗哗流。在镜子里都认不出自己了，要知道，我们穿了四年男人的长裤啊！我本来可以告诉别人，我受过伤，给震坏了。可是如果讲出来，谁还会给我工作？谁还会娶我？于是我们都像鱼儿一样沉默，谁都不承认自己在前线打过仗。</p>
<p>回忆是很痛苦的，但是不去回忆，就更加不能忍受。”</p>
<p>什么是最难忘的？ 最难忘的，是讲述者们那种轻轻的、充满惶惑的声音。人们面对自身感到惊奇，面对身边的事情感到困惑。</p>
<p>于是，我硬是用牙齿把伤员的烂胳膊啃了下来，然后马上包扎……我做着包扎，那伤员还在催促：“护士，快点呀，我还要打仗呢……”他还是个急性子……</p>
<p>我们身体机能全都变了，整个战争的几年中我们都不是女人了，失去了女性的那事情……每个月来的那事……呶，您是明白的……战争结束后，有些人就失去了生育能力。</p>
<p>我们从来都受到这样的教育，说我们的国家如果没有了，我们就会什么都没有了。我们自小就学习热爱国家，赞美国家。一旦战争爆发，我们必须做些什么去帮助国家。需要护士，我们就去做护士；需要高射机枪手，我们就去开高射机枪。</p>
<p>那么，祖国又是如何欢迎我们的？我真是忍不住要哭出来……四十年过去了，说起来还是面孔发热。男人都沉默不语，而女人们，就都冲着我们大喊大叫：“我们知道你们在前方干的那些事！用你们的年轻身体去勾引我们的男人，前线的婊子！穿军装的母狗……”侮辱的话语五花八门……俄国的语言词汇很丰富……</p>
<p>如果谁参加过战争，他就会明白，分开一天，这是怎么回事。哪怕只是一天……</p>
<p>现在我的家里就是没有任何红色，绝不能有红色。人的血液是非常鲜艳的，不管在大自然中还是在画家的作品中，我都没有见过这样鲜艳的颜色。只有石榴汁有些相似，但也不尽相同。像那种成熟的石榴……</p>
<p>一年之后，我们的爸爸也回来了。爸爸带回来一大堆奖章，我也带回来一枚勋章和两枚奖章。但是在我家里，名次应该是这样排列的：大英雄是妈妈。她保护了全家，既保护了家人也保护了房子，那是一场那么可怕的战争啊。爸爸从来都不佩戴任何勋章或者军功章，他认为在妈妈面前夸耀战功是很羞愧、很尴尬的，因为母亲没有任何奖章……</p>
<p>人类从前是互相仇视，然后又是互相残杀。对我来说，这是最不可理解的，这都是些什么人啊？而这正是我们，是我们自己……</p>
<p>这就是斯大林格勒……人类最惨烈的战役，最最残酷的厮杀。告诉你吧，我最亲爱的……人不可能有两颗心，一颗是为了恨，另一颗是为了爱。每个人都只有一颗心，而我永远都在想的，是如何保护我的这颗心。</p>
<p>我对祖国履行了我的责任，可我却因为自己打过仗而忧伤，为我所知道的一切而难过……</p>
<p>我不是在写战争，而是在写战争中的人。我不是写战争的历史，而是写情感的历史。</p>
<p>我在建造一座感情的圣殿……用我们的愿望、失望和梦想，用我们曾经有过，却又可能被遗忘的那些感情，去建造一座圣殿。</p>
<p>但是有人以胜利的历史偷换了战争的历史。</p>
<p>他们执着于理想，将理想深深根植于自己内心，决不妥协——国家成了他们的宇宙，取代了他们的一切，甚至生命。他们无法摆脱伟大的历史，无法和那段历史告别，无法接受另外一种幸福，不能像今天的人们这样，完全潜入和消失于个体生活中，把渺小看成巨大。</p>
<p>消费主义就是自由之王。巨大的阴暗，欲望的阴暗，蛰伏于人类生命中的本能，而我们对于这种生活只有模糊的认识。在整个历史中，人们只是活过了，而不是生活过了。现在已经不再需要军事经验，它应该被遗忘。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://movie.douban.com/subject/26356495/" target="_blank" rel="noopener">女狙击手</a></p>
<p><a href="https://manhua.dmzj.com/zhanzhengzhongmeiyounvrendemianrong/" target="_blank" rel="noopener">战争中没有女人的面容</a></p>
<p>洛塔·施瓦德：战火中的女性</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么写读后感</title>
    <url>/p/99ab8148.html</url>
    <content><![CDATA[<blockquote>
<p>学而不思则惘，思而不学则怠</p>
</blockquote>
<p>读书破万卷,然后呢？成为百科全书吗？</p>
<p>读书只是手段，只是方式，最终目的是为了思考，沥心见慧，而不只是故事记忆和情感共鸣。</p>
<p>在积累一定数量后，是否对知识有一定的体系认证，能否构建自己的认知体系，在对事物的观察能否更有深度地理解，在评价时有能不能从更多的角度进行解析？</p>
<p>通过文字，让大脑中纷飞的想法有落地生根的可能，让记忆化作记录，让记录激发思考，去验证、猜想、扩展。。。。。。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>所谓技术文档（一）</title>
    <url>/p/9aebf26c.html</url>
    <content><![CDATA[<p>弄清读者是谁：给最终用户（小白）的、给系统维护人员、给后来的技术人员交接的的文档肯定不一样，给小白的重截屏，给维护的重操作，交接的重原理。</p>
<p>切换“无知者”模式：很多东西是在做项目的过程中试错积累出来的。做着做着：这么干原来不行啊，应该这样这样，改设计！做着做着：哎呀，原来有这个问题没有考虑到，现在加进去，改设计！做着做着：哦？什么？客户要改需求？好吧，我改设计！这样下来大型的IT项目做到最后，和最开始的设计已经大相径庭了，按照原来设计的思路来写文档肯定是不行的，按照时间顺序把修改加上会更加混乱。写文档的时候需要切换到“无知者”模式，把自己想象成一个刚刚接受项目要开始设计的人，面对已知的这些“新要求”和对技术全新的理解，重新写一份文档，这样才能脉络清晰，可读性高。</p>
<p>遵循标准构架：大型项目牵扯的东西多，有实际的设备有虚的概念，有用户界面也有关键性配置，杂七杂八什么都有，如果不按照一个标准构架来写文档，很容易就眉毛胡子一把抓。这时候就一定要找一个标准构架，比如OSI七层构架，TCP-IP四层构架等等，从上到下或者从下到上，写着也方便，看着也舒服。</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>时间里的人</title>
    <url>/p/350390c5.html</url>
    <content><![CDATA[<p>纽约时间比加州时间早三个小时，</p>
<p>New York is 3 hours ahead of California,</p>
<p>但加州时间并没有变慢。</p>
<p>but it does not make California slow.</p>
<p>有人22岁就毕业了，</p>
<p>Someone graduated at the age of 22,</p>
<p>但等了五年才找到好的工作！</p>
<p>but waited 5 years before securing a good job!</p>
<p>有人25岁就当上CEO，</p>
<p>Someone became a CEO at 25,</p>
<p>却在50岁去世。</p>
<p>and died at 50.</p>
<p>也有人迟到50岁才当上CEO，</p>
<p>While another became a CEO at 50,</p>
<p>然后活到90岁。</p>
<p>and lived to 90 years.</p>
<p>有人依然单身，</p>
<p>Someone is still single,</p>
<p>同时也有人已婚。</p>
<p>while someone else got married.</p>
<p>奥巴马55岁就退休，</p>
<p>Obama retires at 55,</p>
<p>川普70岁才开始当总统。</p>
<p>but Trump starts at 70.</p>
<p>世上每个人本来就有自己的发展时区。</p>
<p>Absolutely everyone in this world works based on their Time Zone.</p>
<p>身边有些人看似走在你前面，</p>
<p>People around you might seem to go ahead of you,</p>
<p>也有人看似走在你后面。</p>
<p>some might seem to be behind you.</p>
<p>但其实每个人在自己的时区有自己的步程。</p>
<p>But everyone is running their own RACE, in their own TIME.</p>
<p>不用嫉妒或嘲笑他们。</p>
<p>Don’t envy them or mock them.</p>
<p>他们都在自己的时区里，你也是！</p>
<p>They are in their TIME ZONE, and you are in yours!</p>
<p>生命就是等待正确的行动时机。</p>
<p>Life is about waiting for the right moment to act.</p>
<p>所以，放轻松。</p>
<p>So, RELAX.</p>
<p>你没有落后。</p>
<p>You’re not LATE.</p>
<p>你没有领先。</p>
<p>You’re not EARLY.</p>
<p>在命运为你安排的属于自己的时区里，一切都准时。</p>
<p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>时光河流中的水滴</title>
    <url>/p/1f552ee9.html</url>
    <content><![CDATA[<h1 id="记录时光的影子"><a href="#记录时光的影子" class="headerlink" title="记录时光的影子"></a>记录时光的影子</h1><p>今天在网络上，逛到了博客 <code>读写错误</code>，博主没什么特定主题，话题和文章都很随性,但在翻阅博客列表时，发现博主居然在2003年开始写博客到现在！到我写下这篇文章为止已经连载16年。</p>
<p>第一次遇到维护这么久的个人博客，翻阅时就好像打开时空胶囊，看到了过去的某段残影，如腾讯收购 Foxmail就记录了腾讯收购Foxmail的事件，看看博主的猜想不禁感慨，谁想到这是中国互联网巨无霸微信的开始？</p>
<p>独立的blog，也许就这么简单，当写给自己看，也不需要担心平台倒了，就记录着时光的点滴，等待着某个时刻来回忆吧。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>最好的告别：衰老</title>
    <url>/p/70388567.html</url>
    <content><![CDATA[<p>现代社会生活质量的提高和医学的进步让我们需要面临“活得很老该怎么办”的问题。</p>
<a id="more"></a>

<p>首先，人们不能解决的是家庭结构的问题。Gawande提出，在其祖先生活的印度，老人是由后辈照顾的，老人因为对财产有支配权，外加上年迈带来的德高望重，基本上可以活得很自由、很高兴。但在现代社会，这种情况已经开始逐渐变少。大多数人和长辈一起生活是因为没有别的选择，以及社会风气。</p>
<p>和长辈同处是有代价的，比如长辈固执而执意发号施令，Gawande就说自己的叔伯在照顾爷爷时就承受了不少压力。在可以远离父母也能自食其力，同时社会接受父母子女分居时，大多数人是希望自立门户。</p>
<p>医疗的目的一直是治愈疾病、阻止死亡的发生。正是这种精神让现代医疗将人类生命延长一倍。然而，现在最新的医疗技术已经不再像过去一样，几乎在面对所有疾病时，能够将人类的生命延长许多。而且，这些治疗方案往往是昂贵以及痛苦的。具有讽刺意义的是，人们因为过去百年中医学的突飞猛进往往意识不到这一点，他们往往认为最新、最激进的治疗方案才是最好的，并且认为所有疾病都是可治愈的。这样的后果是病人在受了许多罪后往往并不能将自己的生命延长。</p>
<p>一个理智的人在死亡降临的时候还是无法舍弃生的欲望。</p>
<p>现代化并没有降低老年人的地位，而只是降低了家庭的地位。它赋予人们，包括年轻人和老年人，一种更多的自由、自主、自助的生活方式。</p>
<p>老年不是一场战斗，而是一场屠杀。</p>
<p>当生命的脆弱行凸显出来时，人们的日常目标和动机会彻底改变。至关重要的是观念，而不是年龄。</p>
<p>自主的价值······在于它所产生的责任：自主使得我们每个人负责某中连贯的独特的个性感、信念感和兴趣，塑造自己的生活。它允许我们过自己的生活，而不是被生活所驱使，这样，我们每个人都能够在权利框架允许的范围内，成为他塑造的那个自己。</p>
<p>什么时候应该努力医治，什么时候应该放弃治疗？</p>
<p>死亡通常是一连串毁灭的过程，本质上会使死者的人性崩解，在我见过的死亡中，有尊严的并不多。</p>
<p>善终服务试图提供一种死亡方式的新范式。虽然并不是每个人都接受其主张，但是，那些接受的人在为我们这个时代展示一种死亡艺术。这么做代表着一种抗争–不仅仅是抗击痛苦，同时也是抗击医学治疗看似不可阻挡的势头。</p>
<p>接受个人的必死性，清楚了解医学的局限性和可能性，这是一个过程，而不是一种顿悟。</p>
<p>把今天过得更好，而不是为了未来牺牲现在。</p>
<p>在年老和患病的时候，人至少需要两种勇气。第一种勇气是面对人终有一死的事实的勇气–寻思真正应该害怕什么、可以希望什么的勇气。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>方法论：请停止无效努力</title>
    <url>/p/e9a277f0.html</url>
    <content><![CDATA[<h1 id="序言-用更有效的方式去努力"><a href="#序言-用更有效的方式去努力" class="headerlink" title="序言 用更有效的方式去努力"></a>序言 用更有效的方式去努力</h1><p>脱离了对自己的了解、对事情的判断、对未来的信心、对目标的渴望，精神是永远不会有的。相反，有了长远的策略，每件事情都有正确的方法去做，在过程中还能不断找到发挥自身优势的机会，精神自然会来。</p>
<a id="more"></a>

<h1 id="第一章-人人都有天赋：如何快速找到你的天赋优势"><a href="#第一章-人人都有天赋：如何快速找到你的天赋优势" class="headerlink" title="第一章 人人都有天赋：如何快速找到你的天赋优势"></a>第一章 人人都有天赋：如何快速找到你的天赋优势</h1><p>你没钱，真的不是因为不努力——找到正确的定位才是关键</p>
<p>根据这个模型，你个人能够创造出多大的价值，离不开三大内在要素：</p>
<p>第一个要素，知识和技能。</p>
<p>第二个要素，能力。比如学习和思考能力、人际交往能力等等。</p>
<p>第三个要素，天赋。包括潜在能力、性格特质、动机、价值观</p>
<h3 id="外在因素也包括三个方面：出身、选择、运气。"><a href="#外在因素也包括三个方面：出身、选择、运气。" class="headerlink" title="外在因素也包括三个方面：出身、选择、运气。"></a>外在因素也包括三个方面：出身、选择、运气。</h3><p>出身是你拥有的原始资本，选择是让你重新获得资本的机会，而运气，则是你选择之后能否如愿的随机因素。</p>
<p>会发现，这六个因素里面，有些是无法改变的，比如出身和运气，而另一些是可以人为改变的，比如知识、技能、能力。</p>
<p>复杂一点的是天赋和选择。天赋本身几乎不能改变，但是你可以通过发掘自己的天赋、选择与之匹配的工作，从而最大化地利用它。所以，我们暂且也认为它是部分可变的。</p>
<p>另外，选择大于努力这句话我完全同意，可问题是，当你选择的时候，并不知道哪个选择是对的。</p>
<p>刨除不可变因素，我们可以把个人所选择的定位（也可以称之为增值方式）分成五种不同的类型：投机型、知识型、技能型、能力型、天赋型。需要注意的是，在识别你的价值类型时，并非看你有没有知识、能力，而是要看你的差异化因素在哪里。</p>
<h3 id="差异化因素才是你的价值所在。"><a href="#差异化因素才是你的价值所在。" class="headerlink" title="差异化因素才是你的价值所在。"></a>差异化因素才是你的价值所在。</h3><p>不能内化为能力的知识，是很难为你增加财富的。不能结合思维能力的知识，价值是很低的。</p>
<p>技能不行，能力可以弥补，但能力不行，技能无法代替。能力型的人，天花板往往是他们自己，而不是外在的限制。</p>
<p>想要获得更高的回报，最优的选择有两个，一是提升能力，二是不断认识自己、发掘自己的天赋。</p>
<p>总之，如果想要收入更高，你需要：</p>
<p>1 在学习新知识的时候，内化成能力。</p>
<p>2 有技能的，需要找到稀缺技能，当然，这种稀缺性只能维持一段时间，一旦供求达到平衡之后，收入就会下降。</p>
<p>3 能力，才是长久需要提升的，因为世界变化太快，只有能力是各种岗位间通用的。</p>
<p>4 同时，要不断尝试和总结，发现自己的天赋。</p>
<h3 id="精彩提炼"><a href="#精彩提炼" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 你个人能够创造出多大的价值，离不开三大内在要素：第一个要素，知识和技能。第二个要素。能力，比如学习和思考能力、人际交往能力等等。第三个要素，天赋，包括潜在能力、性格特质、动机、价值观。</p>
<p>2 决定你最终能够收获多少回报的，除了内在因素之外，还有三大外在因素：出身、选择、运气。</p>
<p>3 个人价值定位有五种不同的类型：投机型、知识型、技能型、能力型、天赋型。</p>
<p>4 在五种不同的价值定位类型中，最优的选择有两个，一是提升能力，二是不断认识自己、发掘自己的天赋。</p>
<p>5 大多数人没有采取最优选择，而是将自己定位在知识型和技能型，原因是：第一，知识和技能型最容易提升。第二，受限于岗位的定位。</p>
<p>6 如果想要收入更高，你需要在学习新知识的时候，内化成能力。有技能的，需要找到稀缺技能。当然，这种稀缺性只能维持一段时间，一旦供求达到平衡之后，收入就会下降。能力，才是长久需要提升的，因为世界变化太快，只有能力是各种岗位间通用的。同时，要不断尝试和总结，发现自己的天赋。</p>
<h2 id="努力，到底是不是天赋"><a href="#努力，到底是不是天赋" class="headerlink" title="努力，到底是不是天赋?"></a>努力，到底是不是天赋?</h2><p>所谓天赋，指的是某种天生的特性，让一个人可以在同样起点的情况下，比一般人更加快速地成长。</p>
<p>天赋包括能够帮助一个人更快速成长的所有天生特性。而一个人要能够更快地成长，其实需要两个要素，一是能力方面的天赋，也从这个角度来说，“努力也是一种天赋”这句话就有其合理性了。因为，努力代表着一种意愿，背后是由性格、动机、价值观等等来决定的，而这些都是天生的特性。</p>
<p>首先，事情的结果取决于两大方面，一是内部因素，即你做了什么，二是外部因素，即你的运气等。</p>
<p>一个人的行为取决于三个要素：知、能、愿。</p>
<p>能力和意愿都跟天赋有很大的关系，所以继续细分。这里，我将能力和意愿，分别分成先天和后天两部分。也就是说，能力取决于先天的能力天赋以及后天的刻意练习。而意愿，取决于先天的意愿天赋以及后天的环境和经历。</p>
<p>另外，关于刻意练习，我仍然将它继续细分，分为练习的方法以及练习的热情。方法是说，你知道如何进行刻意练习。而热情是说，你是否对刻意练习充满热情，因为刻意练习是一项艰辛的事情，是一个不断行动、犯错、反馈、调整的过程，我们后面会介绍。当然，倘若没有足够的热情，我们也是很难持续下去的。<br>综合这两个维度来看，你的天赋需要用在这样的领域：第一，这个领域内，是否有这项天赋，是否会导致较大的差异化；第二，该天赋是该领域的关键成功要素。</p>
<p>热情并不来源于爱好。根据自我决定理论，热情来源于自主感、胜任感、归属感。</p>
<p>不光在如何定位自己这方面，我们会盲目模仿、与他人比较、浪费自己的天赋。</p>
<p>是这样的人选择了这样的职业吗？很大程度上不是，而是职业所处的环境改变了这些人。</p>
<p>一个内容单一且每天重复的工作，会导致你主动思考能力的下降；一个流程非常规范和标准的工作，会导致你挑战和克服困难精神的丧失；一个每天跟机器打交道的工作，会导致你社交能力的减弱；一个不鼓励自主学习、主动担责的工作，会导致你失去努力的内在动力……这些，都是后天工作环境对一个人能力的影响。</p>
<p>所以，你选择怎样的工作环境，也就决定了你的天赋是否可以充分发挥作用。</p>
<h3 id="精彩提炼-1"><a href="#精彩提炼-1" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 每个人都有自己的相对天赋，正确运用天赋，可以让我们事半功倍。<br>2 天赋包括能力天赋和意愿天赋，所以，在总结和反思自己的时候，要回顾这两点。<br>3 能力天赋只代表潜力，要转化为能力，还需要刻意练习。<br>4 正确运用天赋需要做到：找到天赋差异性大且决定性强的领域，掌握正确的刻意练习的方法，找到能有更多自主感、胜任感、归属感的工作以维持热情，坚定地拒绝那些世俗眼中的光鲜追求，避免选择那些容易埋没天赋的工作。</p>
<p>别再挥霍你的天赋了——觉得自己没天赋，是因为你没方法</p>
<h2 id="天赋有四个特征，简称为“SIGN”："><a href="#天赋有四个特征，简称为“SIGN”：" class="headerlink" title="天赋有四个特征，简称为“SIGN”："></a>天赋有四个特征，简称为“SIGN”：</h2><p>特征一，自我效能（Self-efficacy）。对自己可以完成某项工作或任务的自信程度。</p>
<p>特征二，本能（Instinct）。当你还没开始做这件事的时候，你就迫不及待地想要开始了。</p>
<p>特征三，成长/专注（Growth）。当你做这件事的时候，你充满好奇，十分专注，时间过得很快。</p>
<p>特征四，满足（Needs）。做完这件事之后，就算感到疲劳和困倦，你依然会有满足感。</p>
<p>花时间去最大化你的天赋，比花时间去弥补自己的劣势，要有效得多。这是我们应用天赋的最关键策略。</p>
<h3 id="什么是正确的刻意练习方法呢？它必须符合四大特征："><a href="#什么是正确的刻意练习方法呢？它必须符合四大特征：" class="headerlink" title="什么是正确的刻意练习方法呢？它必须符合四大特征："></a>什么是正确的刻意练习方法呢？它必须符合四大特征：</h3><p>第一，在学习区练习</p>
<p>我们的学习，一般有三个区域：一个是舒适区，就是你非常熟练、几乎是下意识就可以完成的事情；中间是学习区，就是有一些挑战，可以通过努力掌握的；最外层是恐慌区，远远超出你的能力，当前很难掌握。如果用比喻的话，舒适区就像是右手随意写字，学习区是用右手学写某种字体的字，而恐慌区是让你直接用左手写那种字体出来。因此，你需要反思，你现在的8小时工作内容中，分布在各个区域的比例有多少？如果在学习区的都不到1小时，那你就需要考虑一下了。因为，长此以往，你工作八年，只相当于别人工作一年。</p>
<p>第二，大量重复</p>
<p>第三，持续获得有效反馈。如果你的目标是升职为总监/经理，那么，让你的大脑先升职。</p>
<p>第四，专注</p>
<h3 id="精彩提炼-2"><a href="#精彩提炼-2" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 天赋包括能力天赋和意愿天赋，所以真正的天赋是让你感觉自己更强大的东西。</p>
<p>2 天赋有四个特征，分别是自我效能、本能、成长/专注和满足。</p>
<p>3 探索天赋有三个方法：写日记记录内在感受，问自己有关自我效能、本能、成长/专注和满足的问题，以及问别人关于自己的特质。</p>
<p>4 将弥补劣势的时间，重新分配到最大化你的天赋上面，才能事半功倍。具体方式是，思考三个可能性：停止、合作、替代。</p>
<p>5 刻意练习是指：为了掌握某种能力，有意识地付出努力，投入到某项活动中。</p>
<p>6 正确的刻意练习要符合四大特征：在学习区练习、大量重复、持续获得有效反馈、专注。</p>
<p>7 学习区位于舒适区和恐慌区中间，是刻意练习的最佳区域。</p>
<h1 id="第二章-学习如何学习：如何将知识转化为能力"><a href="#第二章-学习如何学习：如何将知识转化为能力" class="headerlink" title="第二章 学习如何学习：如何将知识转化为能力"></a>第二章 学习如何学习：如何将知识转化为能力</h1><p>学习的正确姿势——靠意志力的学习，都是耍流氓</p>
<p>我们先抛开学习，思考一个问题：如果让你做一件事情，能够持续而且快乐，会是什么样的事情呢？其实不外乎三点：喜欢、擅长、有价值。</p>
<p>从这三点出发，我们就可以总结出，如何让我们快乐且有效地持续学习。我概括为四点：</p>
<p>第一，按需学习：学习的东西是否对现阶段有价值。</p>
<p>第二，调整心态：对待学习的态度，决定了我们是否会喜欢它。</p>
<p>第三，提升元认知策略：每个人有不同的学习风格，了解自己的风格并且调整学习方法，能够大大提高学习效率。</p>
<p>第四，正确犯错：人类的大脑是从犯错中学习的，能否从错误中学习，决定了我们从学习中获得的是成就感还是挫败感。</p>
<p>成人教育领导人物马尔科姆·诺斯尔斯提出了成人学习的四个特点，区别于小孩子的学习第一，自愿；第二，经验；第三，自主；第四，行动。所以，综合以上四点，在选择学习内容的时候，我们需要遵循的原则是：</p>
<p><strong>原则一——有用：对我们现阶段要有用的，这个用处不一定是工作或者赚钱，也可以是让人放松等等。</strong></p>
<p><strong>原则二——匹配：跟我们的经验背景相匹配的，不会太粗浅，也不会太深奥。</strong></p>
<p><strong>原则三——参与：能够有参与感的，说教式的学习最好不要参与。原则四——应用：可以应用到行动中去的，</strong></p>
<p>跟我们的工作、生活相结合的。</p>
<p>其中，对于“有用”这个原则，我们还需要注意两点：</p>
<p>第一，长期有用的东西，需要把它转化成短期有用：</p>
<p>第二，大的学习内容，需拆分出有用的组成部分。</p>
<p>学习能力强的人，除了智力和知识储备方面存在优势外，更重要的是，他们能够了解和不断总结自己的学习风格、明确优劣势、进而调整学习方法——这种能力我们称为元认知，它是“对于认知的认知”。</p>
<p>那些元认知能力强的人是如何学习的呢？</p>
<p>理查德•克拉克在1998年提出了五种元认知技巧，或许可以让我们借鉴：</p>
<p>技巧一，<strong>筹划</strong>——学习新知识时需要分析出必须要做的事情，比如研究一个行业，重点看其宏观环境、如何盈利、人才市场等等。并且，会据此制定计划，与什么人聊天、如何寻找资源、大概什么时间去做。而元认知差的人没有特别的规划，可能就一头扎进去了。</p>
<p>技巧二，<strong>选择</strong>——元认知能力强的人可以从杂乱无章的资料里筛选出关键要素，并时刻记住自己的目标。元认知比较差的人，通常做法是觉得每样信息都很重要，都要去学，于是很快被信息淹没。</p>
<p>技巧三，<strong>联系</strong>——寻求新旧知识之间的联系。</p>
<p>技巧四，<strong>调整</strong>——分析与理解新的知识，抛弃过去有用但现在不需要的信息。</p>
<p>技巧五，<strong>追踪</strong>——能理解与应用新的知识，明确局限性，不会生搬硬套。</p>
<p>通常学习有三层：知识层：学习某项内容，会某个知识点；能力层：超越具体的学习内容，举一反三，应用到解决问题中；价值观层：建立整体的心智模型和价值体系。</p>
<p>倘若我们每次犯错后都能找到原因，并在下次有所进步，那么在犯错中感受到的就是快乐，而非挫败了。</p>
<h3 id="精彩提炼-3"><a href="#精彩提炼-3" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 我们的学习大多是“T”字型的：在一个领域精通就可以，而其他大多数领域，学习重点更在于了解以及建立跨领域间的联系。</p>
<p>2 快乐有效的学习，要满足三点：学自己喜欢的东西、能够学得好、能给我们带来价值。</p>
<p>3 在学习过程中，需要做到：按需学习、调整心态、提升元认知策略、正确犯错。</p>
<p>4 按需学习：选择对我们有用、与历史过往经历匹配、能让我们参与其中、并能够应用的学习内容。长期有用的东西，需要转化成短期有用；一个大的学习内容，需要拆分出对我们最有用的部分，并集中学习这个部分。</p>
<p>5 调整心态：不要试图用意志力坚持学习，而要从学习本身寻求快乐。把诱惑隔离开，渐渐会学习养成习惯。学习一样东西，不需要1万小时，20小时足矣。</p>
<p>6 提升元认知策略：每个人的认知方式不同，知道自己的认知优劣势，才能够制定适合自己的学习方法。通过筹划、选择、联系、调整、追踪的五大技巧，来提升自己的学习效率。</p>
<p>7 正确犯错：人类的大脑是从犯错中学习的，能否从犯错中进步，决定了犯错这件事获得的是成就感还是挫败感。</p>
<h2 id="建立自己的知识体系——为什么你有海量信息，却解决不了现实问题"><a href="#建立自己的知识体系——为什么你有海量信息，却解决不了现实问题" class="headerlink" title="建立自己的知识体系——为什么你有海量信息，却解决不了现实问题"></a>建立自己的知识体系——为什么你有海量信息，却解决不了现实问题</h2><p>知识的学习：具体某个领域的、用来阐述道理或解释事情或完成任务的相关信息。能力的学习：这里的能力是广义的，既包括特定领域的技能，比如打篮球、写程序、画插画，也包括超越具体领域的通用能力，比如思维、沟通、计划等。价值观的学习：整体的心智模型和价值体系，也就是，对事物的判断。</p>
<p>一个完整的知识体系，应该包括三个要素：有知识架构、有知识内容、内容之间有联系。</p>
<h3 id="如何建立出这种知识体系呢？可以遵循以下方法："><a href="#如何建立出这种知识体系呢？可以遵循以下方法：" class="headerlink" title="如何建立出这种知识体系呢？可以遵循以下方法："></a>如何建立出这种知识体系呢？可以遵循以下方法：</h3><p>方法一，明确自己的学习背景</p>
<p>你刚开始学习一个领域的时候，首先要明确：你为什么学习这个领域？将来打算如何应用？这个领域跟你现有的其他知识是什么关系？</p>
<p>方法二，通过各种可靠渠道建立架构</p>
<p>在建立知识架构的时候，什么是靠谱且高质的信息源呢？答案是：专家、专业网站、经典书。<br>就很难建立起架构。一方面，趣味书籍往往选取某个细分角度，无助于你认识全貌，另一方面，为了保持趣味性，必然在一些难懂的知识上进行模糊处理。</p>
<p>方法三，不断修正自己的知识架构</p>
<p>方法四，在架构中填充知识</p>
<p>方法五，将知识之间、知识与问题之间进行关联</p>
<p>如何让知识和问题链接起来呢？答案是：二者都向对方靠。</p>
<p>知识向问题靠：每看到一个知识的时候，就去思考这个知识可以用来解决什么问题。</p>
<p>问题向知识靠：遇到任何问题的时候，不要抛开过去的知识坐着苦想，而是回到你的知识体系，去查看哪个能帮你解决问题。</p>
<h3 id="精彩提炼-4"><a href="#精彩提炼-4" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 技术和互联网如此发达，所以我们的学习，应该不再局限于现有知识，而更多的是探索未来的能力；不再局限于知识本身，而更多的是这些知识可以解决何种问题；不再局限于某个领域，而更多的是知识之间的联系。</p>
<p>2 从学习来说，分为知识、能力和价值观三类学习。这三类内容的学习方式是不同的，倘若我们没有意识到这种不同，就会出现如下误区：误区一：知识零散化，导致信息饥渴症以及信息过载。误区二：只学价值观，忽略知识和能力。误区三：将知识与能力割裂。</p>
<p>3 一个完整的知识体系，应该包括三个要素：有知识架构、有知识内容、内容之间有联系。</p>
<p>4 建立知识体系的步骤：明确自己的学习背景、通过各种可靠渠道建立架构、不断修正自己的知识架构、在架构中填充知识、将知识之间以及知识与问题之间进行关联。</p>
<h2 id="第三章-构建思维能力：让烦恼变成真正有效的思考"><a href="#第三章-构建思维能力：让烦恼变成真正有效的思考" class="headerlink" title="第三章 构建思维能力：让烦恼变成真正有效的思考"></a>第三章 构建思维能力：让烦恼变成真正有效的思考</h2><p>正确定义问题，减少无用功——认清六个问题，节省80%的无用功</p>
<p>爱因斯坦说：“如果给我1个小时解答一道决定我生死的问题，我会花55分钟来弄清楚这道题到底是在问什么。一旦清楚了它到底在问什么，剩下的5分钟足够解答这个问题。”</p>
<p>我们的工作，大致可以分为两种类型，一种是过程导向型，一种是结果导向型。</p>
<p>我们大部分人的工作，其实都是结果导向型，如果想要多产出价值，除了多花时间以外，还有两种方法，一种是做更高价值的事，另一种则是把事情做得更快。</p>
<p>那么，如何找到真正值得解决的问题呢？只需要记住两点：第一，不是所有的问题都是真正的问题；第二，不是所有真正的问题都值得被解决！</p>
<h3 id="不是所有问题都是真正的问题"><a href="#不是所有问题都是真正的问题" class="headerlink" title="不是所有问题都是真正的问题"></a>不是所有问题都是真正的问题</h3><p>我们所看到或者听到的问题，其实只是表象问题，而表象问题跟真正问题之间，还差了三条街，也就是三种偏差。</p>
<p>第一，<strong>理解偏差（常常出现在别人要你解决问题的时候）——所以要提问</strong></p>
<p>第二，<strong>隐藏偏差（常常出现在与他人产生冲突的时候）——所以要挖掘</strong></p>
<p>Simon Fisher曾经提出过一个冲突层模型，他说，我们所声称的问题其实只是最表层的，背后存在隐藏的原因，以及内心真正的需求。</p>
<p>第三，<strong>成因偏差（常常出现在解决商业性问题的时候）——所以要分析</strong></p>
<p>不是所有真正的问题都值得被解决。我们用一个二维矩阵，来帮助我们区分不同的问题。</p>
<p>处于四个不同区间的问题，你的解决方式应该是不同的，否则就是在做无用功。另外，我给每一个区间取了个名字，便于理解。</p>
<p>区间1，解决度高、关键度低——小插曲：这个区间通常是最容易对付的问题，通常不会困扰你。对于小插曲的问题，如果花时间很少，可以迅速解决；如果花时间很多，可以授权别人去做。</p>
<p>区间2，解决度低、关键度低——困难游戏：这个区间的问题，就好像一个困难的游戏，通关几乎不可能，但这事儿没那么重要</p>
<p>对于类似困难游戏的问题，你需要设定一个时限，然后以此为标准，时限内可以解决的问题就做，时限内肯定无法解决的，就不要开始了，放弃吧。</p>
<p>区间3，解决度低、关键度高——无底洞：这是很多人容易陷入的无底洞。</p>
<p>因为关键度高，所以你会觉得要多花时间、需要非常谨慎，可是，问题的解决度明明很低。比如股市，关键度很高，可你天天挂在心上、天天研究，跟不研究比起来，结果也不会有多少差别。</p>
<p>将时间花在这些问题上，同样是一种浪费。并且，长久将自己陷在这个区间不能自拔，会导致自己毫无成就感、更加焦虑。</p>
<p>区间4，解决度高、关键度高——高价值陷阱：这个区间才是我们要花时间的地方，花时间解决可以产出结果、价值又高的事情。但是，这里也会有陷阱。</p>
<p>因为重视，很多人总会在内心漫无目的地反复思量，却不会行动。你以为自己在思考和解决问题，其实只是在困扰和焦虑中耗费精力。</p>
<p>真正的思考，是你需要收集信息、自我剖析、咨询他人、分析各种可能、最后进行选择。</p>
<p>面对高价值问题的时候，你唯一需要注意的是：思考，而不是困扰。</p>
<p>如果你意识到自己只是在困扰（通常的表现为：反复思量、毫无进展，而且你知道这样下去根本找不到答案），马上停止下来，避免落入陷阱。</p>
<p>实际上，找到高价值问题并不难，你只需要养成一个习惯，在看到问题之后，不要马上解决，而是拿出我提供的这个清单过一遍。当然，你也可以在此基础上，根据你自己的思维习惯，设计一个属于你自己的问题清单，会更有针对性。</p>
<hr>
<p>清单问题1：澄清需求——我是否清楚该问题/任务的背景、目的、关键利益方、可用资源、时间要求？</p>
<p>清单问题2：挖掘诉求——对方为什么会提出这样的问题/挑战？ta的真正诉求是什么？这个诉求还可以通过什么方式实现？我可以怎么帮助ta实现？（若不是跟人相关的问题，此条可略过）</p>
<p>清单问题3：找准问题——这个问题解决了，事情就会都顺利了？我解决的只是表象问题、还是真正成因？</p>
<p>清单问题4：确定关键——这个问题现在是否必须被解决？是否有其它更加重要的问题需要我去花时间？</p>
<p>清单问题5：确定可行——这个问题现在是否可以被解决？我解决这个问题大概需要多久？这个时间是否可被接受？</p>
<p>清单问题6：正确思考——这个问题我思量多久了？有没有进展？继续如此，是否有可能找到答案？（当你因为无法进展而苦恼的时候，问这个问题）最后，请牢牢记住这几句话：不是所有问题都是真正的问题，不是所有真正的问题都值得被解决。看到问题的时候，不要马上解决，先过一遍清单。</p>
<hr>
<h3 id="精彩提炼-5"><a href="#精彩提炼-5" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 大部分工作，需要的都是功劳，而不是苦劳，所以，“做什么事”，比“怎么做事”，可能更重要。</p>
<p>2 不是所有的问题都是真正的问题：表象问题跟真正问题之间，存在三种偏差。</p>
<p>3 不是所有真正的问题都值得被解决：因为大部分问题，花多少时间，结果都是一样的。</p>
<p>4 在开始解决问题之前、或者耗时很久却毫无进展的时候，看一下文中提到的6个问题的清单，也许会豁然开朗。</p>
<h2 id="“活的思维”与“死的知识”——清晰的思维不是无法培养的"><a href="#“活的思维”与“死的知识”——清晰的思维不是无法培养的" class="headerlink" title="“活的思维”与“死的知识”——清晰的思维不是无法培养的"></a>“活的思维”与“死的知识”——清晰的思维不是无法培养的</h2><p>其实，结构化思维不仅价值度高、而且可培养度也很高，非常值得我们刻意训练。</p>
<p>人类大脑在处理信息的时候，有两个规律：</p>
<p>第一，不能一次太多，太多信息会让我们的大脑觉得负荷过大；</p>
<p>第二，喜欢有规律的信息。</p>
<p>美国心理学家米勒（George A. Miller）明确提出短时记忆的容量为7±2，即一般为7并在5~9之间波动。</p>
<p>所以，如果我们在解决问题、面临选择以及与人沟通的时候，能够找到一个结构，将所有的碎片信息放进去、进行归类，就能够大大减轻大脑的负担，更容易地解决问题。而这，就是所谓的“结构化思维”。它的作用在于：</p>
<p>第一，帮助我们更全面、更系统地思考，将复杂的问题简单化。</p>
<p>第二，方便我们与人沟通，让他人更好地理解我们的意思。</p>
<p>第三，互联网时代，信息都是碎片化的，如果没有结构化思维，信息只是信息，可如果有了结构化思维，就能够建立起自己的知识体系，有利于我们在解决问题的时候调用大脑中的相关信息。</p>
<p>当你面临一个难题的时候，该如何去寻找结构呢？这里给出两种方法：一种是自上而下地找结构，一种是自下而上地归纳提炼结构。</p>
<p>第一，自上而下找结构：思考一个框架，然后将信息或解决方案放入框架。</p>
<p>宏观环境分析比较常见的结构是PEST（Political政治层面，Economic经济层面，Social社会层面，Technological技术层面）</p>
<p>第二，自下而上归纳总结成结构：当你不清楚可以用什么框架的时候，四种方式把信息结构化。</p>
<p>第一步，头脑风暴。</p>
<p>第二步，连线分组。</p>
<p>第三步，提炼结构。</p>
<p>这一步需要用到MECE（Mutually Exclusive, Collectively Exhaustive，即相互独立、完全穷尽）原则，来决定分组调整。</p>
<p>第四步，完善观点。</p>
<p>我们找结构的时候，也是有些技巧的，给出两点最重要的技巧：</p>
<p>第一，通过常见结构类型来推导结构：你会发现，很多结构其实都很相像。</p>
<p>我按照使用频率，列了一些思维结简单的：</p>
<p>时间、空间，等等。</p>
<p>三要素类：比如，3C战略三角（Corporation公司，Customer顾客，Competition竞争对手）。</p>
<p>二维矩阵类：比如前面提到的任务分析矩阵（紧急性、重要性）。</p>
<p>流程类：比如产品价值链（研发、设计、采购、生产、营销、服务，等等）。</p>
<p>利益相关方类：比如波特五力模型（影响企业竞争战略的五种力量：现有竞争者、潜在竞争者、替代品、供应商、购买者）。</p>
<p>第二，通过学习知识来积累结构，将知识内化为能力。</p>
<h3 id="精彩提炼-6"><a href="#精彩提炼-6" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>1 结构化思维是可培养且价值度高的能力，几乎是最值得刻意训练的能力。</p>
<p>2 几乎不存在思维清晰、沟通不清的情况，沟通不清楚就是还没思考透。</p>
<p>3 对于简单的问题，我们可以先思考结构，再填充内容。</p>
<p>4 对于复杂的问题，我们可以列出所有信息，用自下而上的方法找到结构，具体方法分为四步：头脑风暴、连线分组、结构提炼、观点补充。</p>
<p>5 大多数结构都是常见的类型，找不到结构的时候，可以往这些常见类型上面靠：时间、空间、三要素、二维矩阵、流程、利益相关方。</p>
<h2 id="跳出固有思维——为什么有些人条理清晰，却没有洞见"><a href="#跳出固有思维——为什么有些人条理清晰，却没有洞见" class="headerlink" title="跳出固有思维——为什么有些人条理清晰，却没有洞见"></a>跳出固有思维——为什么有些人条理清晰，却没有洞见</h2><p>我们此前提到的结构化思维，属于垂直思维（Vertical Thinking），它能够让我们从一个点开始，跟随严密的逻辑一步步往下推导，就像我们上面写的公式那样。但是它有缺陷，因为忽略了水平方向的可能性，比如，收入=单价X杯数，这个公式的假设前提是我们仍然按照每杯咖啡来收费，但忽略了按时间收费的可能性。</p>
<p>这种水平方向的思考，我们称为水平思维（lateral thinking），维基百科的定义是：以非直接、非传统的方式或者显然非逻辑、非一步步推导的方式，来寻求解决问题的办法。</p>
<p>垂直思维让你的思考更清晰、想法更完善、表达更逻辑，但是要有更创新的洞见，往往还需要结合水平思维。</p>
<p>实际上，创新是一个综合概念，而思维是创新的方式，我们在创新的过程中，垂直思维和水平思维都是必要的。</p>
<p>斯坦福开设了一门创新课程《创意速成课》，就是教大家如何产生创意。</p>
<p>为了便于理解，整个流程我总结成了五字诀“信放虑收行”</p>
<p>信：从观念上、信息上做好创造的准备。</p>
<p>放：将自己的思维信马由缰地放出去，打开脑洞。</p>
<p>虑：过滤掉那些不靠谱的想法。</p>
<p>收：将思维收回来，进行整理归纳，形成方案，这一步，我们用到的是之前提到的结构化思维。</p>
<p>行：执行和跟进。以这样的流程，便能够确保：我们的方案中，既有创新大胆天马行空，又有深思熟虑严密逻辑。</p>
<p>第一，信：从观念上、信息上做好创造的准备。</p>
<p>●改变观念</p>
<p>要变成一个有创造力的人，我们需要在心态上做到：第一，我们要解决的不仅仅是涌现出来的现存问题，更重要的是，要善于发现潜在问题并解决。第二，任何变化、挫折、失败都是创新的好机会，而不是一个麻烦。第三，随时关注外部变化和趋势。</p>
<p>●收集信息</p>
<p>基本上解决问题之前，我们需要收集三类信息：</p>
<p>第一类是特征信息，即该领域内一些好的方案所具备的特征，这能够确保我们时刻记住最终目标，而不会跑偏。</p>
<p>第二类是主题信息，即与待解决问题相关的方法论/学习材料，这能够确保你的方案有实质内容。</p>
<p>第三类是对象信息，即你的受众的需求，这能够确保你的方案能够接地气地解决问题。</p>
<p>第二，放：将自己的思维信马由缰地放出去，打开脑洞。</p>
<p>我们的思维在多次解决同类问题、处理同类信息之后，会逐渐形成习惯，也就是思维定式。思维定式一方面让我们处理同类问题更加快速，但另一方面，也会让我们的思维受限。所以，打开脑洞的方式，就是破除思维定式，我给大家介绍几个方法：</p>
<p>●6W：拓展问题拿到一个问题的时候，将它拓展成为六个问题，分别进行思考：Who、What、Why、Where、When、How。</p>
<p>●SCAMPER：当有产品/服务出现问题、需要改进的时候，SCAMPER是个很好的工具，可以帮我们拓展思路。</p>
<p>Substitute替代：原材料、资源、流程等，是否有可替代的其他方案。</p>
<p>Combine合并：资源、品类、功能等，是否存在合并的可能性。Adapt适应：产品还可以适用于何种场景，需要作何改变。Modify修改：产品的形状、颜色等特征，可以作何修改。</p>
<p>Put to another use用途：产品还可以有哪些新用途。Eliminate简化：产品的哪些地方还可以更简化/忽略。Reverse反向：你想做的这个改变，如果反过来，会如何。<br>●重新表述问题。当我们面临一些问题，没有任何思路的时候，试着将问题用不同的方式问自己，可能会有惊喜。</p>
<p>●反向问题</p>
<p>●用比喻：转换成熟悉问题</p>
<p>●随机输入：随手拿起一本书、一张照片，或者听一首歌，强行将它们跟你的问题联系在一起，迫使你跳出思维定式。另外，把你的问题用图形化的方式展现出来，也是一个非常好的方法。</p>
<p>第三，虑：过滤掉那些不靠谱的想法。</p>
<p>●考虑各个想法的风险、影响、阻力</p>
<p>●在此基础上对方案进行比对和决策</p>
<p>第四，收：将思维收回来，进行整理归纳，形成方案。</p>
<p>创新者的性格与普通人最大的区别是，他们的性格复杂，往往能兼容对立的两面。</p>
<p>创新者的高自主性，让他们得以摆脱社会对性格的偏好和定义，保持自己的兼容性。所以，想让自己的思维突破定式的限制，首先就要让自我突破外在标签的限制。</p>
<h3 id="精彩提炼-7"><a href="#精彩提炼-7" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>逻辑严密的垂直思维存在局限性，而天马行空的水平思维，会让你更有创造力。</p>
<p>创新解决问题的五字诀：信、放、虑、收、行。</p>
<p>开脑洞（放）的正确姿势：6W问题、SCAMPER、重新表述问题、反向问题、用比喻、随机输入。</p>
<p>解除思维限制、打开脑洞之前，先解除外在标签对自我的限制，承认自己的多样性。</p>
<h3 id="后续练习"><a href="#后续练习" class="headerlink" title="后续练习"></a>后续练习</h3><p>找出你手头上最难解决的一个问题，最好是工作中的问题，然后，按照如下顺序进行思考。先问六个问题，从而确定这是否是值得被解决的高价值问题。</p>
<p>如果是高价值问题，准备7张A4纸。<br>用开脑洞的六个方法，思考跟这个问题相关的任何想法，每个方法用一张A4纸。<br>分析这些想法的潜在风险、可能影响、面临阻力，划掉不靠谱的想法。<br>将留下来的想法写到第7张A4纸上。<br>用之前提到的结构化思维的自下而上的方法，对第7张A4纸中的想法进行结构化。<br>最后，据此制定行动方案。  </p>
<h3 id="我们的独立思考"><a href="#我们的独立思考" class="headerlink" title="我们的独立思考"></a>我们的独立思考</h3><p>你以为的“真相”，其实只是“立场”</p>
<p>独立思考本质上是一种批判性思维，而批判性思维本身就是对思维展开的思维，目的是去考量我们自己（或者他人）的思维是否符合逻辑、是否符合好的标准，它是否违背我们下意识的思维方式的。</p>
<p>独立思考的最佳方式是提问，在提问之前，我们需要先区分几个基本概念。</p>
<p>1 区分基本概念</p>
<p>●描述性论题（Descriptive Issues）与规定性论题（Prescriptive Issues）</p>
<p>●事实（Fact）与观点（Opinion）</p>
<p>2 问问题</p>
<p>一般来说，我们在论述问题的时候，应该包括以下要素：</p>
<p>论题：比如，范冰冰是不是美女？理由：美女是指外表让人产生愉悦心情的女性；范冰冰外表让人心情愉悦；范冰冰是女性。结论：范冰冰是美女。逻辑：从给出的理由是否能够推导出结论。在这个例子里面，通过演绎推理，可以得出结论，所以逻辑非常严密。证据/事实：除了这些要素以外，很多理由是需要证据/事实来证明的。比如，范冰冰的外表让人心情愉悦，这是个规定性论述，是需要证据的。</p>
<p>假设：一些理由还可能存在假设，比如，其中一个理由：美女是指外表让人产生愉悦心情的女性。但是，如果换一个人，ta可能会说：美女还需要内心善良。所以，这是需要假设的。</p>
<p>综合这些要素，我对论述中容易犯的一些错误，做了个总结。不管是在反思自己还是反思他人的时候，我们都需要加以注意：</p>
<p>第一，这个理由是否能够推出结论？是否存在逻辑漏洞。</p>
<p>常见的逻辑漏洞，不外乎以下类型：人身攻击、虚假的两难选择、相关当因果、诉诸感情、乱扣帽子。</p>
<p>第二，是否隐藏了自己的某种价值观假设</p>
<p>第三，证据/事实是否有效支撑理由。</p>
<p>第四，是否存在故意隐藏或模糊不利证据/事实。</p>
<p>在训练我们独立思考的时候，还需要注意的是：</p>
<p>第一，多审视自己的第一反应：避免先入为主，避免“我的就是比你好的”</p>
<p>第二，多从正反两方面思考问题：不要轻易否定，也不要轻易肯定。</p>
<p>第三，筛选需要批判性思考的问题：我们不需要对每句话都进行批判性思考，倘若那样的话，我们就没法写<br>文章、没办法说话甚至没办法生活了。</p>
<p>第四，跟独立思考的人相处：独立思考的人，通常有这样的特征，具有自主性、满怀好奇心、为人谦恭有礼、常常以理服人而非人身攻击。倘若我们经常跟这类人相处，便能够帮助我们养成独立思考的习惯。</p>
<p>最后，这句话与各位共勉：Opinion is cheap——Margaret Simons（永远记住，观点是最廉价的，事实和论证才有价值）。</p>
<h3 id="精彩提炼-8"><a href="#精彩提炼-8" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>大部分时候，我们本能地喜欢与己相同的观点，却不爱追究真正的事实。<br>独立思考本质上是一种批判性思维，但我们常常很难做到，因为这种思维是反直觉的、思考的结果可能是令人沮丧的、而且我们的教育并未着重培养这一思维。<br>社会日益复杂、信息日益爆炸，倘若我们不具备独立思考的能力，将会一直处于“一觉醒来价值观就会被颠覆”的动荡中。<br>关于“世界是什么”的议题称为描述性议题，关于“世界应该是什么”的议题称为规定性议题。<br>描述性议题的结论如果正确，可以称为“事实”，而规定性议题的结论，称为“观点”。<br>问题的论述应当包括以下要素：论题、理由、结论、逻辑、证据/事实、假设。<br>当我们对一个论述展开独立思考的时候，通常可以思考这些问题：逻辑是否存在漏洞，导致给出的理由推导不足以推导出结论；存在何种隐藏的价值观假设，该价值观你是否认可；证据/事实是否足以支持理由；是否隐藏/模糊不利证据或事实。<br>在培养自己独立思考能力的时候，我们还应当注意：多审视自己的第一反应，不要轻易相信下意识的判断；多从正反两方面思考问题；筛选需要思考的问题，而不是对所有问题都花同样的力气进行思考；跟独立思考的人相处。  </p>
<h1 id="第四章-提升沟通能力：如何成为高段位沟通者"><a href="#第四章-提升沟通能力：如何成为高段位沟通者" class="headerlink" title="第四章 提升沟通能力：如何成为高段位沟通者"></a>第四章 提升沟通能力：如何成为高段位沟通者</h1><p>为什么你总是有口难言——如何做好临场发言</p>
<p>思路非常清晰的人，很少有表达不清晰的，因为表达本身就是思路的一部分。</p>
<p>用结构化思维，帮助你在短时间内更好地沟通，关键是三个步骤：</p>
<p>第一步，想主题：迅速找到一个切入点，第一句就说出自己的观点。</p>
<p>第二步，搭架子：在论证观点时，思考一个结构（时间、空间、程度），并只说三点，这称为三个“架子”。</p>
<p>第三步，填素材：每个架子里，填充一些事例、数据等，来推进论据向观点靠近。</p>
<p>比较好的开头是直接抛出观点，比如“我认为，这个政策对消费者是利好，但对于企业来说有负面影响”。这类主题的好处是：直接摆明观点，听众有了预期；观点比无用信息更加吸引人，会吸引听众继续听下去；一个话题有很多的角度，如果不说明，听众的思路会很散，但是这样的观点摆出来之后，听众会跟着你去思考。</p>
<h2 id="如何找到架子"><a href="#如何找到架子" class="headerlink" title="如何找到架子"></a>如何找到架子</h2><p>大致来说，架子不外乎以下类型：</p>
<p>类型一，时间架：按照时间的顺序，把脑子里的信息整理输出，时间类的架子可以分成以下三类：代表时间的词、代表阶段的词、代表步骤的词。我们平时可以有意识地积累这些架子，脑子里积累的架子越多，整理思路的速度就越快。</p>
<p>类型二，空间架：按照地点的顺序整理思路。接下来给大家一些空间法的架子：代表地理位置、代表视觉区域。</p>
<p>类型三，三角架：按照三个方面的顺序整理思路。代表三个方面（三件事）的词、代表三类人的词。</p>
<p>用这三种方法找架子的时候，可以尽量使用MECE原则（Mutually Exclusive, Collectively Exhaustive，即，架子之间相互独立、完全穷尽），这个原则在本书之前讲结构化思维的时候也提到过，这样会给人逻辑更加严密的感觉。</p>
<p>素材需要数据、事实和故事来填充，我想我们都知道这些。然而，有另一个技巧，却往往是我们忽略的，那就是：如何组织语言以及调动观众思维。</p>
<p>具体在承上启下的时候，比较好的做法是：从上个子主题中，挑选一个关键词/短语来总结其思想，将其用在下个主题的起始句中。</p>
<h3 id="如何进行训练"><a href="#如何进行训练" class="headerlink" title="如何进行训练"></a>如何进行训练</h3><p>累架子——随时随地积累<br>练套路——分三个阶段练</p>
<h3 id="精彩提炼-9"><a href="#精彩提炼-9" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>用结构化思维进行临场发言的步骤：想主题、搭架子、填素材。<br>想主题的注意点：迅速找到一个视角，并在第一句话就抛出观点。<br>架子有三种类型：时间架、空间架、三角架。<br>填素材的时候，需要注意承上启下，以使听众跟着思考。<br>如何练习：在日常生活中不断累架子；在平时工作中不断练套路。  </p>
<h2 id="如何愉快地闲聊——聊天不是为了得出一个正确答案"><a href="#如何愉快地闲聊——聊天不是为了得出一个正确答案" class="headerlink" title="如何愉快地闲聊——聊天不是为了得出一个正确答案"></a>如何愉快地闲聊——聊天不是为了得出一个正确答案</h2><p>如果我们跟人聊天，想让对方觉得愉快，需要做什么呢？控制话题的长度和节奏；适时表达认同；与对方感同身受。</p>
<p>如何控制聊天长度和节奏</p>
<p>要想很好地控制聊天长度和节奏，就需要能够自如地延展和结束话题。</p>
<h3 id="1-当对方抛出话题的时候，你该如何延展"><a href="#1-当对方抛出话题的时候，你该如何延展" class="headerlink" title="1 当对方抛出话题的时候，你该如何延展"></a>1 当对方抛出话题的时候，你该如何延展</h3><p>简单来说，可以从以下六个角度来思考和回应这个问题，我分别举例说明：</p>
<p>角度一——历史：这个现象跟过去有何不同？这个现象是否牵扯到过去的某种现象</p>
<p>角度二——原因：导致这个现象的原因</p>
<p>角度三——范围：这个现象发生的范围</p>
<p>角度四——具化：把一个现象缩小到个体身上，举一个你知道的有趣的例子</p>
<p>角度五——影响：一个现象可能引发的一系列现象</p>
<p>角度六——未来：关于这件事情的后续进展，有没有什么措施将会采取</p>
<h3 id="2-当自己抛出话题的时候，最重要的就是：不要抛出封闭式问题。"><a href="#2-当自己抛出话题的时候，最重要的就是：不要抛出封闭式问题。" class="headerlink" title="2 当自己抛出话题的时候，最重要的就是：不要抛出封闭式问题。"></a>2 当自己抛出话题的时候，最重要的就是：不要抛出封闭式问题。</h3><h3 id="3-当你不想继续的时候，如何优雅地结束"><a href="#3-当你不想继续的时候，如何优雅地结束" class="headerlink" title="3 当你不想继续的时候，如何优雅地结束"></a>3 当你不想继续的时候，如何优雅地结束</h3><p>●以事情来结束</p>
<p>●以口号式的祝福或赞美结束</p>
<p>●以表情结束（适用于线上聊天）</p>
<h3 id="如何适时表达认同"><a href="#如何适时表达认同" class="headerlink" title="如何适时表达认同"></a>如何适时表达认同</h3><p>●借助表情：如果你想表达认同，不妨多用一些肢体语言，尤其是表情，能让对方更加强烈地感觉到你传递的信号。</p>
<p>●善于倾听，看着对方</p>
<p>●赞美对方</p>
<h3 id="如何与对方感同身受"><a href="#如何与对方感同身受" class="headerlink" title="如何与对方感同身受"></a>如何与对方感同身受</h3><p>最关键的是，主动建立自己与他人的感情联结、将心比心，让自己代入他人的感受。</p>
<h3 id="精彩提炼-10"><a href="#精彩提炼-10" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>如果我们跟人聊天，想让对方觉得愉快，需要：控制话题的长度和节奏、适时表达认同、与对方感同身受。<br>聊天不是辩论、不是汇报工作，更不是为了得出一个正确答案。<br>如何控制长度和节奏：当对方抛出话题的时候，从六大角度延展；当自己抛出话题的时候，不要抛出封闭式问题，可以是一些关于对方人生和职业经历的话题；不想继续的时候，以事情、口号或者表情来结束。<br>如何适时表达认同：借助表情、善于倾听、赞美对方。<br>如何表达不认同：委婉地表达、给别人期望。<br>如何与对方感同身受：承认世界的多样性、穿上对方的鞋、暂时放下自我。  </p>
<h2 id="说事实不如讲故事——你很难说服人，是因为你没用这个套路"><a href="#说事实不如讲故事——你很难说服人，是因为你没用这个套路" class="headerlink" title="说事实不如讲故事——你很难说服人，是因为你没用这个套路"></a>说事实不如讲故事——你很难说服人，是因为你没用这个套路</h2><p>故事让你产生共情，胜过一切冷冰冰的数据和逻辑。</p>
<p>亚里士多德说“我们无法通过智力去影响别人，而情感却能做到这一点。”</p>
<p>实际上，冲突是故事要素中最大的核心。可是，要如何制造冲突呢？</p>
<p>冲突=渴望+障碍。</p>
<p>除了冲突之外，故事还需要什么要素呢？一个好的故事，需要包括三个基本要素（冲突、行动和结局）以及两个附加要素（情感和展示）。</p>
<p>基本要素很容易理解，因为有冲突，必然是需要行动的，行动之后到底结果如何，这就是结局了。那么，附加要素：情感和展示，到底是什么呢？情感的作用是，建立跟观众或读者的连接，引起共鸣。</p>
<h3 id="精彩提炼-11"><a href="#精彩提炼-11" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>任何想要说服别人、激发对方情感的场合，你都需要故事，因为只有故事才能引发共情。<br>好的故事都具备这些要素：基本要素（冲突&lt;渴望、障碍&gt;、行动、结局）+附加要素（情感、展示）。<br>商业故事与小说故事遵循同样的方法，但商业故事有四大特点：渴望是挖掘的而不是人为制造的；目的性很强所以故事是从结局倒推的；并非所有故事都需要情感；展示往往包含很多数字和案例。<br>常见的商业故事类型：我是谁、我为什么在这儿、教育展望、我知道你在想什么。  </p>
<h2 id="拓展弱联系——最有价值的信息和资源并非来源于好朋友"><a href="#拓展弱联系——最有价值的信息和资源并非来源于好朋友" class="headerlink" title="拓展弱联系——最有价值的信息和资源并非来源于好朋友"></a>拓展弱联系——最有价值的信息和资源并非来源于好朋友</h2><p>根据牛津大学人类学家罗宾邓巴（Robin Dunbar）的研究，每个人的社交网络中，最核心的圈子有3-5人，最为亲密。然后是12-15人，失去他们会给你带来重创。继而是30-40人，这是你经常保持联系的一群。然后是150人，而这150人是人类智力允许其拥有的稳定网络的人数上限（也被称为邓巴数字）。</p>
<p>当考虑找人合作、了解信息的时候，“弱联系”其实是最佳选择。</p>
<p>那么如何跳到自己的小圈子以外、并与其它圈子的人缩短心理距离呢？我总结了一些方法，如下：</p>
<h3 id="1-离开舒适区"><a href="#1-离开舒适区" class="headerlink" title="1 离开舒适区"></a>1 离开舒适区</h3><p>主动，决定了你迈出去的关键一步，也决定了你人际网络的广度，而内涵决定了你跟对方能够聊多久，也就是决定了你人际网络的深度。如何离开舒适区、走到圈外呢，这里有几种方法：</p>
<p>第一，让别人引荐</p>
<p>第二，主动建立圈子之间的连接</p>
<p>第三，借助共同话题</p>
<h3 id="2-选对圈子"><a href="#2-选对圈子" class="headerlink" title="2 选对圈子"></a>2 选对圈子</h3><p>其实选择一个人际网络圈的时候，我们需要有几个判断：</p>
<p>第一，不要跟现有的人际网络重合度过大</p>
<p>第二，能够给你带来价值</p>
<p>价值可以是自我成长、信息获取、合作机会，等等，甚至你觉得这个圈子的人很逗比，这也是一种价值，就看你自己需要什么。</p>
<p>第三，你对这个圈子可以有贡献和价值</p>
<h3 id="3-差异化定位"><a href="#3-差异化定位" class="headerlink" title="3 差异化定位"></a>3 差异化定位</h3><p>一般而言，人际网络中会有四种角色：节点、专家、明星、助理。</p>
<h3 id="4-摆正态度"><a href="#4-摆正态度" class="headerlink" title="4 摆正态度"></a>4 摆正态度</h3><p>第一，保持真诚保持真诚在这里有两个含义：1 出发点别那么功利；2 表现真实的自己。</p>
<p>第二，保持平等</p>
<p>第三，记得给予</p>
<p>“Give and take: A revolutionary approach to success”（中译名《沃顿商学院最受欢迎的成功课》）一书中提到，人际网络中有三种人，一种是Giver（给予者），一种是Taker（获取者），一种是Matcher（互利者），那些获得卓越社交价值的人往往是Giver（给予者）。所以，不要总是求别人帮忙。另外，承诺别人的事情一定要做到，甚至超预期地做到。</p>
<h3 id="5-用好技巧"><a href="#5-用好技巧" class="headerlink" title="5 用好技巧"></a>5 用好技巧</h3><p>第一，形象技巧</p>
<p>第二，比你能说的，让他说；没你能说的，启发他说</p>
<p>第三，适当展现自己的能力和价值</p>
<p>有时候跟牛人相处，你的能力实在弱爆了，没有什么可展现的。这个时候，你可以展现潜力。对资历比你深很多的人来说，帮助年轻人实现想法，比从他们身上获得价值要有意思得多。</p>
<h3 id="6-最后，不要过于依赖人际网络"><a href="#6-最后，不要过于依赖人际网络" class="headerlink" title="6 最后，不要过于依赖人际网络"></a>6 最后，不要过于依赖人际网络</h3><p>第一，不要因此忽略自己的好友</p>
<p>第二，弱联系也可以转化为强联系</p>
<p>第三，投资自己比投资别人要靠谱得多</p>
<p>你最大的瓶颈永远是你自己，而不是人际网络，不是机会，也不是环境。</p>
<h3 id="精彩提炼-12"><a href="#精彩提炼-12" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>强联系，是指你们处于同一个圈子，比如一起工作、一起居住、一起娱乐，你们的相处时间较长，通常想法也倾向于相似。<br>弱联系，是指你圈子以外的人，你认识、但不那么关心，通常建立在价值交换的基础上。<br>弱联系的真正作用是把不同的社交圈子连接起来，从圈外给你提供有用的信息。所以弱联系理论常常应用于找工作、商业合作等信息依赖性社交事件。<br>拓展弱联系的方法：离开舒适区、选对圈子、差异化定位、摆对态度、用好技巧、不要过于依赖人际网络。<br>离开舒适区的方法：朋友引荐、主动建立不同圈子间的连接、找到共同话题。<br>选择圈子的标准：与现有圈子重合度不要太高、可以为你带来价值、你可以对这个圈子贡献价值。<br>根据你的性格、资源等，可有四种人际网络的定位：节点、专家、明星、助理。<br>如何摆对态度：保持真诚、保持平等、记得寄予。<br>这些技巧需要注意：根据场合来塑造外在形象、根据对象来决定你说话的时间、向对方展现能力、能力不足的时候展示潜力。<br>不要过于依赖人际网络：别因此忽略强关系、弱关系也可以转化为强关系、投资自己比投资别人更加靠谱。  </p>
<h1 id="第五章-选择合适平台：借助平台成就不可取代的自己"><a href="#第五章-选择合适平台：借助平台成就不可取代的自己" class="headerlink" title="第五章 选择合适平台：借助平台成就不可取代的自己"></a>第五章 选择合适平台：借助平台成就不可取代的自己</h1><p>最好的方式是，你去了解并学习职业规划的方法论和思考问题的方式，再实践到自己的规划上。</p>
<p>在我们进行职业规划的时候，针对目标职业，至少有四点是我们需要关注的：</p>
<p>第一，目标职业的工作内容、薪酬回报等；</p>
<p>第二，目标职业未来的发展前景、供需关系；</p>
<p>第三，目标职业的到达方法，比如招聘要求、招聘渠道；</p>
<p>第四，企业组织形式的变化。</p>
<p>我们应该在掌握方法之后，自己做规划，而不要期待他人给出答案。<br>职业规划的三要素：价值规划、扬长避短、关注外部。  </p>
<p>●价值规划：如何通过规划，让自己的价值（知识、技能、能力）得以不断提升。</p>
<p>●扬长避短：了解自己的意愿和擅长，才知道自己接下来可以走什么路。</p>
<p>●关注外部：在进行个人规划时，外部环境是一个重要参考因素，包括行业内人才供需关系、企业组织形式<br>变化，等等。</p>
<h3 id="个人商业模式画布——像企业一样，给自己做规划"><a href="#个人商业模式画布——像企业一样，给自己做规划" class="headerlink" title="个人商业模式画布——像企业一样，给自己做规划"></a>个人商业模式画布——像企业一样，给自己做规划</h3><p>在这里，我介绍一个规划工具——个人商业模式画布，这是我自己用过并非常推荐的工具。为什么推荐呢？</p>
<p>第一，它是从企业商业模式中演变而来，因此，借助它，有利于我们拔高思维高度，去思考策略层面的事情，而不是长久陷在执行层，拘泥于“我到底选哪份工作”、“我能涨多少工资”。当然，不是说这些不重要，只是我们太久困于这些问题，需要偶尔从这些问题中抽离出来，让自己看得更高更远一些。</p>
<p>第二，这个画布不仅仅是规划工具，还可以作为诊断工具来使用，可以诊断你当前的职业状态，从而为后期的规划奠定基础。</p>
<p>可以让你进行如下思考：</p>
<p>●当前的职业状态有没有问题。</p>
<p>●如何进行职业选择。</p>
<p>●如何规划职业甚至人生。我分两步来介绍这个工具的使用：第一，填写画布；第二，分析画布。</p>
<h4 id="如何填写画布"><a href="#如何填写画布" class="headerlink" title="如何填写画布"></a>如何填写画布</h4><p>个人商业模式画布一共有九个要素，我将每个要素都标了序号，这个序号也代表你在填画布时候的思考和填写顺序。</p>
<p>要素一，核心资源：我是谁，我有什么</p>
<p>我是谁，主要包括性格、价值观。我有什么，主要包括兴趣、知识、技能、能力。</p>
<p>要素二，关键业务：我要做什么</p>
<p>我个人推荐现在和目标两个版本都写，后面分析的时候告诉大家原因。但是这里有几个注意点：</p>
<p>第一，如果你写的是目标，建议目标不要离你太远。</p>
<p>第二，业务罗列不要太细，两三个重要提炼就可以。</p>
<p>第三，无论目标还是现状，都要与画布的其他要素保持统一。</p>
<p>如果你在关键业务里面写了两个版本：现状和目标，那就意味着，其他要素也是写两个版本，这样才能对应起来，不应该出现：“关键业务”写的是目标，后面“客户群体”又写成了现状。</p>
<p>要素三，客户群体：我能帮助谁</p>
<p>要素四，价值服务：你为客户群体提供的价值是什么</p>
<p>要素五，渠道通路：怎样宣传自己、交付服务</p>
<p>要素六，客户关系：怎样和对方打交道</p>
<p>要素七，重要合作：谁可以帮我</p>
<p>要素八，收入来源：你在这份职业中获得的收获</p>
<p>这里的收入是广义的概念，包括物质回报和非物质回报。其中物质回报包括薪酬、福利、股权期权等；非物质回报则包括环境氛围、发展机会、成就感、满足感等。</p>
<p>要素九，成本结构：你为这份职业需要付出什么这里的付出包括时间、精力、金钱，甚至你的压力。</p>
<h4 id="如何分析画布"><a href="#如何分析画布" class="headerlink" title="如何分析画布"></a>如何分析画布</h4><p>至此，你的个人商业模式画布已经完成，接下来就可以去分析和应用了。这里按照文章开始时候给大家讲的三个用途，分别来举例：职业诊断、职业选择、职业规划。</p>
<p>用途一，职业诊断</p>
<p>用途二，职业选择</p>
<p>用途三，职业规划</p>
<p>个人商业模式画布是从企业商业模式中演变而来，因此借助它，有利于我们拔高思维高度，去思考策略层面的事情。</p>
<p>画布共有九大因素：核心资源、关键业务、客户群体、价值服务、渠道通路、客户关系、重要合作伙伴、收入来源和成本结构。</p>
<p>画布有三大用途：职业诊断、职业选择、职业规划。</p>
<p>用画布做诊断的关键在于：发现因素之间的不匹配。</p>
<p>常见的不匹配情形：关键业务跟核心资源不匹配；价值服务跟客户群体不匹配；渠道通路与客户群体不匹配。</p>
<h3 id="主副业选择——如何成为斜杠青年"><a href="#主副业选择——如何成为斜杠青年" class="headerlink" title="主副业选择——如何成为斜杠青年"></a>主副业选择——如何成为斜杠青年</h3><p>任何一份职业中，我们的诉求无非是三个方面：愉悦、成就、金钱。而这三方面的诉求，分别来自于：你热爱这份职业、你有能力做好它，并且它还可以为你赚足够的钱。</p>
<p>我们用这三个诉求，可以把职业分成七大类型，这有助于我们进行职业选择：</p>
<p>●爱好式职业：喜欢，但并不擅长，同时也无法带来足够的物质回报。</p>
<p>●勤勉式职业：喜欢，并且也能赚钱，只是不擅长。</p>
<p>●功利式职业：不喜欢也不擅长，但是可以依靠它获得物质回报。</p>
<p>●理性式职业：不喜欢，但很擅长，也能够获得不错的物质回报。</p>
<p>●虚无式职业：擅长，不热爱，也很难获得物质回报。</p>
<p>●幻想式职业：喜欢并擅长，但物质回报不足。</p>
<p>●完美职业：喜欢并擅长，而且可以赚到足够的钱。</p>
<p>关于寻找兴趣，我推荐三个方法：多尝试、多总结、做测评。</p>
<p>方法一，多尝试。这个无需多说，因为不去尝试，怎么会知道自己喜欢什么呢？很多事情，如果只是听说，往往容易产生一面之词。</p>
<p>方法二，多总结。世界上有成百上千个行业与职业，你不可能都去尝试。所以，你需要举一反三地总结，问自己一些深层次的问题。</p>
<p>方法三，做测评。测评工具有很多，比如霍兰德、职业锚，等等，这些都是职业兴趣类的测试，可以用来参考。但在发现兴趣的时候，不建议用一些性格特质的测试，比如MBTI，因为性格并不代表兴趣，而且性格跟你最终表现出的行为，中间也差了十万八千里。</p>
<p>关于兴趣，我常常看到很多年轻人存在认识误区，这里重点澄清三个：第一，享受不是兴趣，愿意付出才是；第二，任何事情，接触皮毛的时候不要谈兴趣；第三，兴趣跟爱好不同。</p>
<p>寻找自己的擅长领域，我给出两种方法，一种是自我总结，另一种是他人反馈。</p>
<h3 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h3><p>我也给一个问题清单：</p>
<p>●过去的工作中，哪些工作内容，让你感觉得心应手，而哪些让你觉得异常困难？</p>
<p>●你因为什么样的成绩而受到领导/同事的表扬、批评？</p>
<p>●你在哪些领域的知识和技能积累比较多？</p>
<p>●相比同龄人，你的能力优势在哪里？思维方面：思维严谨、逻辑缜密；人际方面：与人交往和沟通；运营<br>方面：制定计划并实施。</p>
<p>任何一份职业中，我们的诉求无非是三个方面：愉悦、成就、金钱。三个诉求将职业划分为七大类型。<br>我们很难找到一份工作，可以满足你对事业的全部幻想，就像你很难找到一个另一半，可以满足你对异性的全部幻想一样。<br>当我们选择主业、副业、爱好的时候，选那些诉求互补的，而不是诉求重合的，否则只会让你的缺憾加倍。<br>职业类型并非是一成不变的。当外界环境发生变化的时候，我们也应当相应调整。<br>寻找兴趣的三个方法：多尝试、多总结、做测评。其中的总结可以使用文中的总结清单，而测评只是辅助，不可全信。<br>享受不是兴趣，愿意付出才是；任何事情，接触皮毛的时候都不要谈兴趣；兴趣也不是爱好，而是热情的来源。<br>寻找自己擅长领域的两种方：自我总结、他人反馈。<br>有些能力，大部分属于天生，而有些能力，是可以通过培养来提升的。对于可培养的能力，不应当以此作为标尺去寻找职业，而应该是先提升能力，然后拓宽自己的职业道路。  </p>
<h3 id="你的高度-自身价值-平台高度——借助平台的正确姿势"><a href="#你的高度-自身价值-平台高度——借助平台的正确姿势" class="headerlink" title="你的高度=自身价值+平台高度——借助平台的正确姿势"></a>你的高度=自身价值+平台高度——借助平台的正确姿势</h3><p>努力、能力、天赋都很重要，因为这些构成了一个人的内在价值，然而，如果有一个合适的平台，却可以帮助你达到另一个高度。</p>
<p>你的高度=自身价值+平台高度</p>
<p>平台大致分为两类，一类是自建型平台，一类是他人型平台。先来说说三个自建型平台。</p>
<p>1 靠策略：这里的策略，并不是广义的概念，而是指个人的策略规划<br>一个平庸的企业和一个优秀的企业，差距在于战略。人也一样，一个好的策略规划，可以帮助我们更快地达到想要的高度。</p>
<p>总之一句话，靠策略成功，需要的是长远的战略规划，这样才能在短期内有的放矢。</p>
<p>2 靠宣传：把自己宣传出去，建立自己的个人品牌</p>
<p>3 靠产品：做出一个优秀的产品/解决方案</p>
<p>说完三个自建型平台，我们再来说说他人型平台，这里包括我们最常说的企业平台。</p>
<p>1 靠企业：找到一个能为你提供所需资源的企业平台</p>
<p>2 靠老板：跟随一个值得跟随的老板</p>
<p>职场上有句话说得很好：在一个公司，首先你得行，其次得有人说你行，然后说你行的人得行。</p>
<p>我们刚才提到，人与人之间，信任是最高的交易成本，当这个成本降到很低的时候，能够省却你很多精力，你只需要有能力，然后其他的交给这个靠谱的老板就行。</p>
<p>3 靠伙伴：靠着伙伴一起成长和扶持，实现1+1&gt;2</p>
<p>有一群志同道合而且能够共同成长的伙伴，是谁也无法替代的。所以说，年轻的时候，选择志同道合且能力相当的伙伴，能够互相促进。</p>
<p>4 靠家庭：父母或者伴侣的资源</p>
<p>最后，如果你想借力以上这些平台，那么有几个注意点：</p>
<p>第一，适当的时候选择合适的平台：如果你从图上看，平台会有高低。另外，成功率也有高低。所以，你需要根据不同的时期，选择不同的平台。</p>
<p>第二，平台是以自身价值为基础的：从图上看，底部都是你的自身价值。</p>
<h3 id="精彩提炼-13"><a href="#精彩提炼-13" class="headerlink" title="精彩提炼"></a>精彩提炼</h3><p>一切让你可以达到另一个高度的外部因素，都可以称之为平台。所以，你的高度=自身价值+平台高度。<br>平台的主要类型：靠策略、靠宣传、靠产品、靠企业、靠老板、靠伙伴、靠家庭。<br>在选择企业平台这件事情上，除了薪酬以外，你需要重点考虑：培养和发展机会、人脉和声誉、是否进入HIPO名单。<br>如果你发现自己跟老板很投缘，而且他符合这些特征，那么不妨考虑一下：对未来的判断常常很准、自身能力强、关心你、善于辅导你成长、为人正直。<br>年轻的时候，选择志同道合且能力相当的伙伴，能够互相促进。<br>适当的时候选择合适的平台。<br>在该长本事的时候长本事，该靠平台的时候靠平台，别搞乱了。<br>抓住机会，才能弯道超车——如何利用企业资源来提升个人价值</p>
<p>随着交易成本的下降和管理成本的上升，企业将越来越平台化，表现为：更替、无界、联盟和分化。<br>我们应该不断通过提问，时刻关注自己行业的发展动向。<br>主动发现机会，利用企业资源提升自我价值，才有可能弯道超车。<br>如果希望联盟，就去那些相对依赖人的行业。<br>最重要的是，不只是个人，企业也应当关注这些趋势，才能留住优秀的人才。  </p>
<h1 id="第六章-破除思维定式：哪些思维方式会终生阻碍你"><a href="#第六章-破除思维定式：哪些思维方式会终生阻碍你" class="headerlink" title="第六章 破除思维定式：哪些思维方式会终生阻碍你"></a>第六章 破除思维定式：哪些思维方式会终生阻碍你</h1><p>努力和结果之间并非线性关系——如何拥有一个高性价比人生</p>
<p>维持高性价比的三种可行方式</p>
<p>1 有所取舍</p>
<p>我们的知识和能力分布，应该是“T”字型的，也就是说，在一些领域做到70分，掌握最基础的能力，但是需要选择一个领域精耕和深挖。</p>
<p>取舍的标准有二个：第一，资源分布情况；第二，自身能力、兴趣、需求。</p>
<p>2 掌握方法</p>
<p>我认为盲目努力根本称不上努力，而是另一种大脑偷懒的做法。</p>
<p>3 调节情绪</p>
<p>这世界对人的评判标准依然粗暴，那就是：你有没有成功。</p>
<h3 id="错误意识"><a href="#错误意识" class="headerlink" title="错误意识"></a>错误意识</h3><p>工作不等于付出，而生活也不等于享受。付出不等于痛苦，而享受也不等于快乐。</p>
<p>我们追求的根本不是痛苦与快乐的平衡，而是长期快乐与短期快乐之间的平衡。</p>
<p>人的行为受很多因素的影响，性格只是很小的一部分，只代表你对这件事的一种偏好，而不代表能否做好。</p>
<p>面对你的天性，去做一双鞋，而不是去拔钉子。</p>
<p>如果在每次挫折和失败之后，就进入恢复模式，理所当然地认为自己需要疗伤，那就阻碍了这些挫折和失败给我们带来的全新视角，以及让自己变得更好的斗志。</p>
<h3 id="别给自己贴标签"><a href="#别给自己贴标签" class="headerlink" title="别给自己贴标签"></a>别给自己贴标签</h3><p>根据自己过往的经验，给一类人贴上标签进行分类，形成一种固定看法的行为，称为“刻板印象”（Stereotype）。<br>来源于过去的教育以及经历的刻板印象，很可能是一种偏见。<br>贴标签的原因：对抗恐惧、抱团竞争、便利社交。<br>我们常常以截然不同的态度对待他人：对熟悉的人，常常把他看成一个有个性的人，而对不熟悉的人，倾向于进行归类。<br>标签的负面作用：导致消极行为、引起焦虑感、阻碍深层社交。<br>如何避免对他人贴标签：建立意识、接触外群、见识世界。<br>如何避免被动贴标签：了解自己、多看反例、提升地位。  </p>
<h1 id="第七章-回归真实的自己：善用情绪，才能掌控人生"><a href="#第七章-回归真实的自己：善用情绪，才能掌控人生" class="headerlink" title="第七章 回归真实的自己：善用情绪，才能掌控人生"></a>第七章 回归真实的自己：善用情绪，才能掌控人生</h1><p>情商不只是如何对待别人，更重要的是如何对待自己，把情商等同于会说话，是大大的理解误区。<br>仅谈情商没有意义，因为它是多个影响因素的结果，要有针对性地提升。<br>长久受困于情绪，会阻碍我们进入其它层次，比如思维、价值观、愿景。<br>应对自己的情绪：认识它——认可它而不要暴力压抑它；觉察它——叫出它的名字，明白它的特点，从而能够聆听它传递的信息；管理它——用行为疏散负面情绪，而不是用负面情绪指导行为，同时移除自己的情绪条件反射。<br>应对他人的情绪：感知它——通过他人的身体反应和自己的换位思考来感知对方的情绪；应对它——牢记沟通目标，不要争高下、也无需做好人，而是要寻找双方的共同需求、达成共赢。  </p>
<h2 id="如何应对自己的功利心——上进是一种高发慢性病"><a href="#如何应对自己的功利心——上进是一种高发慢性病" class="headerlink" title="如何应对自己的功利心——上进是一种高发慢性病"></a>如何应对自己的功利心——上进是一种高发慢性病</h2><p>上进这个词的核心在于“上”，也就是说，比现在更好。暗含的意思就是，自己现在不够好，希望通过努力变得更好。</p>
<p>上进跟努力是不一样的，努力是付出，而上进是结果。</p>
<p>太过上进不仅带来情绪和心态上的负面影响，常常还会导致：不正确的自我认知、失去过程的快乐、牺牲长远发展换取短期进步。</p>
<p>让自己别太上进的方法：放低自己，承认自己一无是处；关注内在动机而非外在动机；不要太快、效率太高；放弃那些你十分抗拒、或者努力很久而不得的东西。</p>
<p>如何与性格“缺陷”和平相处——性格很难改变，那要怎么活下去</p>
<p>25岁到30岁的这几年，如果能够不断认识自己的性格，利用它的正面性，清楚它的负面性，并想办法应对，是对未来发展有极大益处的。</p>
<p>这世上本来也没有什么完美无缺的性格，也没有多少人能够改变自己的性格。然而，幸运的是，我们总能够找到一些方法，让这些缺陷最低限度地影响到我们。</p>
<p>心理学家埃里克森的研究指出，人一生要经历八个阶段的心理演变。人在不同的成长阶段，只有放弃旧的、过时的观念和习惯，才能度过危机，顺利进入人生的下个阶段。</p>
<p>只有那些抛弃不切实际的憧憬、承认自己和世界的缺陷、并通过其他方式弥补的那部分人，才得以度过这段危机，进入到下一个人格发展阶段，继续成长。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>Manage</tag>
      </tags>
  </entry>
  <entry>
    <title>最强会长黑神：虚假的真实</title>
    <url>/p/1eff3c35.html</url>
    <content><![CDATA[<p>这是一个荒诞的世界。</p>
<h2 id="活着的圣人-黑神目泷"><a href="#活着的圣人-黑神目泷" class="headerlink" title="活着的圣人 黑神目泷"></a>活着的圣人 黑神目泷</h2><p>身世显赫、相貌出众、头脑聪明、运动万能，能够瞬间学习技能并推演该技能到极致的天才，再加上勇敢积极的个性，包容兼爱同时能够激励和领导他人抗争和奋斗，这样的人，真是世界的【主角】，她本身就代表着正确。</p>
<p>正确得不像人，像个圣人。</p>
<p>但活着的圣人没有迷茫吗？</p>
<p>有，很早就有过。</p>
<p>黑神出生时便失去母亲。成长速度异常到出生半年身体就成长到如同5岁孩童般，并且能经过交战而快速习得他人的异常能力，对她来说没有不可能的事。由于成长过快，曾令自己感到如同罪恶般存在着，摸不清到底为何而存在。2岁时，在逃离医院的过程中认识了人吉，并因他的一句“一定是为了他人的幸福而存在着”成为她生存的意义（还好不是成为正义的伙伴之类的理想）。</p>
<p>而她也坚信这个他人赋予的意义，为了他人的幸福而努力，也因为自身的才能和信念成功改变了很多人、事、物，成为领导者、成为众人的依赖。</p>
<p>而成为众人心目中无所不能的【黑神目泷】，作为个体的黑神目泷则不存在，这就是圣人的代价。</p>
<h2 id="努力的凡人-人吉善吉"><a href="#努力的凡人-人吉善吉" class="headerlink" title="努力的凡人 人吉善吉"></a>努力的凡人 人吉善吉</h2><p>个性积极努力，不会因别人做了什么而改变自己，是努力的普通人，单单是陪伴黑神身边就要付出了很多，样貌和人气被很多配角压倒，战斗方式简单朴实，没有反转、没有戏剧，名言和名场景都很难找出来的角色。</p>
<p>与圣人黑神不同，他只是一个普通人，所以他懂得普通人的心，能体会努力的不易、放弃的痛苦、理想和现实的巨大差距、看着同伴背影时的苦涩，他明白自身的极限，他看到现实的差距，他选择积极、冷静、理解和笑容，如果说黑神是会把破房子拆掉重建的人，而人吉是会好好打扫并修补房子的人。</p>
<p>所以他是唯一理解黑神的人，唯一不去依赖黑神的人，唯一反对圣人的人，唯一爱着黑神的人。</p>
<p>在新一届学生会长选举中，人吉善吉向全能者安心院换取能力：愚行权—消除偶然，放弃运气，只依靠真实的积累和思维来决定结果，当机会主义毁灭后，凡人得到了他们的胜利。</p>
<p>圣人不死，大盗不止</p>
<h2 id="真实的谎言-球磨川禊"><a href="#真实的谎言-球磨川禊" class="headerlink" title="真实的谎言 球磨川禊"></a>真实的谎言 球磨川禊</h2><p>球磨川禊做为一个反派极具特色，他的语言中总是真真假假，整部作品很难从他的语言确定他的目的，以能够扭曲现实的[弥天大谎]，不断上演着一场不会成功的反派奋斗剧。</p>
<p>他的能力是以谎言来否定世界，因此能够让被破坏的物品复原、人体上的伤痛回复，甚至能够让死人复活，也算是可以为所欲为了，但即使如此，他也只是一个配角，作为一个反派注定败在主角的手上；作为同伴也只能衬托主角的光彩。整个世界只是一个故事的话，一切的努力和奋斗都不过是谎言，不过是脚本而已；</p>
<h2 id="否定世界的全能者-安心院薰染"><a href="#否定世界的全能者-安心院薰染" class="headerlink" title="否定世界的全能者 安心院薰染"></a>否定世界的全能者 安心院薰染</h2><p>球磨川禊的出场和思考算是对世界提出了疑问，而安心院薰染则是想推翻整个世界，在设定上活了千万年、掌握了上京（10^16）个能力，而且能够创造能力的角色，接近真正的无所不能；</p>
<p>她作为一个故事角色，她在漫长的时间中确定世界不过一部连载的漫画，不过是是主角的舞台，而她也不过是故事的配角，哪怕能力再强再多如果和主角做对，也必定会失败。</p>
<p>球磨川禊可以把这份现实当成谎言继续享受生活的美好，而存活了无数岁月、几乎全能的安心院则选择推动人吉善吉，用主角去和主角交锋，来验证世界的虚假。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>西尾维新的作品总是有性格极端的角色，这部作品同样有很多出色的人物，同时在在作品中更是对故事的套路、角色的命运进行思考，前面的20章是比较俗套的校园戏剧，最后的40章是强行结尾的俗套故事，但中间球磨川禊和安心院薰染所代表的故事章节真的不错;</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>逃离故事：《苏菲的世界》</p>
<p>生活的谎言：《楚门的世界》</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>月圆惊魂夜，对影成三人--月圆之夜</title>
    <url>/p/21a08d7d.html</url>
    <content><![CDATA[<p><img src="/images/game_moon.png" alt=""></p>
<h2 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h2><p>做为一款黑暗童话题材的游戏，游戏画风偏卡通但不幼稚,属于大色块平面类型，主要是颜色搭配得很好，人物各有特色、从小红帽的不同职位立绘到对手、卡牌都很有风格，简约但不简单，黑暗但不阴沉的风格。</p>
<a id="more"></a>

<h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>小红帽的外婆在月圆之夜失踪，她孤身一人前往黑森林探索，一步遇到猎人、守卫、妖怪、魔鬼、最后的boss还有狼人、女巫、神父、神秘人等；剧情虽然是简单的神秘组织背后搞鬼的故事，有趣的是小怪和boss背后都有小剧情，某些特定对手还会有特定的交互，可能会给你卡、加血、加技能等，很有想法。</p>
<h2 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h2><p>作为一款卡牌游戏，做出Roguelike RGP的感觉，人物设置了hp、mp、活动点，卡牌有除了常见的攻击、防御、回复、装备外，陷阱、延时等策划很给力，几种卡牌类型可以很好的相互结合成威力巨大的阵容，同时几个不同的职业也各有特色，比如：战士的攻击和血量、法师的元素爆发和魔力积累、射手的抽卡流、牧师的延时神术都是差别很大的玩法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>精致而完整的一款卡牌游戏，既有简单的爽快感，又能提供有深度的战术组合，5星推荐。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>架构师：ggtalk之向架构进发</title>
    <url>/p/84db9c0a.html</url>
    <content><![CDATA[<p>ggtalk 电台 向架构进发 一期邀请了 Casa Taloyum 聊了有关架构师的一些事。讨论了架构师的工作、架构师和技术专家的区别等问题。在此记录下这期的感想。</p>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><p>建筑工程师是人类有历史以来的最古老的工程师，而软件工程时不过是上个世界才诞生，两者之间差别比较大的是过去的经验和约定的规则，但也可以推演下软件工程后续的发展变化。</p>
<p>现阶段软件工程需要解决的问题基本可以概括为四点：业务功能组织、数据流向、工程发展和维护。</p>
<h2 id="架构师与技术专家"><a href="#架构师与技术专家" class="headerlink" title="架构师与技术专家"></a>架构师与技术专家</h2><h2 id="软件的质量评估"><a href="#软件的质量评估" class="headerlink" title="软件的质量评估"></a>软件的质量评估</h2><p>软件的功能是比较直观的，但软件的质量却比较难进行标准化，很多时候需要用经验来判断，比如直接观看代码，如果命名规范、语法高亮整洁、代码做到自解释，那么代码质量一般不会差。</p>
<p>因为工程师对自己的代码要求高，那么就有某种代码规范，需要有检查自己代码的习惯，比较容易发现代码的风险，并且其他人看这份代码也更舒适，更容易理解。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>需要解决一些难题的时候，有时不止需要思考如何解决，还需要比较不同的解决方案。选择了什么方案？优势是什么？基于什么原则？这些问题也许看上去优先级不高，但需要在不断思考的过程中，形成对不同方案更深刻的理解，在随后的项目实践中统筹方案的选择。同时能够保持方案的一致性，避免在相似的问题上随意采用了多种不同方案，增加项目维护和学习成本。</p>
<h2 id="工程价值观"><a href="#工程价值观" class="headerlink" title="工程价值观"></a>工程价值观</h2><p>Casa 提出了三条理论：工程是会成长，架构会被不断腐蚀，工程成本不是只有开发。</p>
<p>聚焦工程的发展和变化，让工程保持健康而长寿。</p>
<h2 id="定位真正的问题"><a href="#定位真正的问题" class="headerlink" title="定位真正的问题"></a>定位真正的问题</h2><p>问题原因的影响因素高低，很多时候反馈的问题只是表现，本质问题需要细化分析才能定位。而且有些问题可能根据经验和直觉就能猜出原因，但直觉是指出方向而不是结论，不能完全依赖，在工作中还是需要注重沟通和定位问题，解决核心问题能事半功倍得达成效果。</p>
<p>5个为什么原则：当反馈问题时，细化追问到第5个为什么，然后解决那个问题。</p>
<h2 id="新技术如何看待"><a href="#新技术如何看待" class="headerlink" title="新技术如何看待"></a>新技术如何看待</h2><p>很多新技术都是过去技术的优化和提升，不理解得追捧是盲目崇拜，应该关注新技术解决了什么问题，如何解决问题，保持好奇心，同时保持理性看待。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>欧洲古典民俗与神话-魔法使的新娘</title>
    <url>/p/a108bdd7.html</url>
    <content><![CDATA[<p><img src="/imags/acg_mfsdxn_01.jpeg" alt=""></p>
<p>少女羽鸟智世第一次见男主艾利亚斯时，是在一次地下拍卖会上，羽鸟智世想要寻求一处安身之地，无论是何人何处何种境遇。</p>
<p>半人类身形半骷髅羊头的魔法使艾利亚斯抛掷五百万英镑把智世带回了伦敦一处宁静美丽的家，“从今天起，你是我的新娘。”</p>
<p>虽然开头很玛丽苏，但请不要慌，这是一部披着爱情外衣的民俗奇幻故事。</p>
<a id="more"></a>

<h2 id="另一个的世界"><a href="#另一个的世界" class="headerlink" title="另一个的世界"></a>另一个的世界</h2><p>作品中大量的欧洲田园风光极为动人，展示了欧洲农村朴素、自然的风景。</p>
<p>初期，在简单而温馨的日常中，引出背后设定，那就是妖精的世界。</p>
<p>主角慢慢遇到了各种欧洲古典风俗传说，如北极的牧羊人和龙群、海豹人、猫的王国、妖精女王、墓地黑犬、银妖精、女妖、引导亡灵的掌灯人等等，都是独特的民族传说在现实世界的生存状态，就像镜子的另一面，只有像主角这样的人才能看到的世界。</p>
<h2 id="妖精"><a href="#妖精" class="headerlink" title="妖精"></a>妖精</h2><p>魔法使是与妖精签订契约的法师，通过付出魔力或者其他代价能借助妖精的能力施展各种奇迹，前提是能够获得妖精的喜爱，简单讲就是看脸、看血统；</p>
<p>妖精的喜恶是直接的，犹如顽童，可能给你礼物、也可能是突然的恶作剧；</p>
<p>对于人类来讲，最大的区别应该是妖精基本没有同理心，如‘夜之爱女’体质的人，会吸引妖精，可以得到它们的帮助，也会被纠缠、骚扰、甚至取走性命；而对于妖精来讲没有对错，凭本性行事。</p>
<h2 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h2><p>就像J·K罗琳创造了魔法的世界，本作也不只是停留在乡野农村，在本世界中，有着与精灵合作的魔法使、遵循科学的魔术协会、秘密结社的女巫协会、拍卖各种奇珍的地下拍卖所、隐藏在伦敦街头的魔法工坊、监视着异常的神秘教会、在森林深处的精灵国度、在西伯利亚中栖息着的龙群和牧羊人、游荡的无名古妖以及在节日偶然出现自然神灵，设定非常丰富。</p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>羽鸟智世，夜之爱女，吸引精灵的体质如同诅咒，父亲带着弟弟不告而别，母亲自杀，在家庭破灭后，痛恨自己的特殊体质，让她怀疑对自身的存在价值。而在她准备放弃自己的时候，她遇到了艾利亚斯，诞生在阴影中的荆棘，不完全的妖精，不完整的人，在两个世界徘徊的存在。也许彼此都不完整，所以才能彼此依偎、彼此了解，最终获得救赎与成长。</p>
<p>主线还是主角的自我认同，智世在艾利亚斯的带领下，看到了更广阔的世界，也看到自己的能力所带来的可能性，最终放下的母亲的悲伤和愤恨，感谢生命本身，最后舍弃了一部分身体、混合了罪人的血肉和龙诅咒活下去，放下一部分自我、接受他人换来的成长。</p>
<p>而男主艾利亚斯是半人半妖精，无法被两个世界接受，在牧羊人的指引下经历长久的岁月，观察人类、学习生活，但从未体会过人类的内心，在与智世的交流中，也慢慢也会到喜怒哀乐贪嗔怨妒，并统一为对他人的爱，获得了成长。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不可多得的好作品，感情描写含蓄而自然，整体节奏舒适，角色各有特色并且没有绝对善恶，但最吸引人的还是世界设定，而且动画版的画面极美，而且音乐质量很高，空灵悠扬，值得观赏。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>欲罢不能：刷屏时代</title>
    <url>/p/1273a387.html</url>
    <content><![CDATA[<p>微信、微博、抖音、快手、天猫、淘宝，我们的生活越来越便利、充实，如今，电子信息技术完全嵌入中国人民的生活，都要警惕，在这个信息化的时代，我们是否过度依赖信息技术了？又或者我们已经都对移动互联网上瘾了？</p>
<h2 id="令人上瘾的时代"><a href="#令人上瘾的时代" class="headerlink" title="令人上瘾的时代"></a>令人上瘾的时代</h2><p>按照“设计伦理学家”特里斯坦·哈里斯（Tristan Harris）的说法，问题并不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”。</p>
<p>行为上瘾由6种要素构成：可望而不可即的诱人目标；无法抵挡、无法预知的积极反馈；渐进式进步和改善的感觉；随着时间的推移越来越困难的任务；需要解决却又暂未解决的紧张感；强大的社会联系。</p>
<h2 id="行为上瘾是什么"><a href="#行为上瘾是什么" class="headerlink" title="行为上瘾是什么"></a>行为上瘾是什么</h2><p>侵入性技术还让购物、工作和色情变得难以回避了。</p>
<h2 id="任何人都能成为瘾君子"><a href="#任何人都能成为瘾君子" class="headerlink" title="任何人都能成为瘾君子"></a>任何人都能成为瘾君子</h2><p>只要碰到合适的情况，任何人恐怕都能成为瘾君子。</p>
<h2 id="诱使人们上瘾的是环境。"><a href="#诱使人们上瘾的是环境。" class="headerlink" title="诱使人们上瘾的是环境。"></a>诱使人们上瘾的是环境。</h2><p>瘾头嵌在记忆里。</p>
<h2 id="重回上瘾现场的危险性"><a href="#重回上瘾现场的危险性" class="headerlink" title="重回上瘾现场的危险性"></a>重回上瘾现场的危险性</h2><p>创办人认识到，使用互联网和药物成瘾不同，因为人几乎不可能回到正常社会又不上网。不靠酒精、不靠毒品，你能保住工作，偿付账单，进行人际沟通，但不靠互联网，这些事你都做不到。为与绿色运动相呼应，该中心以教导患者怎样“可持续地”使用互联网为目的，并不鼓励他们完全不上网。</p>
<p>导致上瘾的原因很多，但并不存在什么爱上瘾的性格。和正常人比起来，瘾君子并非意志虚弱、道德败坏。相反，许多甚至大多数瘾君子只不过是不</p>
<p>上瘾跟环境也有关系。就算是最顽强的人（比如离开越南时戒掉了毒瘾的年轻美国军人），处在错误的环境下也虚弱不堪。就算是痊愈期间意志力最坚定的人，重新接触与毒品有关的人和地方，也会再度落进毒品的魔爪。</p>
<h2 id="行为上瘾的生物学机制"><a href="#行为上瘾的生物学机制" class="headerlink" title="行为上瘾的生物学机制"></a>行为上瘾的生物学机制</h2><p>通常，大脑深处的松果体会在晚上产生名为褪黑素的激素。褪黑素会让你困倦，这就是为什么倒时差的人上床之前要服用褪黑素补剂。当蓝光进入你眼睛后面，松果体停止产生褪黑素，你的身体开始为白天做准备。但夜晚刷手机的行为破坏了这一机制。</p>
<p>上瘾让人太愉悦了，大脑做了两件事：首先，它产生较少的多巴胺应对快感的洪流；接着，当快感的来源消失，面对如今产生的多巴胺远少于过去的事实，它会挣扎着对付。只要瘾君子继续拼命去获取上瘾源，这样的循环就会持续下去，每一轮刺激过后，大脑产生的多巴胺也越来越少。</p>
<h2 id="任何体验都可能导致上瘾"><a href="#任何体验都可能导致上瘾" class="headerlink" title="任何体验都可能导致上瘾"></a>任何体验都可能导致上瘾</h2><p>只要能缓解心理困扰，任何体验都可能会上瘾。</p>
<p>药物上瘾和行为上瘾之间并不存在界限。两者相辅相成，同样有害，同样具有舒缓作用，也同样无法抵挡。<br>上瘾不是喜欢，而是渴望。</p>
<p>渴望更生猛、更强烈、更宽泛、更有力。从解剖学上看，喜欢微小而脆弱——它很容易遭到破坏，仅占大脑极小的一部分。反过来说，要扰乱强烈的渴望感不容易。一旦人们渴望毒品，就几乎变成了永久性的——对大多数人而言至少要持续一年，甚至持续终生。”</p>
<p>有关上瘾的真相，挑战了我们的许多直觉。它不是身体不求回报地爱上了危险毒品，而是思想学会了把药物或行为与心理疼痛的缓解挂上钩。实际上，上瘾和爱无关；肯特·贝里奇指出，所有的瘾君子都渴望那种让自己上了瘾的东西，但许多人并不喜欢它。</p>
<h2 id="上瘾体验是如何设计出来的"><a href="#上瘾体验是如何设计出来的" class="headerlink" title="上瘾体验是如何设计出来的"></a>上瘾体验是如何设计出来的</h2><p>障碍物怎么竟然能改善患者的步态呢？答案是，如果你想驱使人们采取行动，要把宏大的目标切割成便于管理的具体小目标。人受进步感的带动，如果终点就在眼前，进步也更容易察觉。</p>
<h2 id="目标和记录无处不在"><a href="#目标和记录无处不在" class="headerlink" title="目标和记录无处不在"></a>目标和记录无处不在</h2><p>炮制一个目标变得再容易不过了——对我们更有害的是，受那些旨在让生活变得更轻松便利的设备的哄诱，我们走上了一条错综复杂的道路。</p>
<h2 id="成功是通往失败的路标"><a href="#成功是通往失败的路标" class="headerlink" title="成功是通往失败的路标"></a>成功是通往失败的路标</h2><p>如果把生活当成一连串有待完成的里程碑，你就陷入了“一种近乎连续失败的状态”。按照定义，你任何时候都并不置身于体现了你所定义的成就或成功的地方。而一旦到达了那里，你会发现，你弄丢了那件赋予了你目的感的事情——于是你只好制订新的目标，重新开始。</p>
<h2 id="“差一点儿就赢了”好过“总是赢”"><a href="#“差一点儿就赢了”好过“总是赢”" class="headerlink" title="“差一点儿就赢了”好过“总是赢”"></a>“差一点儿就赢了”好过“总是赢”</h2><p>他很可能明天会接着玩，后天也一样，因为在荷马看来，这不是输。这是“差一点儿就赢了”。<br>游戏里都藏着这种潜在收费。一开始，游戏是免费的，但后来你被迫支付内置费用才能继续玩下去</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>爆裂鼓手：卓越</title>
    <url>/p/393dc713.html</url>
    <content><![CDATA[<p><img src="/images/blog_blgs_cover.jpg" alt=""></p>
<p>天才是数不尽的重复锻炼出来的，卓越的代价是不断逼迫自己去进步，只有热爱能带来一刻的安宁。</p>
<a id="more"></a>

<h2 id="斗志"><a href="#斗志" class="headerlink" title="斗志"></a>斗志</h2><p>一开始老师的一举一动都让 Andrew 非常在意，在意到不敢表现自己，不敢将自己的真正情感激发出来，这时候的 Andrew 是活在老师的“节奏”中。老师的一句表扬他会微微一笑，冲他怒吼他会默默流泪，因为别的鼓手被表扬，他会当面顶撞老师。从始至终他都活在老师“话语中”。</p>
<p>这种嫉妒和怨恨态度激发出一个一心想成为最优秀的鼓手，Andrewq 为了成为第一鼓手，每天疯狂练习打鼓，用了一片又一片创可贴来包裹流血的手也要坚持下去，就为了让敲鼓的速度比别人快！但是成就 Andrew 的还是他自己，Andrew 是怀有真正热爱的 drummer，这种感情超越了与别人竞争的动力，别人上台需要乐谱，而Andrew 在没有谱的情况下上台演奏，乐谱早已经在他的心中。</p>
<h2 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h2><p>在最后上台演奏的时候，Andrew 才真正找到了自己的“节奏”，这段演奏的乐谱只有在 Andrew 心中，最后老师终于愿意配合 Andrew 来进行指挥。当 Andrew 拥抱父亲时，他抹杀掉了之前的自己，他不再是一心想成为第一的鼓手，也不是过去那个懦弱的男孩，他不再在意其他人，而是真正找到了自己的 “Tempo”。</p>
<h2 id="完美"><a href="#完美" class="headerlink" title="完美"></a>完美</h2><p>There are no two words in English language more harmful than “good job”.</p>
<p>没有人能够正真达到完美，但每天都要对自己有要求，每天哪怕进步一点点。</p>
<p>永远不要停留在别人口中的 “good job”。那是别人标准，而真正的标准应该是由自己来定。我想成为什么样的人只有自己知道。在生活中有很多时候我们不知道该如何选择，我们会考虑经济原因，家人朋友的态度等。其实做选择时你只要在心里定一个目标，看看自己做的选择是否理目标更近。</p>
<h2 id="精彩台词"><a href="#精彩台词" class="headerlink" title="精彩台词"></a>精彩台词</h2><p>I’d rather die drunk, broke at 34 and have people at a dinner table talk about me than live to be rich and sober at 90 and nobody remembered who I was.</p>
<p>You walk in here an alternate, who knows you could be the new core.</p>
<p>I don’t care too much. </p>
<p>I think it just it changes. </p>
<p>You know,people change and things work out.</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>波西米亚狂想曲：音乐的力量</title>
    <url>/p/b4e213f6.html</url>
    <content><![CDATA[<p>皇后乐队，一群格格不入的人组成的乐队，敢于突破套路，挑战自己，给这个世界带来不一样的音乐。<br>音乐。</p>
<a id="more"></a>

<p>作为一名理工出身的人，我对艺术的了解很有限，对音乐的聆听也是这几年才有点体会，过去音乐只是我作业或看书的bgm，但现在慢慢能体会到，有些音乐中包含着的情感和理念，它们不只是好听。</p>
<p>在2018年，我第一次购买降噪耳机，在家中倾听鬼束千寻《月光》里的呐喊、莫文蔚《十七岁的果实》里面的青涩、牛尾憲輔《crybaby》中的狂暴、Sarah Brightman《斯卡布罗集市》中的空灵、王菲《匆匆那年》里的思念，真的是享受啊！</p>
<p>而《波西米亚狂想曲》让我对创作者的形象有了更多理解，创作者们为了专辑的歌曲苦恼、为了录音的效果苦恼、为了新歌的创作苦恼、为了演唱表演苦恼，一切是为了把最好的效果展现给听众，来换取欢呼和掌声。<br>这种感染力发挥到极致的表现，就是在最后的演唱会上，在乐队的表演时，几万人随着节拍互动、拍手、歌唱，这堪称奇迹。</p>
<h2 id="弗雷迪·默丘里"><a href="#弗雷迪·默丘里" class="headerlink" title="弗雷迪·默丘里"></a>弗雷迪·默丘里</h2><p>作为乐队的主唱，弗雷迪是才华横溢天才，在乐队中也是闪亮的人物，但在创作的光辉下面，是自我的矛盾，对于家庭的约束、自我性取向的迷惘、创作的苦恼，而弗雷迪最终选择热烈的追求生命、追求自我，勇敢得面对一切。家规严谨的家庭与他和解、他的爱人和朋友能够支持他，团队的争吵最终总是为了更好的创作，也许正因为能够有家庭、爱人、朋友一路陪伴，才为世界带来许多不朽的音乐吧。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>物我两忘--《箭术与禅心》</title>
    <url>/p/1cee4169.html</url>
    <content><![CDATA[<p>技术的学习可以通过重复、模仿来实现，那么心灵、心性该怎么学习呢？本来就无形的事物能怎么改变它呢？本书给出的答案是回归于生活，通过重复某种刻意的行为去影响心灵，箭道通过定式射箭、坐禅冥想、呼吸放松让学生放松、集中、无念，把握住空灵的瞬间，不受杂念影响，进入某种忘我的境界。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>海瑞格教授过世于 1955 年。他生前只出版了一本书，就是本书「箭术与禅心」。后来在他的文札中发现许多关于禅宗理论的笔记， 经过海瑞格夫人的整理，编辑成书，在德国出版时书名就叫做「禅道」 (Der Zen-Weg)。</p>
<p>海瑞格夫妇在日本学习「禅道」，通过在键藏粟(Kenzo Awa)门下学习箭道来学习「禅」，在本书中记录下对技·艺·道的学习经历，分享对箭道和禅道的理解。</p>
<h2 id="箭道是一种运动吗？"><a href="#箭道是一种运动吗？" class="headerlink" title="箭道是一种运动吗？"></a>箭道是一种运动吗？</h2><p>箭术的「大道」(Great Doctrine)有极不同的说法。根据「大道」，箭 术仍然是生死攸关的大事，是射手与自身的战斗;这种战斗不是虚假 的替代，而是一切外在战斗的基础，包括与一个有形对手的战斗。射 手在与自己的战斗中揭露了这项艺术的秘密本质，虽然舍弃了武士斗争的实用目标，也不会降低它的任何实质意义。</p>
<h2 id="箭道的追求是什么？是射中靶子吗？"><a href="#箭道的追求是什么？是射中靶子吗？" class="headerlink" title="箭道的追求是什么？是射中靶子吗？"></a>箭道的追求是什么？是射中靶子吗？</h2><p>这项战斗是射手不瞄准自己地瞄准了自己，不击中自己地击中了自己，因此射手同时成为了瞄准者与目标，射击者与箭靶。或者，使用更接近大师心意的说法，就是射手必须克服自我，成为一个不动的中心。然后就会发生最大与最终极的奇迹:艺术成为「无 艺术」，射击成为无射击，没有弓与箭的存在;</p>
<h2 id="如何用力拉弓？"><a href="#如何用力拉弓？" class="headerlink" title="如何用力拉弓？"></a>如何用力拉弓？</h2><p>拉弓时不要用上全身的力气，而要学习只让两手用力，肩膀与手臂的肌肉是放松的，彷佛它们只是旁观者似的。只有当你们做到了这一点，才算是完成了初步的条件，使拉弓与放箭『心灵化』。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>「真正的艺术，」师父叫道，「是无所求的，没有箭靶!你越是顽 固地要学会射箭击中目标，你就越无法成功，目标也离你越来越远。 阻碍了你的，是你用心太切。你认为如果你不自己去做，事情就不会发生。」</p>
<h2 id="胜负"><a href="#胜负" class="headerlink" title="胜负"></a>胜负</h2><p>就算你每箭都射不中，你仍然可以成为一个师父。射中箭靶 只是外在的证明，表示你的无所求，无自我，放开自己…不管你如何 称呼这种状态，已经达到了颠峰。熟练的程度也有等级之分，只有当你到达了最高的一级，才能百发百中。</p>
<h2 id="集中"><a href="#集中" class="headerlink" title="集中"></a>集中</h2><p>你们必须在路上就开始收心。把你的心神集中于练习厅中所发生的事。视若无睹地经过其它一切，彷佛这个世界上只有一件事是重要而且真实的，那就是射箭!</p>
<h2 id="技艺"><a href="#技艺" class="headerlink" title="技艺"></a>技艺</h2><p>老师绝不会想过早使学生成为艺术家，他的首要考量是使学生成 为一个技巧纯熟的工匠，对自己的手艺有完全的控制。</p>
<h2 id="无我-—-无喜无悲"><a href="#无我-—-无喜无悲" class="headerlink" title="无我 — 无喜无悲"></a>无我 — 无喜无悲</h2><p>射失了不要难过，射好了也不要高兴，必须使自己解脱于快乐与痛苦的冲击，学习平等超然得对待它们，你的高兴要像是为了别人射得好而高兴，不是为了你自己。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
        <tag>mind</tag>
      </tags>
  </entry>
  <entry>
    <title>沧浪之水：权利与话语权</title>
    <url>/p/d1d96956.html</url>
    <content><![CDATA[<p>沉默的大多数</p>
<a id="more"></a>
<h2 id="话语权"><a href="#话语权" class="headerlink" title="话语权"></a>话语权</h2><p>可以说整个小说都在探讨这个话题。话语，是声音、表达、希望、以及要求。人人都应该有表达的权利以及希望的权利，话语权利的实现体现着意识的自由与存在的被尊重，所谓七嘴八舌百家争鸣就是普及了话语权的美妙现象。而权利话语，是一种占主导地位甚至统治地位的话语，与政治、商业、经济、世俗幸福有密切关系，权利话语通常充当着凶手与刺客的作用，谋杀着话语权利以及原本应该存在的话语。池大为刚进卫生厅的时候，觉得：沉默不仅是对良知的压抑，简直就是对自尊心的挑战。于是，他主动发表自己的观点，认为应该尊重自己内心的呼唤，可是，就是这呼唤，带给了他无限的苦恼、折磨、以及无奈。</p>
<h2 id="沉默"><a href="#沉默" class="headerlink" title="沉默"></a>沉默</h2><p>法律告诉我们：您有权保持沉默。某些时候，沉默是唯一的出路，唯一保全自己的选择，默认、对抗、忽略，都可以通过沉默来表达，比话语更有力，比话语更有利。沉默很暧昧，理解沉默有多种可能，从而，沉默起到保护当事者的作用，是适者生存的重要方式。但是，当对抗以及忽略不被允许的时候，沉默就只能被理解为默认了，某些时候，默认话语权利很可能违反权利话语的利益，给沉默者带来灾难以及祸患，因此，小莫情愿在天黑之后给池大为道歉也要在大会上发表对池大为的不满。</p>
<h2 id="人性"><a href="#人性" class="headerlink" title="人性"></a>人性</h2><p>不管作者有意无意，都反映出人的精神追求与现实利益之间的矛盾。从人的本性来说，人自身是要求全面发展的。在精神上要求人格的独立、做人的尊严，希望向外界证明自己的价值，这没有问题；在物质上，追求金钱、物质利益和生命的欲望，这也没有问题，都是正常人性的一部分，但二者一旦构成了矛盾，便使善与恶、荣与辱、崇高与堕落都无可躲避地交织在了一起</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>用python将文本中每一行的开头中间结尾插入字符</title>
    <url>/p/557a0119.html</url>
    <content><![CDATA[<p>遇到一个问题，需要编辑一个txt文本，在开头、中间、结尾处插入字符“|”，由于文本很长，用手工操作太浪费时间，就用python写个脚本来处理，记录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1 &#x3D; open(r&#39;one.txt&#39;)</span><br><span class="line">fw &#x3D; open(r&#39;two.txt&#39;,&#39;a+&#39;)</span><br><span class="line"></span><br><span class="line">with f1 as f:</span><br><span class="line">	for line in f:</span><br><span class="line">		# print line</span><br><span class="line">		line &#x3D; line.strip(&#39;\n&#39;) &#x2F;&#x2F;移除结尾了换行</span><br><span class="line">		each_line_list&#x3D;list(line)&#x2F;&#x2F;转换成list</span><br><span class="line">		each_line_list.insert(0,&quot;|&quot;)</span><br><span class="line">		each_line_list.insert(20,&quot;|&quot;)</span><br><span class="line">		fw.writelines(&quot;&quot;.join(each_line_list)+&#39;|&#39;+&#39;\n&#39;)</span><br><span class="line">f1.close()</span><br><span class="line">fw.close()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这世上有两种程序员，一种会脚本，另一种不会。</p>
]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>白蛇缘起·中国特色的美式动画</title>
    <url>/p/7d46625d.html</url>
    <content><![CDATA[<p>对于动画作品，我认为它的一个特色在于能够容纳更多题材，创作广度比电影大得多，《白蛇缘起》这部电影，让我看到了中美团队合作下，取美国3D动画的成熟顺畅，中国剧情与画风的柔和优雅，在2019年创作出这样的作品绝对是一种进步。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>空之境界·伽蓝之洞：实体与视界</title>
    <url>/p/e9fa88bf.html</url>
    <content><![CDATA[<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>人是实体，如果没有实体，人无法感知世界。</p>
<h2 id="视界"><a href="#视界" class="headerlink" title="视界"></a>视界</h2><p>人是通过实体上的感觉器官来感知世界的，通过眼来看色彩和形状，通过耳来听声音，通过鼻来闻气温，通过人格产生喜怒哀乐，每个人都有一套类似但不完全相同的器官，本质上讲每个人感知到的都不完全相同。</p>
<p>两仪本身具备式和织两种人格，而且是能同时存在，因此她的视界比普通人复杂。</p>
<h2 id="伽蓝之洞"><a href="#伽蓝之洞" class="headerlink" title="伽蓝之洞"></a>伽蓝之洞</h2><p>由于起源为 [ ]，两仪有将一切归于 [ ] 的冲动，表现在人类身上就是想杀人，在《空之境界·杀人考察上》中，在面对杀黒桐干也的矛盾时选择自杀，在生死徘徊中，织死式活，昏迷两年再次醒来，实体少了一个人格导致视界和记忆不相容，就像一觉醒来世界只剩下黑白两色的荒谬，人格产生剧烈的空洞感。</p>
<h2 id="存在"><a href="#存在" class="headerlink" title="存在"></a>存在</h2><p>黒桐干也两年的等待，坚持不变的信念和情感是两仪式回归生活的锚点，是过去两仪式存在的证明。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
        <tag>mov</tag>
        <tag>mind</tag>
      </tags>
  </entry>
  <entry>
    <title>童话的魅力</title>
    <url>/p/a19b059a.html</url>
    <content><![CDATA[<p>很多成人覺得童話講述的是與現實相距甚遠故事，因此不利於讓孩子們學會面對現實。在我看来，童話在用孩子們能夠理解的方式教導他們如何應對成長中的恐懼。</p>
<a id="more"></a>
<h2 id="天真可爱的童话"><a href="#天真可爱的童话" class="headerlink" title="天真可爱的童话"></a>天真可爱的童话</h2><p>我们对童话的定位似乎总是天真浪漫，无忧无虑，但对于孩童来说,童话，是通往成熟通道，儿童通过童话应对成长中的恐惧，学习成熟与独立，处理情感危机，与父亲抗争，与母亲别离，在自我、本我和超我中了解自身。</p>
<p>通过去分析，提高儿童的逻辑能力，在同情和共鳴中，以自我代入的方式，應對成長中可能會遭遇的迷茫、傷害、恐懼……</p>
<h2 id="童话中有常用隐喻："><a href="#童话中有常用隐喻：" class="headerlink" title="童话中有常用隐喻："></a>童话中有常用隐喻：</h2><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>“三”的重複：童話故事中總是會出現三個兄弟、三個考驗、三次機會……這些“三”有些是完全重複的，有些是遞進或者形態不同的。不過這種“三”所對應的，大部份情況是自我、本我和超我；</p>
<h3 id="继母和女孩"><a href="#继母和女孩" class="headerlink" title="继母和女孩"></a>继母和女孩</h3><p>“繼母”的設定以及被趕出家門等等……：繼母這一設定，其中一種解釋是幫助孩子們理解父母對於自己態度的轉變。書中有提到一個案例，一個小孩子在媽媽態度變得很暴躁的時候，就會幻想自己的媽媽是被一個邪惡的繼母取代了；另一種作用，故事中往往繼母到來之後，主人公就會被逐出家門，這一點是在講述孩子們總就是要離開以前的庇護，經歷磨難才能幸福。並且故事中，孩子們在有親生母親的幸福日子往往是一筆帶過的，因為：幸福無憂的嬰兒時期，雖然受到完全的保護，確實空蕩蕩的。</p>
<p>關於女孩的童話：很多關於性早熟的禁忌。童話中的代表就是《睡美人》。童話中因為被紡錘尖扎傷而滴下的鮮血是失去童貞的象徵。而在心理沒有成熟時期的性覺醒所帶來的恐懼，在《睡美人》中被無盡的長眠所替代。在故事中，提到很多王子來喚醒公主，都沒有成功，其實是因為公主並沒有成熟到能夠應對兩性關係。公主最終的蘇醒，代表的是個人和性心理雙方面的完全成熟。</p>
<p>巨人、恶人、巫师、巨龙 父辈</p>
<h2 id="童话的理性思考"><a href="#童话的理性思考" class="headerlink" title="童话的理性思考"></a>童话的理性思考</h2><p>作者Bruno Bettelheim是一名奥地利裔的美国儿童心理学家，作家。他的作品深受弗洛伊德一派的心理分析学的影响。在当时西方社会的一片对童话作品负面评价的风潮之下，Bettelheim的这本书肯定了童话故事对儿童心理发展的正面意义。认为童话这种以象征为主要手法的文学形式，能够最有效的帮助缓解儿童在心理发展的初期阶段内在的情绪障碍，学会处理暂时无法识别与消化的心理矛盾，指引儿童日后对感性和理性的发展与掌控，处理内心领域与现实世界的关系，从而建立健康与完善的人格.</p>
<p>当时的西方社会有很多学者提出，童话中阴暗的反面角色与脱离现实的故事情节于儿童的心理发展无益，应该被更加正面和现实的当代故事所代替，这种做法似乎试图使儿童认为人性的阴暗面并不真实存在，将他们“保护”在一个纯粹至善的世界里；而Bettelheim则认为，童话故事里的各种亦正亦邪的人物及其行为刚好与儿童内心世界各样混乱而无法梳理的情绪相对应，童话里的这些简单明确的因素使儿童无意识的内在感受实体化，比如对被遗弃的恐惧，弟兄姐妹之间的原始竞争，恋母情结等，从而帮助他们更好的消化这些正常的不良情绪，为这些压抑和无处释放的心理困境找到出路。</p>
<h2 id="童话的象征和隐喻"><a href="#童话的象征和隐喻" class="headerlink" title="童话的象征和隐喻"></a>童话的象征和隐喻</h2><p>童话里对象征与隐喻手法的使用，使它变的不那么具有攻击性和目的性，令儿童能在娱乐的同时更放松的运用想象力产生对角色的代入感，这与说教性质的教育方法截然不同。童话在隐喻中以更间接的方式促使儿童更真挚的的直接参与与个人体验，从而共同完成一项更深层的心理启发与指引。作者还提出，给童话故事添加插图的做法尤其不值得提倡，因为插图减弱了童话与孩子心理互动的个体性，抑制了个人想象力的发散，成人的视觉符号反而阻碍了儿童对角色的代入感。</p>
<p>Bettelheim认为童话相比较于神话故事，更呈现了乐观主义的精神面貌。除了童话里完美结局的设定以外，他认为神话故事更侧重于遵循精神分析学里“超我”的原则，令孩子因为感到无法达到神话超人类的高度而丧气；而童话里人物受继母排挤的小女孩，抑或是聪明又能干的小猪，都带着平实的人性，与听故事的孩子没有太大的距离感，更使得他们能够因着故事主角的经历受到鼓舞。</p>
<p>作者在书中探讨了魔法的重要性以及梦境与童话的联系，还深入剖析了大量为大众熟知的童话故事的心理学意义。我认为若将Bettelheim对童话的心理学分析与Donald W . Winnicott所提出的“过渡客体”的理论相提并论，可以说童话也是一种过渡客体的形式。首先童话如同那些毛绒玩具，或者熟悉的小毯子，对儿童而言都有特殊的象征意义，用来模拟内心世界在发育初期无法抒发或者协调的感受或情结。其次，童话最正确的打开方式似乎是得由父母声情并茂的反复讲诉，重复性助于产生一种依恋从而使它更深入孩子的心理世界。总有一两个故事非要吵着听到他们才能入睡，如同必须抱着入眠的毛绒小兔子一样。过渡客体旨在协调儿童的内在现实与外在现实的一致性与和谐度，介于幻想与现实的中间地带，在成人之后，这一领域也成为主要发展文化认知，艺术，以及宗教的特殊地带。</p>
<h2 id="童话的积极引导"><a href="#童话的积极引导" class="headerlink" title="童话的积极引导"></a>童话的积极引导</h2><p>书中还提到了英国作家C.S Lewis以及G.K.Chesterton对于童话故事的肯定与赞赏，认为它们是“灵性的探索”，以及“最接近生活的”。Lewis的一个重要身份之一便是儿童文学作者，他写的《纳尼亚传奇》已经成为当代童话的经典。Chesterton在《回到正统》书中的一章“仙域的伦理”中探讨童话的特殊意义:“我恪守如一的哲学，是从幼儿园学回来的，我对此从没半点怀疑。我大体从一个保姆——一个民主暨传统，神圣而典雅的女祭司学会了有关道理。那时候我最相信的和现在我最相信的东西，同样是童话故事。对我来说，童话故事完全通情达理，它们不是幻想：相比之下，其他东西反而显得奇形怪状。相比之下，宗教和理性主义同样是不正常的；虽然宗教是不正常的正确，而理性主义是不正常的错误。”“我在这里想弄清楚的是，童话世界究竟带来了什么伦理与哲学。只要细加诉说，不难发现很多高尚而有益的原则，都是源自童话故事。《巨人克星杰克》带来了隐含骑士精神的教训：巨人必须杀掉，因为他们是庞然巨物。这是人类勇敢的叛变，对抗如巨人般庞大的骄傲。。。此外，《灰姑娘》带来了像《圣母玛利亚颂》的教训：“叫卑贱的升高”。此外，《美女与野兽》带来了另一则伟大的教训：爱一样东西，一定要在他尚未成为可爱的对象之前。还有，《睡美人》这个可怕的寓言，讲述了人类虽然满有生之福气，却让死亡咒诅着；而死亡又或可软化为睡眠。凡此种种，我关心的不是仙域个别的法规，而是仙域整体的律法精神。这种精神我未懂说话已经学会，将来就是不能写作也不会忘记。我关心的是某种看待生命的方式。童话故事在我心中创造了这种方式，然后具体的事实又悄悄的加以确认。”切斯特顿认为用“魔法”而不是“定律”来理解客观世界的种种事实是至关重要的，因为“科学书籍使用的诸如“定律”“必然性”“秩序”等术语的确有违智性，因为这些用语假定了一种透析核心的综合，而这种综合并不存在。而“魅力”“魔力”“迷惑”等这些词语表达了事实的随意性以及奥妙之处。</p>
<p>有的时候超现实的世界比童话更不真实。</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>我认为童话的格式与构造是所有文体中最直接在人心理层面起作用的，而隐喻是它最大的魅力所在。美从来都不是侵略性的，而是愉悦的邀请。<br>甚至对于成年人来说，童话性质的故事总是令人乐在其中，因为它所产生的思考是多向性并且个人化的，每个人都能从故事的细枝末节里找到自己的影子。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>竹光侍：浮世绘下的人心善恶</title>
    <url>/p/a811b39e.html</url>
    <content><![CDATA[<p><img src="imags/blog_zhuguangshi_cover.jpeg" alt=""></p>
<p>《竹光侍》风格非常独特，以浮世绘画风为主，融和速写、水墨、风俗画、现代漫画等多种艺术形式，多点透视，散点透视切换运用非常自然。</p>
<a id="more"></a>

<p>不同于浮世绘偏重工笔细腻色泽艳丽，作者松本大洋将水墨写意的笔法融入其中，用色也趋于平和柔顺，于淳朴的古风中透出浑然天成的气韵。扁平化带有解构主义的人物造型加入投影让画面刹那立体鲜活起来，平面的人物在自成一派的空间内有了体积，有了生命。</p>
<h2 id="浮世绘"><a href="#浮世绘" class="headerlink" title="浮世绘"></a>浮世绘</h2><p><img src="imags/blog_zhuguangshi_01.jpeg" alt=""></p>
<p>做为一个漫画家，最可贵的应该就是在画功和故事上同时拥有一流的水准和感染力。如同他的画面，松本大洋的作品在其内容方面体现了一种完全超越商业化等束缚的纯粹的表达欲，表达的都是最真诚的感受和震撼人心的情感。</p>
<p><img src="imags/blog_zhuguangshi_03.jpeg" alt=""></p>
<p>有些画面简陋至极，但该表达想表达的内容都没拉下，无论是人物还是行为都描述得非常清晰。</p>
<h2 id="人心善恶"><a href="#人心善恶" class="headerlink" title="人心善恶"></a>人心善恶</h2><p><img src="imags/blog_zhuguangshi_04.jpeg" alt=""></p>
<p>主角宗一郎来到江户，心性却仍是那个跟山对话的少年。对一切抱有好奇，充满想象。他能和孩子们打成一片，和猫狗聊天，甚至喊停雷神，也就毫不意外。大三郎是另一个天真的人物。其充满对古典时代的英雄怀想，又有一保守的随从，于是很有几分堂吉诃德的影子。</p>
<p>另一方面，宗一郎剑技高超，江户的各大道场无人能敌，而他对自身的力量、内心的暴力冲动感到恐惧，卖掉宝刀克制杀戮，横扫剑道道馆后主动保密，只是随身佩带的竹刀表示还没放下一身剑技。</p>
<p>但命运没有放过他，杀戮还是找上门来。</p>
<p><img src="imags/blog_zhuguangshi_05.jpeg" alt=""></p>
<p>本作的高潮是和杀手木久地的对决，在故事推进中慢慢显现两人内心，在泠冽、决绝的交锋中，两人都化身纯粹的恶鬼。</p>
<p>艺术的表达基于现实，但可以远远超脱现实。</p>
<p><img src="imags/blog_zhuguangshi_06.jpeg" alt=""></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看《竹光侍》，为墨色、构图而战栗。在这样的灰色光线中，被故事蒙惑，心里有着蠢动。绘画，不臻至极致就不可能驾驭形式，形式一旦低伏，图会有生命，透着内容想要传达的气息、温度。在这样的作品面前，相似的题材或者人物便只是一张白纸了。</p>
<p><img src="imags/blog_zhuguangshi_07.jpeg" alt=""></p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>简单算法：实现strStr()</title>
    <url>/p/4fc0a09c.html</url>
    <content><![CDATA[<h1 id="实现-strStr-函数。"><a href="#实现-strStr-函数。" class="headerlink" title="实现 strStr() 函数。"></a>实现 strStr() 函数。</h1><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h2 id="Code-C"><a href="#Code-C" class="headerlink" title="Code-C"></a>Code-C</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strStr(char* haystack, char* needle) &#123;</span><br><span class="line">  if (*haystack &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *needle !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (*needle &#x3D;&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  while (haystack[index] !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">    if (haystack[index] &#x3D;&#x3D; *needle) &#123;</span><br><span class="line">      &#x2F;&#x2F;first index</span><br><span class="line">      char* temp &#x3D; needle;</span><br><span class="line">      int tempIndex &#x3D; index;</span><br><span class="line">      while (haystack[tempIndex] &#x3D;&#x3D; *temp) &#123;</span><br><span class="line">        tempIndex++;</span><br><span class="line">        temp++;</span><br><span class="line">        if (*temp &#x3D;&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">          return index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不使用系统api，简单的指针寻址比较字符串</p>
<p>再贴个干净点的做法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strStr(char* haystack, char* needle) &#123;</span><br><span class="line">    int len1 &#x3D; strlen(haystack);</span><br><span class="line">    int len2 &#x3D; strlen(needle);</span><br><span class="line">    int i,j,cnt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (len2 &#x3D;&#x3D; 0) return 0;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; len1 - len2 + 1; i++) &#123;</span><br><span class="line">        cnt &#x3D; 0;</span><br><span class="line">        for (j &#x3D; 0; j &lt; len2; j++) &#123;</span><br><span class="line">            if (haystack[i+j] &#x3D;&#x3D; needle[j]) &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &#x3D;&#x3D; len2) return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础：字符串</title>
    <url>/p/96bf0c06.html</url>
    <content><![CDATA[<p>题目：</p>
<p>实现一个函数，把字符串中的每个空格替换成“###”</p>
<p>code：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static  void Replace(char string[])&#123;</span><br><span class="line">        if (string &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    int originalLength &#x3D; 0;</span><br><span class="line">    int numberOfBlank &#x3D; 0;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while(i&lt;string.length)&#123;</span><br><span class="line">      originalLength++;</span><br><span class="line">      if (string[i] &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">        numberOfBlank++;</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    int newLength &#x3D; originalLength+numberOfBlank*2;</span><br><span class="line">    char[] newString &#x3D; new char[newLength];</span><br><span class="line">    System.out.println(&quot;string.length:&quot;+string.length+&quot;,newLength:&quot;+newLength);</span><br><span class="line"></span><br><span class="line">    int indexOfNew &#x3D; newLength-1;</span><br><span class="line">    int indexOfOriginal &#x3D; originalLength-1;</span><br><span class="line">    while(indexOfOriginal &gt;&#x3D;0 &amp;&amp; indexOfNew &gt;&#x3D; indexOfOriginal)&#123;</span><br><span class="line">      if (string[indexOfOriginal] &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">        newString[indexOfNew --] &#x3D; &#39;#&#39;;</span><br><span class="line">        newString[indexOfNew --] &#x3D; &#39;#&#39;;</span><br><span class="line">        newString[indexOfNew --] &#x3D; &#39;#&#39;;</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        newString[indexOfNew --] &#x3D; string[indexOfOriginal];</span><br><span class="line">      &#125;</span><br><span class="line">      indexOfOriginal--;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(&quot;newString:&quot;);</span><br><span class="line">    System.out.println(newString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础：字符串中的第一个唯一字符</title>
    <url>/p/7dfc482c.html</url>
    <content><![CDATA[<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>案例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">返回 0.</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;,</span><br><span class="line">返回 2.</span><br></pre></td></tr></table></figure>

<p>注意事项：您可以假定该字符串只包含小写字母。</p>
<p>O(n)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int firstUniqChar(char* s) &#123;</span><br><span class="line">  int len &#x3D; strlen(s);</span><br><span class="line">  if (len &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    k &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">      if (s[i] &#x3D;&#x3D; s[j] &amp;&amp; i!&#x3D;j) &#123;</span><br><span class="line">        k &#x3D; 1;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (k &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  char a[] &#x3D; &quot;teetcode&quot;;</span><br><span class="line">  int b &#x3D; firstUniqChar(a);</span><br><span class="line">  printf(&quot;%d\n&quot;, b);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>O(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int firstUniqChar(char* s) &#123;</span><br><span class="line">    int d[26]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    int t;</span><br><span class="line">    for(i&#x3D;0;s[i]!&#x3D;&#39;\0&#39;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t&#x3D;s[i]-&#39;a&#39;;</span><br><span class="line">        d[t]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int k &#x3D; 0; k &lt; 26; k++) &#123;</span><br><span class="line">      printf(&quot;%d--\n&quot;, d[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i&#x3D;0;s[i]!&#x3D;&#39;\0&#39;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t&#x3D;s[i]-&#39;a&#39;;</span><br><span class="line">        if(d[t]&#x3D;&#x3D;1)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a～z总共26个字符，建立一个26位的数组，记录每个字符的出现次数即可，本质类似哈希字典。</p>
]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础：整数反转</title>
    <url>/p/9de29056.html</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int reverse(int x) &#123;</span><br><span class="line">    long long y&#x3D;0;</span><br><span class="line">    &#x2F;&#x2F;pow(x,y),math.h的函数，计算x的y次幂</span><br><span class="line">    int max &#x3D; pow(2,31)-1;</span><br><span class="line">    int min &#x3D; pow(-2,31);</span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp&#x3D;y;</span><br><span class="line">        y&#x3D; y*10+x%10;</span><br><span class="line">        if( y &gt; max || y&lt;min)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        x&#x2F;&#x3D;10;</span><br><span class="line">    &#125;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a &#x3D; -1534236469;</span><br><span class="line">  int b &#x3D; reverse(a);</span><br><span class="line">  printf(&quot;%d\n&quot;, b);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：两数之和</title>
    <url>/p/5352bc23.html</url>
    <content><![CDATA[<p>定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]<br>暴力搜索</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>int *twoSum(int* nums, int numsSize,int target){

    int *array = (int*)malloc(2*sizeof(int));

    for (int i = 0; i &lt; numsSize-1; i++) {
        for (int j = 1; j &lt; numsSize; j++) {
            if (nums[i]+nums[j] == target) {
                array[0] = i;
                array[1] = j;
            }
        }
    }
    return array;
}
``

## 复杂度

时间：O（n^2）

空间：O（1）
</code></pre>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：二维数组查找</title>
    <url>/p/ac19d913.html</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以说是最简单的一种数据结构，它占据一块连续的内存并按照顺序存储数据。创建数组时，我们需要先指定数组的容量大小，然后根据大小分配内存。即使我们只在数组中存储一个数字，也需要为所有的数据预先分配内存。因此数组的空间效率不是很好，经常会有空闲的区域没有得到葱粉利用。</p>
<p>题目：</p>
<p>二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数；</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean Find(int[] matrix, int rows, int columns, int number)&#123;</span><br><span class="line">        boolean found &#x3D; false;</span><br><span class="line">        if (matrix !&#x3D; null &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0) &#123;</span><br><span class="line">            int row &#x3D; 0;</span><br><span class="line">            int column &#x3D; columns - 1;</span><br><span class="line">            while (row &lt; rows &amp;&amp; column &gt;&#x3D; 0)&#123;</span><br><span class="line">                if (matrix[row * columns + column] &#x3D;&#x3D; number) &#123;</span><br><span class="line">                    found &#x3D; true;</span><br><span class="line">                    System.out.println(&quot;location at row: &quot;+row +&quot;,column: &quot;+column);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (matrix[row * columns + column] &gt; number) &#123;</span><br><span class="line">                    column--;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    row ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return found;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：反转字符串</title>
    <url>/p/d792e30d.html</url>
    <content><![CDATA[<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<a id="more"></a>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void reverseString(char* s, int sSize) &#123;</span><br><span class="line">  if (sSize &lt; 2)&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  char sample &#x3D; &#39; &#39;;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; sSize; i++) &#123;</span><br><span class="line">    int j &#x3D; sSize-1-i;</span><br><span class="line">    if (j&lt;&#x3D;i) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    sample &#x3D; s[i];</span><br><span class="line">    s[i] &#x3D; s[j];</span><br><span class="line">    s[j] &#x3D; sample;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(n)</p>
<p>空间:O(1)</p>
]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：买卖股票的最佳时机</title>
    <url>/p/5be8d45f.html</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>峰值和谷底的确定，可以把数组看成连续的波形图，定位每一段的峰值–谷值就得到该段的最优买卖收获</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line"></span><br><span class="line">  if (pricesSize &#x3D;&#x3D; 0 || pricesSize &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int tem &#x3D; prices[0];</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  int isBottom &#x3D; prices[1] &gt; prices[0];</span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 1; i &lt; pricesSize; i++) &#123;</span><br><span class="line">    if (isBottom &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      if (i &#x3D;&#x3D; pricesSize-1 || prices[i] &gt; prices[i+1]) &#123;</span><br><span class="line">        sum &#x3D; sum + prices[i]-tem;</span><br><span class="line">        isBottom &#x3D; 0;</span><br><span class="line">        printf(&quot;is max at index %d\n&quot;, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      if (i !&#x3D; pricesSize-1 &amp;&amp; prices[i] &lt; prices[i+1]) &#123;</span><br><span class="line">        tem &#x3D; prices[i];</span><br><span class="line">        isBottom &#x3D; 1;</span><br><span class="line">        printf(&quot;is bottom at index %d\n&quot;, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>空间：O（1）</p>
<p>时间：O（1）</p>
]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：替换空格</title>
    <url>/p/474ab660.html</url>
    <content><![CDATA[<p>请实现一个函数，把字符串中的每个空格替换成“%20”。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>字符替换、排序、内存操作优化</p>
<h2 id="analyse"><a href="#analyse" class="headerlink" title="analyse"></a>analyse</h2><p>假设长度20的字符串“123 456 789”，存储位置如下：</p>
<p>[123 456 789\0&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;]</p>
<p>如果从头查找空格替换，则每次需要移动的数据如下：</p>
<p>[123%20456 789\0&amp;&amp;&amp;&amp;&amp;&amp;]</p>
<p>[123%20456%20789\0&amp;&amp;&amp;&amp;]</p>
<p>部分字符需要移动多次，时间复杂度为O（n^2）</p>
<p>换种策略，先计算空格数目推算出替换后字符串的新长度，从后面遍历原字符串，遇到空格就填充‘0’‘2’‘%’，每个字符只要移动一次。</p>
<p>C语言实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void replaceBlank(char* string,int length)&#123;</span><br><span class="line">  if (string &#x3D;&#x3D; NULL || length &lt;&#x3D; 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int originalLength &#x3D; 0;</span><br><span class="line">  int numberOfBlank &#x3D; 0;</span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  while (string[i] !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">    originalLength++;</span><br><span class="line">    if (string[i] &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">      numberOfBlank++;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  int newLength &#x3D; originalLength+numberOfBlank*2;</span><br><span class="line">  if (newLength&gt;length) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int indexOfOriginal &#x3D; originalLength;</span><br><span class="line">  int indexOfNew &#x3D; newLength;</span><br><span class="line">  while (indexOfOriginal &gt;&#x3D; 0 &amp;&amp; indexOfNew &gt; indexOfOriginal) &#123;</span><br><span class="line">    if (string[indexOfOriginal] &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">      string[indexOfNew--] &#x3D; &#39;0&#39;;</span><br><span class="line">      string[indexOfNew--] &#x3D; &#39;2&#39;;</span><br><span class="line">      string[indexOfNew--] &#x3D; &#39;%&#39;;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      string[indexOfNew--] &#x3D; string[indexOfOriginal];</span><br><span class="line">    &#125;</span><br><span class="line">    indexOfOriginal--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  char a[20] &#x3D; &quot;123 456 789&quot;;</span><br><span class="line">  replaceBlank(a,20);</span><br><span class="line">  printf(&quot;%s\n&quot;, a);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这道题目中，从头开始查找的惯性思维是问题所在，在内存的存取上，应该放开思维，不需要头、尾、先、后这样的定性思路.</p>
]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：只出现一次的数字</title>
    <url>/p/58214e59.html</url>
    <content><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p>
<h3 id="first-way"><a href="#first-way" class="headerlink" title="first way"></a>first way</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int singleNumber(int* nums, int numsSize) &#123;</span><br><span class="line">  if (numsSize &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return nums[0];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int index &#x3D; 0;</span><br><span class="line">  int m &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">    if (i&lt;&#x3D;index) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;i:%d,index:%d\n&quot;, i,index);</span><br><span class="line">    if (nums[index] &#x3D;&#x3D; nums[i]) &#123;</span><br><span class="line">      int n &#x3D; nums[index+1];</span><br><span class="line">      nums[index+1] &#x3D; nums[i];</span><br><span class="line">      nums[i] &#x3D; n;</span><br><span class="line">      index &#x3D; index+2;</span><br><span class="line">      i &#x3D; index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(i &#x3D;&#x3D; numsSize -1) &#123;</span><br><span class="line">      m &#x3D; nums[index];</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>O(n)</p>
<h2 id="best-way"><a href="#best-way" class="headerlink" title="best way"></a>best way</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int singleNumber(int* nums, int numsSize) &#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[0]&#x3D;nums[0]^nums[i];</span><br><span class="line">        printf(&quot;%d\n&quot;, nums[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>O(1)</p>
<p>异或：相同为0，不同为1. 异或同一个数两次，原数不变。</p>
]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：最长公共前缀</title>
    <url>/p/450dd832.html</url>
    <content><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<a id="more"></a>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* longestCommonPrefix(char** strs, int strsSize) &#123;</span><br><span class="line">  char* str&#x3D;strs[0];</span><br><span class="line">  int i,j;</span><br><span class="line">  if(strsSize&#x3D;&#x3D;0) return &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  for(i&#x3D;1;i&lt;strsSize;i++)&#123;</span><br><span class="line">      j&#x3D;0;</span><br><span class="line">      while(str[j] &amp;&amp; strs[i][j] &amp;&amp; str[j]&#x3D;&#x3D;strs[i][j])j++;</span><br><span class="line">      str[j]&#x3D;&#39;\0&#39;;&#x2F;&#x2F;在str上记录&#39;\0&#39;，最后返回时读取到的值就是最大公共前缀</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>O(n*m)</p>
]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：有效的字母异位词</title>
    <url>/p/c2cdf3b0.html</url>
    <content><![CDATA[<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。</p>
<a id="more"></a>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><p>输入: s = “rat”, t = “car”<br>输出: false</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><p>你可以假设字符串只包含小写字母。</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><p>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isAnagram(char* s, char* t) &#123;</span><br><span class="line">    int * s_buffer;</span><br><span class="line">    int * t_buffer;</span><br><span class="line">    int s_len;</span><br><span class="line">    int t_len;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 分配空间 *&#x2F;</span><br><span class="line">    s_buffer &#x3D; (int *)malloc(sizeof(int) * 256);</span><br><span class="line">    t_buffer &#x3D; (int *)malloc(sizeof(int) * 256);</span><br><span class="line">    &#x2F;&#x2F;初始化空间内容</span><br><span class="line">    &#x2F;&#x2F;memset() 的作用是在一段内存块中填充某个给定的值。</span><br><span class="line">    memset(s_buffer, 0, sizeof(int) * 256);</span><br><span class="line">    memset(t_buffer, 0, sizeof(int) * 256);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 两个字符串大小不一致，返回false *&#x2F;</span><br><span class="line">    s_len &#x3D; strlen(s);</span><br><span class="line">    t_len &#x3D; strlen(t);</span><br><span class="line">    if(s_len !&#x3D; t_len)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 计算字符串1中各个字符的数目 *&#x2F;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; s_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s_buffer[s[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 计算字符串2中各个字符的数目 *&#x2F;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t_buffer[t[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 判断两个字符串中字符是否一致 *&#x2F;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if((s_buffer[i] !&#x3D; t_buffer[i]))</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：移动零</title>
    <url>/p/6848d225.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<a id="more"></a>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ul>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int indexZero(int* nums, int numsSize,int fromIndex)&#123;</span><br><span class="line">  int index &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; fromIndex; i &lt; numsSize; i++) &#123;</span><br><span class="line">    if (nums[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      index &#x3D; i;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int indexNoZero(int* nums, int numsSize,int fromIndex)&#123;</span><br><span class="line">  int index &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; fromIndex; i &lt; numsSize; i++) &#123;</span><br><span class="line">    if (nums[i] !&#x3D; 0) &#123;</span><br><span class="line">      index &#x3D; i;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void moveZeroes(int* nums, int numsSize) &#123;</span><br><span class="line">  if (numsSize &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">    if (nums[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      int index &#x3D; i;</span><br><span class="line">      int nextValueIndex &#x3D; indexNoZero(nums,numsSize,index);</span><br><span class="line">      int nextZeroIndex &#x3D; indexZero(nums,numsSize,nextValueIndex);</span><br><span class="line"></span><br><span class="line">      if (nextValueIndex &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (nextZeroIndex &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        nextZeroIndex &#x3D; numsSize;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int moveSize &#x3D; nextValueIndex - index;</span><br><span class="line">      for (int m &#x3D; i; m &lt; nextZeroIndex; m++) &#123;</span><br><span class="line">        if (m+moveSize&gt;&#x3D;nextZeroIndex) &#123;</span><br><span class="line">          nums[m] &#x3D; 0;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          nums[m] &#x3D; nums[m+moveSize];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      i &#x3D; nextZeroIndex - moveSize-1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>定位 0 index</li>
<li>定位下一个 非0 index2</li>
<li>定位下一个 0 index3<ul>
<li>（index2~index3）&lt;&lt;（index2-index3）</li>
</ul>
</li>
</ul>
<h2 id="Best"><a href="#Best" class="headerlink" title="Best"></a>Best</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void moveZeroes(int* nums, int numsSize) &#123;</span><br><span class="line">    int i,len&#x3D;0;</span><br><span class="line">    for(i&#x3D;0;i&lt;numsSize;i++)&#123;</span><br><span class="line">        if(nums[i]!&#x3D;0)&#123;</span><br><span class="line">            nums[len]&#x3D;nums[i];</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i&#x3D;len;i&lt;numsSize;i++)</span><br><span class="line">        nums[i]&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 遍历index</span><br><span class="line">len &#x3D; first 0 index</span><br><span class="line">if [i]!&#x3D;0,[len] &#x3D; [i]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数理</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>罗小黑战记：无家可归的人</title>
    <url>/p/fa6e93a7.html</url>
    <content><![CDATA[<h1 id="寻找家的旅程"><a href="#寻找家的旅程" class="headerlink" title="寻找家的旅程"></a>寻找家的旅程</h1><p>小黑一开始的家是森林，在人类的开发推进下，它流浪到了城市，在风吹雨打、饮食不定中，一个安定的家是它最大的渴望；</p>
<p>风息离开居住几百年的故乡，在人类的推进中，不断妥协和退让，夺回家园赶走人类是他的渴望；</p>
<p>无限，作为修行多年的人类，无与伦比的强大同时带来深邃的孤独，人与妖都无法接受他，他人是他冷漠背后的渴望；</p>
<p>渴望落地种子，无法确定能不能再次落地生根，只能随风飘浮，祈祷有那么一天；</p>
<a id="more"></a>]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>网络重定向</title>
    <url>/p/a956e2e3.html</url>
    <content><![CDATA[<h2 id="1-什么是网络重定向-what"><a href="#1-什么是网络重定向-what" class="headerlink" title="1. 什么是网络重定向 what"></a>1. 什么是网络重定向 what</h2><p>HTTP重定向(HTTP redirect)就是将各个网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向），也称为URL 重定向、 URL 转发；</p>
<p>常见的HTTP重定向状态码是301（Moved Permanently/永久移动）、302（Found/已定位），差别在于301表示已为目标资源分配了新的永久URI，以后对该资源的任何引用都应使用新的URI，302表示目标资源临时位于其他URI下。由于重定向有时可能会更改，因此客户端应继续将有效请求URI用于将来的请求。</p>
<a id="more"></a>

<p>还有其他的重定向相关状态码，如下：</p>
<ul>
<li>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</li>
<li>305 Use Proxy（使用代理）必须通过代理访问资源， 代理的地址在Response 的Location中</li>
<li>306 unuse(未使用)  这个状态码当前没使用</li>
<li>307 Temporary Redirect（临时重定向）状态代码指示目标资源临时位于其他URI下，并且如果用户代理执行到该URI的自动重定向，则它不得更改请求方法。由于重定向会随时间变化，因此客户端应继续将原始的有效请求URI用于将来的请求。（不允许将请求方法从POST更改为GET）</li>
<li>308 Permanent Redirect（永久重定向）状态码表示已为目标资源分配了新的永久URI，并且对该资源的任何将来引用都应使用随附的URI中的一个。（不允许将请求方法从POST更改为GET）</li>
</ul>
<p>我们可以看到307和301，308和302的定义类似，区别在于发生 HTTP 重定向的时候，主要是 httpMethod和httpBody的请求地址发送改变，请求方式（Get、Post）和请求参数（Body）会一起转移，即：发送HTTP重定向时，请求方式和请求体会一并重定向到新地址,而301和302状态可以从Post请求更改为Get请求；</p>
<h2 id="为什么需要网络重定向-why"><a href="#为什么需要网络重定向-why" class="headerlink" title="为什么需要网络重定向 why"></a>为什么需要网络重定向 why</h2><p>有两种情况：</p>
<p>一种情况是当实际资源，如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，保持（原有）链接可用的技术。HTTP 协议提供了一种特殊形式的响应—— HTTP 重定向（HTTP redirects）来执行此类操作，该操作可以应用于多种多样的目标：网站维护期间的临时跳转，网站架构改变后为了保持外部链接继续可用的永久重定向，上传文件时的表示进度的页面，等等。</p>
<p>避免搜索引擎的信息失效，重新抓取；</p>
<p>另一种情况是给同一个资源多个地址；</p>
<h2 id="网络重定向的实现原理"><a href="#网络重定向的实现原理" class="headerlink" title="网络重定向的实现原理"></a>网络重定向的实现原理</h2><p><img src="/images/it_HTTPRedirect.png" alt=""></p>
<p>meta javaScript 的重定向</p>
<h2 id="iOS如何实现网络重定向"><a href="#iOS如何实现网络重定向" class="headerlink" title="iOS如何实现网络重定向"></a>iOS如何实现网络重定向</h2><h3 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h3><p>待续。。。</p>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>待续。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/613ea8f758a8" target="_blank" rel="noopener">iOS中实现url重定向</a></p>
<p><a href="http://yuqiangcoder.com/2018/09/07/Alamofire-%E9%87%8D%E5%AE%9A%E5%90%91-HTTPS.html" target="_blank" rel="noopener">Alamofire 重定向</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/60669395" target="_blank" rel="noopener">状态码 301.302.303.307.308</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/" target="_blank" rel="noopener">Redirections</a></p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>美丽新世界:群体的天堂，个人的地狱</title>
    <url>/p/78abc40c.html</url>
    <content><![CDATA[<p>前往美好的天堂需要付出什么代价？</p>
<p>阅读难度：★★★★☆，话题深度：★★★★★</p>
<p>key: 乌托邦、美丽新世界、和谐、娱乐、集体</p>
<p>看完美丽新世界真是感觉背后一凉，作者在这个技术引导的时代，在众人享受技术的带来的美好时，对技术的另一面进行警告。</p>
<p>人种定制技术的高效和冷酷，家庭关系的毁灭换取社会更强大的融合，心理暗示来塑造人格行为让每个人都认同某个规则，精神药品即是麻醉也是安慰，隔离文化让快乐来得更简单些，不稳定的异端分子也享受人道的流放策略，一切都是如此美好。没有苦难、没有病痛、没有情伤，各守本份，社会和谐。</p>
<h2 id="但没有痛苦的世界是一个美好的世界吗？"><a href="#但没有痛苦的世界是一个美好的世界吗？" class="headerlink" title="但没有痛苦的世界是一个美好的世界吗？"></a>但没有痛苦的世界是一个美好的世界吗？</h2><p>人类的历史更多是苦难的历史，生活中的喜悦更多是克服磨难带来的奖励。</p>
<p>我们从来没有摆脱过痛苦，婴儿无法自理的不安，幼童能力不足的软弱，少年无尽学业的烦恼，青年在社会和自我中的矛盾，中年发展和培养下一代的压力，老年衰老的无奈，这些都是痛苦。如果这一切都可以克服，那剩下的日子就享受无尽的快乐吗？</p>
<h2 id="大家都属于彼此。"><a href="#大家都属于彼此。" class="headerlink" title="大家都属于彼此。"></a>大家都属于彼此。</h2><p>但是跟受苦受难的太高代价比起来，现实的幸福看起来往往相当廉价。而且，稳定当然远远不如动乱那么热闹；心满意足也不如跟不幸做殊死斗争那么动人；也不如抗拒引诱，或是抗拒为激情和怀疑所颠倒那么引人入胜。幸福从来就不伟大。</p>
<p>跟幸福格格不入的不光是艺术，而且有科学。科学是危险的，我们得给它小心翼翼地套上笼头，拴上链子。</p>
<p>文明绝对不需要什么高贵和英雄主义。这类东西都是没有政治效率的病症。在我们这样的有合理组织的社会里，没有人有机会表现高贵或英勇。这种机会只能够在环境完全混乱时出现：在战争的时候，在派别分化的时候，在需要抵制诱惑的时候，在争夺或保卫爱的对象的时候――显然，在那种时候高贵和英雄主义才会有点意义。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>来自新世界:消灭异端</p>
<p>1844:痛苦的平静</p>
<p>动物农场:平等</p>
<p>和谐:机械化情感</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>[翻译][SwiftGG]每一点进步都是快乐：无处不在的扩展</title>
    <url>/p/bd1af678.html</url>
    <content><![CDATA[<p><a href="http://www.russbishop.net/take-delight-in-small-joys" target="_blank" rel="noopener">原文链接/作者：Russ Bishop</a></p>
<p><a href="https://swift.gg/2019/10/29/extensions-everywhere/" target="_blank" rel="noopener">SwiftGG链接</a></p>
<p>这是关于一点小工作的分享。关于我在 Swift 中那种自然扩展中的体会。</p>
<a id="more"></a>
<p>我认为 <code>UnsafeMutableRawBufferPointer.baseAddress</code> 是可选项这回事非常不合理。它使得这种类型在实践中使用起来非常困难。我也不喜欢在分配时指定对齐方式;在大多数平台上，合理的默认值都是 <code>Int.bitWidth / 8</code>。</p>
<p> 通过扩展，我们可以很容易地解决这些问题。这样的解决方案能像标准库一样自然地使用。<br> <!--more--></p>
<p> 首先，我们需要在调试版本中进行简单的健全性检查，以确保我们不会产生无意义的对齐计算。这里提一个有关正整数的小技巧：一个 2 的 n 次幂数只有一个比特位是有值的。减去 1 时就是把后面的所有比特位设置为 1，如 8（<code>0b1000</code>）- 1 得到 7（<code>0b0111</code>）。这两个数字没有共同的位，因此按位取与应该产生零。由于这规律在零上无效，所以我们分别检查。</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinaryInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isPositivePowerOf2: <span class="type">Bool</span> &#123;</span><br><span class="line">        @inline(__always)</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">self</span> &amp; (<span class="keyword">self</span> - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; <span class="keyword">self</span> != <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 现在让我们默认使用自然整数宽度对齐。这种对齐能做的事情比我们需要的更多，但我们只需要关心存储在缓冲区中的内容就足够的。虽然断言仅在调试环境中有效。但这已经够应付我们的使用;我们知道 Swift 目前支持的每个平台都是如此。</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafeMutableRawBufferPointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(byteCount: Int)</span></span> -&gt; <span class="type">UnsafeMutableRawBufferPointer</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> alignment = <span class="type">Int</span>.bitWidth / <span class="number">8</span></span><br><span class="line">        <span class="built_in">assert</span>(alignment.isPositivePowerOf2, <span class="string">"expected power of two"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allocate(byteCount: byteCount, alignment: alignment)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后再提一个点，我们可以添加一个隐式强制解包的 <code>base</code> 属性。</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafeMutableRawBufferPointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">UnsafeMutableRawPointer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseAddress!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UnsafeRawBufferPointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">UnsafeRawPointer</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseAddress!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 一切是如此简单。</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>SwiftGG</tag>
      </tags>
  </entry>
  <entry>
    <title>胜负：棋魂</title>
    <url>/p/a8cd6280.html</url>
    <content><![CDATA[<p>16年3月，阿尔法围棋与围棋世界冠军、职业九段棋手李世石进行围棋人机大战，以4比1的总比分获胜；2016年末2017年初，该程序在中国棋类网站上以“大师”（Master）为注册账号与中日韩数十位围棋高手进行快棋对决，连续60局无一败绩；2017年5月，在中国乌镇围棋峰会上，它与当时排名世界第一的世界围棋冠军柯洁对战，以3比0的总比分获胜。</p>
<p>当一个竞技行业出现“神之一手”的时候，大概就是这个行业最大的不幸和幸运吧。</p>
<a id="more"></a>

<p>今年抽空重温了《棋魂》，看着千年幽灵和懵懂小儿的相遇，在围棋道路上的进步，遇到竞争对手的恐惧和兴奋，争取棋士资格的不屈不挠，在职业围棋中的激烈拼杀，现在看来也很有趣味，同时对职业、竞技感慨很多，这又是过去没有的一种新体验。</p>
<h2 id="藤原佐为"><a href="#藤原佐为" class="headerlink" title="藤原佐为"></a>藤原佐为</h2><p>藤原佐为是全剧艺术色彩的眼，从这个无法考证的天才棋士展开后面剧情，也许有人认为这是浮夸，但人类社会发展数千年，不断提升自我、挑战自我，从社会结构到科学技术不断地提高生产力，永不满足，永远在追求更强大，各个行业都有人在追求“神之一手”，这个“幽灵”在人类社会飘荡何止千年。</p>
<h2 id="棋士"><a href="#棋士" class="headerlink" title="棋士"></a>棋士</h2><p>围棋开始不过是一种游戏方式，作为爱好能带来享受,但兴趣爱好变成职业呢？在成为职业之后，胜负输赢成为多少棋士挥不去的念想，与很多职业不同，棋士的胜负就摆在那里，无论之前多少合作交流，在棋盘上必然产生一个胜者、一个败将，成王败寇，毫不留情！</p>
<p>棋坛的金字塔，有多少杰出的天才人物后面就有更多默默无名的棋士，再后面还有茫茫多的放弃者。</p>
<p>在本剧中的棋院剧情中，多少天才少年在里面奋斗不休，在赢棋时暗自激动，在输棋时关在厕所哭着复盘，发誓下次绝对不会输。</p>
<p>恐惧、迷茫、低谷、压力都压在每个人的身上，在棋士考试时出现的业余棋手也让主题更深一层，在社会中多少热爱围棋的人在工作和围棋间两难，辞职参加棋士考试的不在少数，但成王败寇，达者为师，棋盘上的胜负就是这样。</p>
<h2 id="连接过去与未来"><a href="#连接过去与未来" class="headerlink" title="连接过去与未来"></a>连接过去与未来</h2><p>最后一章，当藤原佐为离开世界，进藤光走上属于自己的棋士道路，过去和未来就这么连接着，我们汲取着过去的智慧成长，但最后会用自己的眼睛去看世界，用自己的手去改造世界，人类社会的延续也是如此。</p>
]]></content>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>[翻译][SwiftGG]宏定义与可选括号</title>
    <url>/p/e8bb7171.html</url>
    <content><![CDATA[<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-03-20-preprocessor-abuse-and-optional-parentheses.html" target="_blank" rel="noopener">原文地址/作者：Mike Ash</a></p>
<p><a href="https://swift.gg/2019/09/27/preprocessor-abuse-and-optional-parentheses/" target="_blank" rel="noopener">SwiftGG</a></p>
<p>前几天我遇到了一个有趣的问题：如何编写一个 C 语言预处理器的宏，删除围绕在参数上的括号？</p>
<p>今天的文章，将为大家分享我的解决方案。</p>
<a id="more"></a>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>C 语言预处理器是一个相当盲目的文本替换引擎，它并不理解 C 代码，更不用说 Objective-C 了。它的工作原理还算不错，可以应付大部分情况，但偶尔也会出现判断失误。</p>
<p>这里举个典型的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">XCTAssertEqualObjects</span>(someArray, @[ <span class="string">@"one"</span>, <span class="string">@"two"</span> ], <span class="string">@"Array is not as expected"</span>);</span><br></pre></td></tr></table></figure>

<p>这会无法编译，并且会出现非常古怪的错误提示。预处理器查找分隔宏参数的逗号时，没能将数组结构 <code>@ [...]</code> 中的东西应该理解为一个单一的元素。结果代码尝试比较 <code>someArray</code> 和 <code>@[@&quot;one&quot;</code>。断言失败消息 <code>@&quot;two&quot;]</code> 和 <code>@&quot;Array is not as expected&quot;</code> 也提供了更详细的说明。这些不完整的代码组合到了 <code>XCTAssertEqualObjects</code> 的宏扩展中，生成的代码当然错的离谱。</p>
<p>要解决这个问题也很容易：添加一个括号就行。预编译器不能识别 <code>[]</code>，但它<em>确实</em>知道 <code>()</code> 并且能够理解需要忽略里面的括号。下面的代码就能正常运行：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">XCTAssertEqualObjects</span>(someArray, (@[ <span class="string">@"one"</span>, <span class="string">@"two"</span> ]), <span class="string">@"Array is not as expected"</span>);</span><br></pre></td></tr></table></figure>

<p>在 C 语言的许多场景下，你添加多余的括号也不会有任何区别。就像宏扩展之后，生成的代码虽然在数组文字周围有括号，但没有异常。你可以编写充满多余括号的表达式，而编译器会愉快地为你挖掘到最底部：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,((((((((((<span class="number">42</span>)))))))))));</span><br></pre></td></tr></table></figure>

<p>甚至将 <code>NSLog</code> 这样处理也行：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">((((((((((<span class="built_in">NSLog</span>))))))))))(<span class="string">@"%d"</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>在 C 中有一个地方你不能只添加随机括号：类型（types）。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f(<span class="keyword">void</span>); <span class="comment">// 合法</span></span><br><span class="line">(<span class="keyword">int</span>) f(<span class="keyword">void</span>); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<p>所以怎么区分这种情况呢？这种情况并不常见，但如果你有一个使用类型的宏，并且您的类型包含不在括号内的逗号，则会出现这种情况。宏可以做很多事情，当一个类型遵循多个协议时，在 Objective-C 中可能出现一些类型带有未加括号的逗号;当使用带有多个模板参数的模板化类型时，在 C++ 中就可能出现。举个例子，这有一个简单的宏，创建从字典中提供静态类型值的 <code>getter</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETTER(type,name) \</span></span><br><span class="line">	- (type)name &#123; \</span><br><span class="line">		<span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>你能这样使用它：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">	<span class="built_in">NSDictionary</span> *_dictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GETTER(<span class="built_in">NSView</span> *,view)</span><br><span class="line">GETTER(<span class="built_in">NSString</span> *,name)</span><br><span class="line">GETTER(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;,someCopyableThing)</span><br></pre></td></tr></table></figure>

<p>到目前为止没问题。现在假设我们想要制作一个遵循<em>两个</em>协议的类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GETTER(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>,<span class="built_in">NSCoding</span>&gt;,someCopyableAndCodeableThing)</span><br></pre></td></tr></table></figure>

<p>哎呀！宏不起作用了。而且添加括号也无济于事：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GETTER((<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>,<span class="built_in">NSCoding</span>&gt;),someCopyableAndCodeableThing)</span><br></pre></td></tr></table></figure>

<p>这会产生无效代码。这时我们需要一个删除可选括号的 UNPAREN 宏。将 <code>GETTER</code> 宏重写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define GETTER(type,name) \</span><br><span class="line">	- (UNPAREN(type))name &#123; \</span><br><span class="line">		return [_dictionary objectForKey: @#name]; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们该怎么做呢？</p>
<h2 id="必须的括号"><a href="#必须的括号" class="headerlink" title="必须的括号"></a>必须的括号</h2><p>删除括号很容易：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN(...) __VA_ARGS__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETTER(type,name) \</span></span><br><span class="line">	- (UNPAREN type)name &#123; \</span><br><span class="line">		<span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看上去很扯，但这的确能运行。预编译器将 <code>type</code> 扩展为 <code>(id &lt;NSCopying，NSCoding&gt;)</code>，生成 <code>UNPAREN (id&lt;NSCopying, NSCoding&gt;)</code>。然后它会将 <code>UNPAREN</code> 宏扩展为 <code>id &lt;NSCopying，NSCoding&gt;</code>。</p>
<p>但是，之前使用的 <code>GETTER</code> 失败了。例如，<code>GETTER(NSView *，view)</code> 在宏扩展中生成 <code>UNPAREN NSView *</code>。不会进一步扩展就直接提供给编译器。结果自然会报编译器错误，因为 <code>UNPAREN NSView *</code> 是无法编译的。这虽然可以通过编写 <code>GETTER((NSView *)，view)</code> 来解决，但是被迫添加这些括号很烦人。这样的结果可不是我们想要的。</p>
<h2 id="宏不能被重载"><a href="#宏不能被重载" class="headerlink" title="宏不能被重载"></a>宏不能被重载</h2><p>我立刻想到了如何摆脱剩余的 <code>UNPAREN</code>。当你想要一个标识符消失时，你可以使用一个空的 <code>#define</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN</span></span><br></pre></td></tr></table></figure>

<p>有了这个，<code>a UNPAREN b</code> 的序列变为 <code>a b</code>。完美解决问题！但是，如果已经存在带参数的另一个定义，则预处理器会拒绝此操作。即使预处理器可能选择其中一个，它也不会同时存在两种形式。可行的话，这能有效解决我们的问题，但可惜的是并不允许：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN(...) __VA_ARGS__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETTER(type,name) \</span></span><br><span class="line">	- (UNPAREN type)name &#123; \</span><br><span class="line">		<span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这无法通过预处理器，因为它会由于 <code>UNPAREN</code> 的重复 <code>#define</code> 而报错。不过，它引导我们走上了胜利的道路。现在的问题是怎么找出一种方法来实现相同的效果，而不会使两个宏具有相同的名称。</p>
<h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>最终目标是让 <code>UNPAREN(x)</code> 和 <code>UNPAREN((x))</code> 结果都是 <code>x</code>。朝着这个目标迈出的第一步是制作一些宏，其中传递 <code>x</code> 和 <code>(x)</code> 产生相同的输出，即使它并不确定 <code>x</code> 是什么。这可以通过将宏名称放在宏扩展中来实现，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTRACT(...) EXTRACT __VA_ARGS__</span></span><br></pre></td></tr></table></figure>

<p>现在如果你写 <code>EXTRACT(x)</code>，结果是 <code>EXTRACT x</code>。当然，如果你写 <code>EXTRACT x</code>，结果也是 <code>EXTRACT x</code>，毕竟没有宏扩展的情况。这仍然给我们留下一个 <code>EXTRACT</code>。虽然不能用 <code>#define</code> 直接解决，但这种做法也算是一种进步。</p>
<h2 id="标识符粘贴"><a href="#标识符粘贴" class="headerlink" title="标识符粘贴"></a>标识符粘贴</h2><p>预处理器有一个操作符 <code>##</code>，它将两个标识符粘贴在一起。例如，<code>a ## b</code> 变为 <code>ab</code>。这可以用于从片段构造标识符，但也可以用于调用宏。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AB 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A(x) A ## x</span></span><br></pre></td></tr></table></figure>

<p>从这里可以看到，<code>A(A)</code> 产生 <code>1</code>，<code>A(B)</code> 产生 <code>2</code>。</p>
<p>让我们将这个运算符与上面的 <code>EXTRACT</code> 宏结合起来，尝试生成一个 <code>UNPAREN</code> 宏。由于 <code>EXTRACT(...)</code> 使用前缀 <code>EXTRACT</code> 生成参数，因此我们可以使用标识符粘贴来生成以 <code>EXTRACT</code> 结尾的其他标记。如果我们 <code>#define</code> 那个新标记为空，那就搞定了。</p>
<p>这是一个以 <code>EXTRACT</code> 结尾的宏，它不会产生任何结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTHING_EXTRACT</span></span><br></pre></td></tr></table></figure>

<p>这是对 <code>UNPAREN</code> 宏的尝试，它将所有内容放在一起：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN(x) NOTHING_ ## EXTRACT x</span></span><br></pre></td></tr></table></figure>

<p>不幸的是，这并不能实现我们的目标。操作顺序是问题所在。如果我们写 <code>UNPAREN((int))</code>，我们将会得到：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">NOTHING_ ## EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">NOTHING_EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>标示符粘贴发生的顺序太前，<code>EXTRACT</code> 宏永远不会有机会扩展开。</p>
<p>你可以通过使用间接强制预处理器以不同的顺序判断事件。我们不是直接使用 <code>##</code>，而是制作一个 <code>PASTE</code> 宏：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASTE(x,...) x ## __VA_ARGS__</span></span><br></pre></td></tr></table></figure>

<p>然后我们将根据它写下 <code>UNPAREN</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN(x)  PASTE(NOTHING_,EXTRACT x)</span></span><br></pre></td></tr></table></figure>

<p>这<em>又</em>不起作用。情况如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">PASTE(NOTHING_,EXTRACT (<span class="keyword">int</span>))</span><br><span class="line">NOTHING_ ## EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">NOTHING_EXTRACT (<span class="keyword">int</span>)</span><br><span class="line">(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>但更接近我们的目标了。序列 <code>EXTRACT(int)</code> 显然没有触发标示符粘贴操作符。我们必须让预处理器在它看到 <code>##</code> 之前解析它。可以通过另一种方式间接强制解析它。让我们定义一个只包装 <code>PASTE</code> 的 <code>EVALUATING_PASTE</code> 宏：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVALUATING_PASTE(x,...) PASTE(x,__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>现在让我们用<em>这个</em>写 <code>UNPAREN</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNPAREN(x) EVALUATING_PASTE(NOTHING_,EXTRACT x)</span></span><br></pre></td></tr></table></figure>

<p>这是扩展：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN((<span class="keyword">int</span>))</span><br><span class="line">EVALUATING_PASTE(NOTHING_,EXTRACT (<span class="keyword">int</span>))</span><br><span class="line">PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">NOTHING_ ## EXTRACT <span class="keyword">int</span></span><br><span class="line">NOTHING_EXTRACT <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>即使没有额外加括号也能正常运行，因为额外的赋值并没有影响：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">UNPAREN(<span class="keyword">int</span>)</span><br><span class="line">EVALUATING_PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">PASTE(NOTHING_,EXTRACT <span class="keyword">int</span>)</span><br><span class="line">NOTHING_ ## EXTRACT <span class="keyword">int</span></span><br><span class="line">NOTHING_EXTRACT <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>成功了！我们现在可以不需要用括号围绕着类型来编写 <code>GETTER</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETTER(type,name) \</span></span><br><span class="line">	- (UNPAREN(type))name &#123; \</span><br><span class="line">		<span class="keyword">return</span> [_dictionary objectForKey: @<span class="meta">#name]; \</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="宏的奖励"><a href="#宏的奖励" class="headerlink" title="宏的奖励"></a>宏的奖励</h2><p>在提出可以证明这个结构的宏的同时，我构建了一个很好的 <code>dispatch_once</code> 宏来制作延迟初始化的常量。实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONCE(type,name,...) \</span></span><br><span class="line">	UNPAREN(type) name() &#123; \</span><br><span class="line">		<span class="keyword">static</span> UNPAREN(type) static_ #<span class="meta"># name; \</span></span><br><span class="line">		<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate; \</span><br><span class="line">		<span class="built_in">dispatch_once</span>(&amp;predicate,^&#123; \</span><br><span class="line">			static_ #<span class="meta"># name = (&#123; __VA_ARGS__; &#125;); \</span></span><br><span class="line">		&#125;); \</span><br><span class="line">		<span class="keyword">return</span> static_ #<span class="meta"># name; \</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ONCE(<span class="built_in">NSSet</span> *,AllowedFileTypes,[<span class="built_in">NSSet</span> setWithArray:@[ <span class="string">@"mp3"</span>,<span class="string">@"m4a"</span>,<span class="string">@"aiff"</span> ]])</span><br></pre></td></tr></table></figure>

<p>然后，你可以调用 <code>AllowedFileTypes()</code> 来获取集合，并根据需要高效创建集合。如果类型包含逗号，添加括号就能运行。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>仅仅写这个宏，我就发现了很多艰涩的知识。我希望接触这些知识也不会影响你的思维。请谨慎使用这些知识。</p>
<p>今天就是这样。更多令人兴奋的冒险以后也会有，可能是比这更不可思议的事情。在此之前，如果你对此处的主题有任何建议，请发送给 <a href="mike@mikeash.com">我们</a>！</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>SwiftGG</tag>
      </tags>
  </entry>
  <entry>
    <title>自卑和超越：自我认知与社会认同</title>
    <url>/p/2e79d4e7.html</url>
    <content><![CDATA[<p>作者尔弗雷德·阿德勒，是个体心理学创始人，与弗洛伊德、荣格齐名的心理学三巨头之一。虽然他是弗洛伊德的学生，但也是弗洛伊德的反对者。</p>
<p>阿德勒强调社会和自我奋斗对个人的影响，是现代自我心理学之父，对西方心理学的发展有极大影响。</p>
<p>他认为，自卑感是人类进步的底层动力；遗传等先天因素并不能决定人的命运，每个人都可以通过自己的努力来实现目标，也可以通过与他人建立合作，来实现自己的人生意义和个人价值。</p>
<h2 id="意识与行动"><a href="#意识与行动" class="headerlink" title="意识与行动"></a>意识与行动</h2><p>人的行动是由意识决定的，心理学可以利用人们对于意义本身的理解，来影响自身的行为和发展方向，进而为人类谋取更大的福祉。</p>
<blockquote>
<p>经验并非成功或失败之母。我们的生活经验对我们没有太大用处，起决定作用的是我们赋予经验的认知和意义。</p>
</blockquote>
<h2 id="自卑与自信"><a href="#自卑与自信" class="headerlink" title="自卑与自信"></a>自卑与自信</h2><p>每个人都有自卑，每个人都可以培养起自己的自信；对待自卑不需要太过沉迷痛苦，而应该面对自卑的起源，去追求改变、克服弱点、实现卓越，将过去的自卑化作未来的自信，化作自我提升的动力。</p>
<blockquote>
</blockquote>
<p>阿德勒认为，每个人都有不同程度的自卑感，而优越感则是自卑感的补偿。但自卑感的存在并不是一件坏事，因为它激励了人不断追求卓越，克服自身的障碍，在有限的生命空间内发挥出最大的价值。可以说，正是由于人类会有自卑感，才会有不断取得发展和进步的不竭动力。</p>
<p>人的潜力是没有局限的，更不是天生注定的，只要肯去挖掘，每个人都有成功和飞跃的机会。这也是阿德勒个体心理学的一个重要原则。</p>
<p>我们每个人都有不同程度的自卑感，因为我们都想让自己更优秀，让自己过更好的生活。</p>
<p>当一个人失去自信，不再认为通过自己脚踏实地的努力可以摆脱自卑感，但他依旧不能忍受自卑感的折磨时，他会继续设法摆脱它们，只是他所运用的方法是不切实际的。他不再设法克服困难，反而沉醉于一种优越感中，强迫自己认为自己有优越感。这样不但不利于消除自卑感，反而使自卑感不断累积。产生自卑的真正原因没有克服，问题就会一直存在，所采取的每一个自欺欺人的行动都会让他的自卑感更加强烈。</p>
<p>自卑情结是指一个人在意识到他要面对一个他无法解决的问题时，表现出的无所适从。</p>
<p>自卑感本身无可厚非，它是推动人类进步的动力。比如，只有人类认识到自己的无知，才会进一步学习，以便更好地在世界上生存。</p>
<p>我们知道人类永远无法达到生命的终极目标。如果一个人已经没有任何做不到的事情，那么他的生活一定是索然无味的。当一个人生命中所有的事情都已预知，那么我们的生活还有什么意义呢？生活的不确定性正是我们希望的来源。当我们能知晓任何事物，探索和讨论也就没有存在的必要了，科学也不需要发展了。当我们的一切都是一个设定好的故事，曾经让我们追求的宗教和艺术也都失去了意义。幸好，生活并不是如此，有许多新的问题等着我们去解决，我们需要在社会中不断奋斗，勇往直前。</p>
<p>人人都在追求属于自己独有的一种优越感。它取决于人们赋予生命的意义。</p>
<p>在努力追求优越感的过程中，只有为了他人的利益而前进的人和那些为了社会的发展而奋斗的人，才是能够超越生活，从而顺利获得优越感的人。</p>
<h2 id="童年的影响"><a href="#童年的影响" class="headerlink" title="童年的影响"></a>童年的影响</h2><p>童年的经历对自我的影响是极大的，它影响了个人对自我和环境的初始定位，同时也是个体主观意识的起点，也是人生的起点。</p>
<p>记忆不是偶然存在的，只要存在，就有意义。</p>
<p>记忆是不会说谎的，记忆也是人的所有心理现象中最能反映真实自我的一个。</p>
<p>首先，童年记忆涵盖了一个人对于自己和环境的初始印象，个体第一次将自己的外貌、自我评价、他人评价综合起来考虑；</p>
<p>如果找到了人性曲解的初始端，并配以有效的治疗方法，那人性是可以改变的。这里所谓的有效方法即培养个体与人合作的勇气和精神。</p>
<h2 id="精神决定行动"><a href="#精神决定行动" class="headerlink" title="精神决定行动"></a>精神决定行动</h2><p>阿德勒主张人的行动受精神影响，精神决定了不同的人在困难、悠闲、孤独、烦恼时的不同行动。而如果想改变自己的行为，需要先认识到自己的驱动精神，先改变认知再改变行为。</p>
<p>精神犹如发动机，将人体的潜能全部激发出来，带领身体进入安全舒适的地位。在身体的每项活动中，我们都能看到精神的意义。</p>
<p>我们只要留心观察个人的行为举止就能了解这个人。行为举止是永远受到人生意义的制约的。</p>
<p>只有渴望将自己融入社会整体而不是只关注自己的人，才能成功学会如何补偿自己的缺憾。只是想逃避困难的人，必然会落后于他人。如果他们努力地争取克服困难，他们自然会训练提升自己，使自己获得克服缺陷的能力。</p>
<p>一个人的心智模式、生活态度会对其身体产生持续的影响。一个人的性格和人生态度在儿时就已经形成了，如果你有足够的人生经验，你就可以从一个人的童年预见他以后的发展趋势。</p>
<p>我们必须对一个人的整个生命态度进行解读，了解他的生活方式、行为模式、对生活的态度、对他人的看法等，从中找出他的错误看法。这才是心理学真正该做的事情。</p>
<p>一个人的生活模式是在小时候就形成了的。因此，这并不是能轻易改变的。只有自己了解到形成时所犯的错误，才有可能改变过来。</p>
<h2 id="社会合作"><a href="#社会合作" class="headerlink" title="社会合作"></a>社会合作</h2><h3 id="犯罪与社会"><a href="#犯罪与社会" class="headerlink" title="犯罪与社会"></a>犯罪与社会</h3><p>犯罪行为本质是行使了有违人类社会公认道德规范的行为，让一个人足够认可社会并且与社会的联系密切是遏制犯罪行为的好方法。</p>
<p>罪犯的做事方式及态度都表现出他在努力解决问题，他在追求成功和优越感。虽然他们很努力，但是他们所追求的方向是错误的，这就导致了他的行为不符合社会的要求。</p>
<p>防止走上犯罪道路的最佳方法就是与他人合作。</p>
<p>如果我们了解犯罪并不是一个孤立事件，而是生活模式的反应，而且能找出形成的原因，并把它当成是可以解决的，那么我们就有信心能改变犯罪的问题。</p>
<h3 id="婚姻"><a href="#婚姻" class="headerlink" title="婚姻"></a>婚姻</h3><p>婚姻是建立在平等、尊重和关爱上，自私是无法建立稳定的婚姻关系。</p>
<p>婚姻实质上是两个平等的人在人生路上的陪伴和结合，在家庭地位上没有高低之分。家庭中所有的事情没有控制或权威可言。</p>
<p>只有夫妻二人都将对方的幸福看得比自己的幸福更重要时，双方才有可能产生真正的合作，才会给予对方真正的爱。</p>
<p>为了保证有和谐的夫妻关系，我们需要给对方而不是自己更多的关心，也就是说，给对方的关心要胜过给自己的关心。</p>
<h3 id="社会合作与价值"><a href="#社会合作与价值" class="headerlink" title="社会合作与价值"></a>社会合作与价值</h3><p>在工作中实现价值的人，这份价值如果是他自己认同的，那么认同感就会反馈出优越。</p>
<p>在社会中，善于合作的人能创造的价值也更大，</p>
<p>让他们有动力朝着自己所选择的方向努力。通过完成目标来获得优越感。</p>
<p>他们的职业选择中，我们能看出他们全部的生活模式，他们为什么而努力以及他们认为生活中最有价值的东西是什么。</p>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>作为 20 世纪的作品，有一定的局限性，忽略了社會文化的影響，对于自我意义的定位没有更清晰准确的讨论，不过 20 世纪很多科学作品对讨论的假设的科学程度要求不高，像《裸猿》《人类动物园》等作品，有的观点科学，有些只是假说。</p>
<p>但《自卑和超越》对个人心理的分析还是很有价值的，尤其是对心理上的自卑的分析，从起源到行为，深刻分析了记忆、认知和行为的关系，并对改变自卑做出了指导，同时推广到社会合作中，对婚姻关系的分析在当时可说非常先进；</p>
]]></content>
      <tags>
        <tag>book</tag>
        <tag>mind</tag>
      </tags>
  </entry>
  <entry>
    <title>虐杀器官--语言映射认知</title>
    <url>/p/41b771d3.html</url>
    <content><![CDATA[<p>tag:战争、高科技、近未来、杀戮、语言、价值观、生命意义</p>
<p>《虐杀器官》，动漫改编于同名小说，是伊藤计划三部曲之一，另外两部是《和谐》《尸者的帝国》，一部探讨战争和人性的作品。</p>
<p>作品定位在科技高度发达的近未来，此时部分落后国家爆发了一连串内战及民族冲突，在这血腥风暴之中，美国特殊情报部队「克拉维斯（クラヴィス）」发现了在阴影之下有一名叫「约翰·保罗（ジョン・ポール）」的美国人参与其中，约翰路过之处必定掀起腥风血雨，而主角追捕约翰的过程的过程。</p>
<h2 id="科技生活"><a href="#科技生活" class="headerlink" title="科技生活"></a>科技生活</h2><p>在电影中，有很多高科技设想，如AR无缝结合现实，视频或交互界面不在局限于固定界面上；纳米机械推广，在眼药水中集成军方摄像和展示窗口；人工肌肉让机器能够做出更多工作，替代了重复劳动力；个人信息全面联网支付、出行都与网络联通等。</p>
<h2 id="杀戮文法"><a href="#杀戮文法" class="headerlink" title="杀戮文法"></a>杀戮文法</h2><p>在电影中，保罗通过研究二战纳粹屠杀时的宣传资料，提炼出杀戮文法，能够针对某中语言进行调整，宣传扩散后该语种的人群会被抑制同情心，剥夺同理心、降低逻辑判断等里，激化社会矛盾，引诱杀戮行为。</p>
<p>后半部分扩展讨论了人是否能够拥有自由的意识，人性价值何在，通过纳米机器、心理调节或语言，能够调整个人情感、价值观、五感，生产出绝对冷静、隔绝痛感、没有怜悯、没有恐惧、没有快感的战士；社会层次上，用语言宣传引导群体意识，让一个个和平的国度产生一次次的暴乱、战争。</p>
<h2 id="语言和意志"><a href="#语言和意志" class="headerlink" title="语言和意志"></a>语言和意志</h2><p>极具想象力的作品，对于语言对意志自由探讨很多，我们通过感官了解世界，当我们以为把握自我的时候，外界的信息能够对自己产生多大的影响呢？一个人的本质是存在并且能够一直保持？如果被外界改变“我”是否还是“我”？</p>
]]></content>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>读《当呼吸化作空气》：向死而生</title>
    <url>/p/a8f1b26e.html</url>
    <content><![CDATA[<p>保罗在事业即将飞腾的35岁检查出了肺癌，在接下来的两年里，他重新回到自己忙碌的工作岗位上，完成住院医师的工作、得到教授资格，迎接女儿卡迪的出生，在病痛和关爱中思索死亡的意义，写下《当呼吸化为空气》……到了那天，他躺在曾经工作过的医院里，弥留之际，他说“准备好了”。</p>
<a id="more"></a>

<h2 id="死神的来访从不敲门"><a href="#死神的来访从不敲门" class="headerlink" title="死神的来访从不敲门"></a>死神的来访从不敲门</h2><p>1977年出生的保罗·卡拉尼什，在斯坦福大学获得了英语文学和人体生物学双料学位，还在剑桥大学获得了医药哲学硕士学位，然后在耶鲁大学医学院继续深造，行医时还获得过美国神经外科医生协会最高奖。</p>
<p>斯坦福医学院准备授予他外科教授职位，并让他主持自己的研究室，通过漫长的医学训练和忙碌的医师工作，一切开始走上美好，似乎即将走上人生的巅峰。</p>
<p>然而，肺癌像石头砸在镜子上把一切打成粉碎。</p>
<p>在人生的道路上，谁会预想到那天会和死神碰面呢？可面临死亡从来都是一个选择，这是既定的命运。</p>
<p>在命运面前，有人以信念安抚自己、有人以乐观笑看生活、有人选择绝望和放弃，而《当呼吸化为空气》，是一本与死神同行的书，坦然真诚，又充满力量。</p>
<p>在确定绝症后，保罗选择慢下来。回望过去：十岁时居家搬迁至亚利桑那州的金曼；在母亲的影响和熏陶下读了大量文学类的图书，并对文学产生了浓厚的兴趣；在斯坦福读书时，确定人生的志向；为了成为神经外科医生，接受高强度近乎残忍的培训；与露西相爱，并进入婚姻；并在行医的过程中，目睹太多的人与死神相遇或擦肩，生死是已经是日常，多少人奋力与死亡抗争又在命运的安排中倒下。</p>
<h2 id="面对死亡"><a href="#面对死亡" class="headerlink" title="面对死亡"></a>面对死亡</h2><p>生命的基本要求是新陈代谢，而死亡，就是新陈代谢的终止。死神不会放过我们任何人。医生和病人，活着，呼吸着的生命，这都是命运的安排。</p>
<p>技术再高超的医生也不一定就得了人！有得时候，你而已能使用的治疗手段只有语言。</p>
<p>医生在为了生命不断地搏斗着，也同时直面生命意义的拷问。背负着无形的枷锁，肩负着生死攸关的责任。也许病人鲜活的生命就我在我们手中，但死神总是最后的胜者。</p>
<p>而当保罗面临这一些，在迷茫后选择向好友坦露心扉，坦陈了最深的担忧。面对深爱的妻子，他说“我需要你”；而他的妻子用行动表明了对他的所有支持，陪他一起治疗，以及与他一起延展生命，而非等死，比如，生下卡迪。</p>
<p>还有主治医生艾玛，正是她，鼓励保罗找到自己最看重的东西，并鼓励保罗重返了医生的岗位，并且顺利毕业，拿到神经外科主治医生和教授的资格。</p>
<p>以及保罗的家人，他的父母、兄弟，给了他稳定的爱和陪伴。他们一起过节，照顾卡迪，共同讨论保罗的病情。“保罗坐在轮椅上，抱着卡迪。他父亲在旁边看顾。他母亲和我坐在不远处的沙发上。保罗给卡迪唱歌，在膝头轻轻摇晃着她。她咧嘴大笑……”</p>
<p>正是在这么多人的支持下，保罗才能在病魔缠身中完成工作，写下本书，告诉大家这一路上到底会面对什么？</p>
<blockquote>
<p>你在死亡中探究生命的意义</p>
</blockquote>
<blockquote>
<p>你见证生前的呼吸化作死后的空气</p>
</blockquote>
<blockquote>
<p>新人尚不可知，故旧早已逝去</p>
</blockquote>
<blockquote>
<p>躯体有尽时，灵魂无绝期</p>
</blockquote>
<blockquote>
<p>读者啊，趁生之欢愉，快于时间同行</p>
</blockquote>
<blockquote>
<p>共赴永恒生命！</p>
</blockquote>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋卷钩生：突出的个性</title>
    <url>/p/e01b7789.html</url>
    <content><![CDATA[<p><img src="/imags/blog_lxjgs_cover.jpg" alt=""></p>
<p>我看的漫画、小说和电影都挺多的，作为故事的载体，在不提升到艺术的范畴，我不禁思考漫画相比小说、真人电影等有什么不同？</p>
<p>真人电影需要以演员演绎故事，小说用文字来描述故事，漫画以线条来演绎故事，其中电影无法脱离真人的演绎空间，真实的表现现实的局限，小说的文字可以产生无限的联想和感知，而漫画则在双方中取平衡，用现实的某部分画面来描绘故事同时又可以摆脱现实的约束，在线条和阴影间给读者创造出巨大差异、想象和冲击。</p>
<p>画面的扭曲和方法</p>
<p>绘画 照相的区别</p>
<p>想象力的空间</p>
<p>个性，不同</p>
<p>独特的画风更是放大这种特质</p>
]]></content>
      <tags>
        <tag>acg</tag>
      </tags>
  </entry>
  <entry>
    <title>跟任何人都聊得来:沟通</title>
    <url>/p/4b08e500.html</url>
    <content><![CDATA[<p>把对方看在眼里，放在心上</p>
<ul>
<li>坚持自己的个性，让自己的独特之处发挥作用。</li>
<li>准备越充分，你就越自信。</li>
<li>永远保持一颗好奇的心，千方百计让自己变得有趣。</li>
<li>学会从他人的思维角度出发，真正在意对方。</li>
</ul>
<p>对于外在世界，我们要充满期待地去探索。这里涉及两个概念：探索和充满期待。探索是本书所有讨论内容的基础——弄清楚自己手中的工具，学会如何使用这些工具，用这些工具发现和他人的共同兴趣，拓展新的交谈领域。充满期待的意思是期望这场让人兴奋的旅程。如果你是刚开始学习这些技巧，可能很难想象整个旅程有多么刺激。这就像学习一项运动，随着能力的增长，过程也会变得越来越有趣。成功不会一夜之间就实现，整套技巧需要一定的时间才能掌握，但是，只要一步步坚持下去，一切就容易了。</p>
<p>学会从他人的思维角度出发</p>
<h2 id="第1章-坚持自己的个性，交谈才会更有趣"><a href="#第1章-坚持自己的个性，交谈才会更有趣" class="headerlink" title="第1章 坚持自己的个性，交谈才会更有趣"></a>第1章 坚持自己的个性，交谈才会更有趣</h2><p>内向让交谈更有深度，外向则更具行动力</p>
<p>你的独一无二以及周围人的独一无二会打开通往沟通力的大门。“赞美自己的独一无二”是我们建立良好的人际关系以及与他人交谈的最有力工具。当我们将注意力集中在真实的自我而非模仿他人时，结果就会不可思议。</p>
<h2 id="第2章-你真的了解自己吗"><a href="#第2章-你真的了解自己吗" class="headerlink" title="第2章 你真的了解自己吗"></a>第2章 你真的了解自己吗</h2><p>草坪总是人家的好</p>
<p>要想拥有一块完美的草坪，正确的方法是测试分析土壤条件，选择适合的草种。如果直接把他人的草种种植在自己的草坪上，草坪肯定变得凹凸不平。人际沟通的技能也是如此。关键在于不要模仿他人，而是自我学习和成长。一旦我们接受了自己不同于他人的地方，我们就可以最大限度地利用这一点。我们可以选择正确的沟通技巧，选择合适自己的社交场合，和他人有效、惬意地交谈。</p>
<h2 id="第3章-为什么听不懂，为什么说不清"><a href="#第3章-为什么听不懂，为什么说不清" class="headerlink" title="第3章 为什么听不懂，为什么说不清"></a>第3章 为什么听不懂，为什么说不清</h2><p>如果之前的经历是消极的，那么在人际沟通方面只会有以下三种选择： ●不再和他人交谈； ●继续交谈，但感觉痛苦；</p>
<h2 id="第4章-挑战我们心中的假设"><a href="#第4章-挑战我们心中的假设" class="headerlink" title="第4章 挑战我们心中的假设"></a>第4章 挑战我们心中的假设</h2><p>真正的交谈在第一句话之前就已经开始了。交谈双方都会通过观察对方的肢体语言、面部表情，然后解读获取的无声信息，做出各种预判和假设。然而，通常情况下，这些判断和假设都是不正确的。</p>
<h2 id="第5章-找到共同的兴趣点"><a href="#第5章-找到共同的兴趣点" class="headerlink" title="第5章 找到共同的兴趣点"></a>第5章 找到共同的兴趣点</h2><p>交谈的三种模式</p>
<h2 id="第6章-千方百计让自己变得有趣"><a href="#第6章-千方百计让自己变得有趣" class="headerlink" title="第6章 千方百计让自己变得有趣"></a>第6章 千方百计让自己变得有趣</h2><p>对于交谈来说，“样样都通”比“一门精通”更重要。所以，平时要多留意搜集信息，千方百计让自己变得有趣，这是有效沟通的秘密之一。</p>
<p>事先做好准备</p>
<p>在健康友好的谈话氛围中，双方的信息输入应该是平衡的，注意力偏向任何一方都会失衡。因此，将注意力集中于你们所处的情景，是最为安全的做法，就是将问题和评论集中于彼此都感兴趣的大环境或外部事件。</p>
<p>如何准备开场白</p>
<p>要想加入一个交谈群体，你如何准备自己的开场白呢？首先要说什么呢？记住：你的目标是找到共同兴趣点。刚刚加入一个交谈群体就想要控制整个交谈或者想要开始新的话题并非明智之举。更好的选择是继续你刚刚听到的话题，对他们所谈之事稍加评价，当然，这种评价最好是站在他们的角度思考的结果，而非你个人的观点。</p>
<p>一开始不要只谈论自己，这样会显得很自我。</p>
<p>一开始不要谈论他们的观点。对于刚刚见面的人，就开始对其观点评头论足很冒险。初步接触之后，再深入探索当然没问题，但是，一开始就这么做不合适。</p>
<ul>
<li>对于大家正在讨论的话题，稍作评论，以此“吸引大家的注意”。评论要简短，且尽量避免争议和武断。你的首要目标是和大家建立联系。这一步完成后，彼此之间才有足够的信任，才能继续深入交谈。</li>
<li>诚实坦然。问问自己，“我在贸然打断他人吗？”他们很可能会邀请你加入，不过，你一定要足够敏感。如果他们继续讨论明显只有他们自己感兴趣的话题，那不妨借合适的时机优雅地离开。</li>
<li>开场白千万不可以使用讽刺性的话语。这太冒险了。</li>
<li>一开始不要对工作、运动、健康、政治或宗教评论。这个时候并不合适说服谁加入你的阵营，而应该通过交流建立联系和信任。</li>
<li>选择和当时情境相关的交谈开场白，例如：——“嗯，你是怎么认识‘主持人’的？”——“你们彼此都已经认识了吗？”——“今天的交通特别堵。你们在路上遇到了吗？”——“你们是怎么找到这里的？”</li>
<li>集中注意力于“此刻”。屏蔽周围发生的事，这样你才能将注意力集中在你的交谈对象身上。这也是对他人的尊重，同时也有利于将注意力集中于交谈群体，而非你个人。</li>
</ul>
<p>如何捕捉有效信息</p>
<h3 id="永远保持一颗好奇的心"><a href="#永远保持一颗好奇的心" class="headerlink" title="永远保持一颗好奇的心"></a>永远保持一颗好奇的心</h3><p>直觉情绪者：爱好思考，因此，好奇心会自然而然产生。他们会运用想象力及意象，依照新的方式看待事物。可能他们会选择记日志的方式，抓住并组织观察所得，关注信息输入给他们带来的感受。如果在迪士尼乐园待上一天，他们会不停地走动，关注每个设计的细节。在一天的活动结束后，他们会根据不同事情带给他们的感受将一天的不同时间段记住。</p>
<p>理性思考者：爱好分析，因此，他们会对观察到的事物详细询问：这是谁？那是什么？什么时候？在哪儿？如何发生的？为什么会这样？他们要确定自己获取了所有的事实，然后再去分析这些如何暗含在每一天的生活中，如何将其应用于每一天的生活中。如果在迪士尼待上一天，他们会弄清楚在场的人数，队伍要排多久，并且根据所遇到事件的意义将其分别记住。</p>
<p>感性判断者：相较于抽象的概念，感性判断者更喜欢具体的观点。他们会通过视觉、听觉、触觉观察周边的世界，然后思考内在的逻辑关系。较之于应用，他们更在意细节。如果在迪士尼待上一天，他们会如数家珍般告诉你一天的所有细节。他们知道每次排队的时间，行人交通有哪些问题，如何解决这些问题等。</p>
<p>感官感知者：擅长于同时进行多项任务，并且通过行动来学习。他们通过参与不同活动获得观点和看法。如果在迪士尼乐园，他们会急于享受一天的时间，根本顾不上分析发生的一切。如果一天结束之后还记得些许细节，那一定是他们在讲述自己的经历。</p>
<p>我们的好奇心去哪儿了</p>
<h2 id="第7章-学会从他人的角度出发"><a href="#第7章-学会从他人的角度出发" class="headerlink" title="第7章 学会从他人的角度出发"></a>第7章 学会从他人的角度出发</h2><p>真正对他人感兴趣</p>
<p>亨利·杜蒙德说过，“这世上，对于快乐的追求，一半都变了味。人们以为快乐是拥有，是得到，是享受他人的服务。恰恰相反，快乐是给予，是服务他人。”</p>
<p>从积极的镜头审视自我</p>
<p>我们的思想决定了我们的态度，进而决定了我们的行为。我们生而具有不同的性格。成功的关键并不是要改变这种独一无二性，而是学会接受和赞美它。一旦我们对自己有了清楚的认识，了解了自己的独一无二性，我们就能够用这种独一无二性影响他人了。</p>
<p>镜头一：接受。要认识到，并非每次交谈都会完美无缺。当我们追求完美时，我们会发现每次交谈都无法如愿，挫败感也就油然而生。这样的经历会挫伤我们对于自我能力的认识，继而影响以后的交谈，因为我们看待自我的镜头乌云密布，失去了真实性。就像雪崩一样，向下的趋势总会不断加速，直到无法阻挡。</p>
<p>镜头二：愿景。和他人交流不顺的确让人不悦，但是，将这种不悦投放到未来就不好了。某个人的消极观点不应成为我们衡量自我价值的可靠尺码。</p>
<p>镜头三：积极性。交谈的目的是建立联系，而不是让他人永远记住你。</p>
<p>镜头四：感恩。每个人似乎都很忙，因此，时间也显得弥足珍贵。如果有人花时间和你交流，他们就是在送给你最宝贵的礼物。意识到时间的宝贵，你就会改变和他人交流的方式。</p>
<p>镜头五：满足。满足感是发自内心的，只有真正接受自己，认识自己的独特性才会产生。要认识到，我们并非粉墨登场的演员，他人也非台下的观众。我们彼此是相互影响，相互分享的，只有这样才可能收获让人满意的交流，双方才会奉上真实的自我。</p>
<h2 id="第8章-学会倾听，别人才能聊得开"><a href="#第8章-学会倾听，别人才能聊得开" class="headerlink" title="第8章 学会倾听，别人才能聊得开"></a>第8章 学会倾听，别人才能聊得开</h2><h2 id="第9章-学会提问，别人才能聊得透"><a href="#第9章-学会提问，别人才能聊得透" class="headerlink" title="第9章 学会提问，别人才能聊得透"></a>第9章 学会提问，别人才能聊得透</h2><p>封闭式提问Vs开放式提问</p>
<p>相比较而言，开放式提问很难用一两个词回答，回答者自然会拓展其思路。如果运用得当，开放式提问会有很多益处，比如：</p>
<p>交谈会更加容易，因为通过提问，你可以让对方讲述自己，谈谈自己的看法。所有的事情都是对方在做，你只需认真倾听就可以了！</p>
<ul>
<li>对方会更有安全感。如果向对方提出一连串只需简要回答的问题，他们会觉得是在接受质问。而开放式提问便于对方自行决定所要讲述的内容，因此，他们会有安全感。</li>
<li>有助于增进彼此的信任感。开放式提问会让对方会觉得你真正在意他，否则也不会提出这样的问题，而且他们也能感觉到你在用心倾听。感受到对方真正在意自己时，信任感就会油然而生。</li>
<li>真正掌控交谈的方向。开放式提问会让你自己感觉很放松，并且享受和他人的信息交换。一旦提出开放式的问题，你就开始真正掌控交谈的方向了。</li>
</ul>
<p>有效提问的技巧</p>
<p>选择开放式问题时，要确定这些问题的针对性。如果你问对方：“你对政治怎么看？”对方的回答可能就比较有限了。因为他/她很可能不知从何说起，甚至懒得回答。如果选择的问题比较有针对性，回答也就有了一定的范围，这样对方也就容易给出合适的回复了。</p>
<p>真正在意对方的回答。如果对方意识到你并不关心他们的回答，他们就会觉得你的提问毫无诚意。若非如此，还有一种可能就是，对方给出的信息远远超出了你的需要。</p>
<p>事先做好计划。比如说，下周我要和一位公司的CEO进行电话会议，而这个公司恰是我马上就要去工作的地方。我从没有和他见过面，因此我要事先浏览一下他们公司的网站，阅读一下这位CEO的大致介绍，从中我可以了解我们之间有哪些共同之处，据此设计一些问题，这样就能确保我的提问得到合适的回答了。</p>
<p>列出问题请单。对某些人来说这种做法显得不自然。他们觉得如果真的在意，无需笔头记录也可以想起要提的问题。可是，脑海存储的信息量太大，如果能够以便于记忆的方式将其组织好，也足以说明你对交谈的重视。跟那位CEO通话的时候，我的面前摆好一张问题列表。这样我就可以很放松，将注意力集中在交谈上，自如地去探索对方提供的新信息。</p>
<p>当心比较冒险的问题。人们的生活时刻都在发生变化，因此，如果你们有段时间未曾谋面，和对方交谈时，所有的假设都要小心。如果问到对方的配偶、工作或子女，却意外发现对方已离婚、失业或因孩子的学习而烦闷不已，这个时候双方就很容易陷入尴尬。你并不知道对方是否经历了或在经历痛苦，因此，发问之前一定要谨慎。比如可以这么表达：“上次我们聊天时，记得你说过工作上有些棘手，后来怎么样了？”或者“你的儿子最近怎么样？”这样的问题就比较诚恳，因为你没有故意回避彼此都知道的事实，但同时又在慢慢接近主题，而且对于可能出现的问题很敏感。</p>
<p>遇到不理解的问题，不妨直接提问。很多人有这样的担心，对方会以为我们没有认真倾听。而事实恰恰相反，直接提问会让对方感觉出你在认真听讲。因为只有用心倾听才会提出问题。</p>
<p>如果对方失去了交谈的兴趣，并不一定是你的话题不合适，而是你将注意力过多集中在交谈上，而忽视了对方的真正想法。专业的销售人员都知道，如果要和顾客有效交谈，交谈中顾客所说至少要占70%。</p>
<p>问什么问题并不是关键所在，真正的关键在于你对对方的回答真正感兴趣。仔细听对方的回答，而不是一心想着接下来你要说什么。</p>
<p>遇上了沟通高手，该怎么办？</p>
<p>交谈过程中，你一旦成为受关注对象，该如何是好？</p>
<p>千万不要显摆自己</p>
<p>人们更愿意和自己喜欢的人建立联系。如果你和他人讨论他们关心的事情，彼此的关系就很容易拉近。想一想，那些真正倾听你的人是如何吸引你的吧。</p>
<p>总结来说，有效的提问需要注意以下几点： ●提一个封闭式问题。 ●然后选择新闻采访使用的开放式问题：谁、什么、哪里、什么时候、怎么样、为什么。 ●仔细倾听对方的回答。 ●重复。</p>
<h2 id="第10章-压力，一种积极的沟通力量"><a href="#第10章-压力，一种积极的沟通力量" class="headerlink" title="第10章 压力，一种积极的沟通力量"></a>第10章 压力，一种积极的沟通力量</h2><p>对于有效沟通来说，压力是一种积极的力量。如果我们感觉到压力，这就说明我们正在做的事情是有意义的，是值得的。</p>
<p>我们为什么会如此紧张</p>
<p>知识链接——积极压力和消极压力</p>
<p>疏通压力：我们可以做些什么</p>
<p>注意对方说了些什么，而非时刻关注自己的感受。这个需要练习，不过，一旦你能不再担心自己的表现，就会感到自如的。</p>
<p>交谈顺利进行需要花一定的时间，要认识到这一点。这就像和一位陌生人跳慢步舞，你需要一定的时间才能掌握对方的节奏和风格。</p>
<p>认真准备。明白自己有哪些探索工具，如何使用。</p>
<p>交谈成功，不要独揽功劳；交谈失败，也不要独自担负责任。交谈的顺利进行，至少需要双方的配合，无论结果怎样，都不是哪一方的责任。</p>
<p>先从小范围开始。在社交场合，尝试寻找看起来友善、有亲和力或你认识的人，从这里开始。可能你会注意到在某些方面和你很像的人，比如说，穿衣风格很像，或者对方也是一个人在自助餐桌前享受鹅肝酱等等。不妨和这样的人一起交流，实践一下自己的交谈技巧。这样，你会更加自信地和他人交谈，对方也有可能将你引荐给他人。（注意：随着时间的推进，无须开启太多交谈。）</p>
<p>活动结束后，回顾你的“表现”——只要一次就够了。体育队一般都会回放前一周的比赛拍摄录像，以便弄清楚哪些地方还可以改进。对于交谈来说，这也是比较有效的。思考哪些地方表现不错，哪些地方依然需要学习，确实很有价值。</p>
<p>不要将自己的表现和在场其他人的表现相比较。如果真的这么做了，你一定会挑选出最擅长交谈的人，失落感自然难免。相反，如果你和不如自己的人相比较，就容易自负。只要用自己的标准来衡量就行了——即自己过去的表现及对于以后的期望。</p>
<h3 id="如何有效地掌控压力"><a href="#如何有效地掌控压力" class="headerlink" title="如何有效地掌控压力"></a>如何有效地掌控压力</h3><p>对于有效沟通来说，压力是一种积极的力量。如果我们感觉到压力，这就说明我们正在做的事情是有意义的，是值得的。因此，我们要给予疏导。</p>
<p>首先，我们可以练习从心理层面控制压力。本章主要讨论准确、真实地评估所处状况，而不是给予错误的解读。如果想象着交谈能够顺利进行，且事实如此，我们会觉得特别舒心；如果进展不顺，心里就会不舒服。不管情况如何，我们都要如实对待，分析一下，将来我们应该如何做出改变。而现在，对于进展不顺利的交谈不要总是纠结，过去的事情就让其过去。</p>
<p>第二，我们可以尝试从身体层面控制压力。不要总想着一切都无法改变，相反，可以实践本书前面讨论的简单技巧。很多压力症状通过呼吸练习、锻炼都可以得到缓解，并非一定都需要心理治疗。如果交谈过程中，我发现自己牙齿之间居然藏着菠菜，这种情况下，什么交谈技巧都不需要，有牙线就可以了。</p>
<p>第三，我们要经常练习，学会控制压力。一旦认识到控制“燃料”的价值，我们就会寻找机会不断实践。实践次数越多，就越容易。压力不会消失，我们也不想让其消失。在交谈过程中，我们可以让其成为我们的好伙伴。</p>
<h2 id="第11章-如何应对棘手的交谈"><a href="#第11章-如何应对棘手的交谈" class="headerlink" title="第11章 如何应对棘手的交谈"></a>第11章 如何应对棘手的交谈</h2><p>总有些情况在我们预料之外</p>
<p>不管你的交谈水平如何，都有可能遇到不顺利的局面。有时候你可以感觉到事情在朝着糟糕的方向发展，不过大多数都是突发情况，完全在我们的预料之外。</p>
<p>真正将对方放在你心上</p>
<p>真正将对方放在你心上注意一点，人际关系中没有什么操控术。一切的一切，其关键还是要诚实，真正对他人感兴趣。我们并不是要你学着如何在棘手的交谈中“获胜”，而是坦诚相对，让双方都受益。任何别有用心的伎俩都不利于交谈的顺利进行。</p>
<h2 id="第12章-战胜交谈拖延症"><a href="#第12章-战胜交谈拖延症" class="headerlink" title="第12章 战胜交谈拖延症"></a>第12章 战胜交谈拖延症</h2><p>为什么会有交谈拖延症？</p>
<p>在交谈过程中，我们往往会将更多的精力放在话题的开启和维系上，比如，如何克服最初的犹豫，如何接近对方，如何整理思路，如何选择正确的话语，等等。如果我说，结束交谈才是最为困难的部分，恐怕很多人都会感到惊讶。</p>
<p>如何恰到好处地结束交谈</p>
<p>结束并不一定总意味着很糟糕，再顺利的交谈也有结束的时候。那么，我们应该如何优雅地结束交谈呢？</p>
<ul>
<li>结识新朋友。</li>
<li>了解新信息。</li>
<li>为了业务目的交流。</li>
<li>出售商品或服务。</li>
<li>享受和他人的交流互动。</li>
<li>说服或激励某人。</li>
</ul>
<p>一旦明确了自己的交谈目的，不妨尝试以下方式让交谈体面地结束：</p>
<ul>
<li><p>转移话题。记得我小时候，柔道是大家惯用的防身技能。因为柔道并不需要练习者有多么健硕的体格，只要学会借力打力、转移力道就可以了。交谈中，如果对方强行将话题维持在不愉快的道路之上，你可以将之转向其他方向，然后重新控制局面。记得最近在健身房更衣室，我旁边那个家伙看着壁挂式电视，对当时正在播放的某条新闻评论不休。他的强势让我有些不舒服，而且我觉得自己无法反驳他的观点。于是，我试图将其评论引至新的方向：“是的，似乎最近有很多类似的让人沮丧的新闻故事。最近一次你看到鼓舞人心的新闻是什么时候？”他的语气完全变了，开始回答我的问题，而且根本没有意识到他的话语已经改变了方向。</p>
</li>
<li><p>去粗取精。想一下交谈中最有趣的部分是哪些，回顾一下，然后体面地结束交谈。比如说，“我之前从来没有跟蹦极的人交流过，我以为自己不会去尝试，但是，今天听了你的经历，我觉得真是太棒了。今天晚上我还想再认识一些人，所以，我得告辞了。很感谢你和我交流——预祝今晚过得愉快！”这种总结直接、体面，而且没有留下任何商榷的余地。你已经简要表述了自己要做的事，也给了对方鼓励。</p>
</li>
<li><p>坦诚相告。如果你在交谈之前就很明确自己的目的，不妨以此作为结束交谈的合理工具。简单地告诉对方，你接下来要做什么，要去和谁交流，要去哪里，要看什么。这样对方就会明白结束交谈是因为你的任务还没完成，需要继续，而不是逃避他们。</p>
</li>
<li><p>换位思考。在交谈过程中，让对方知道你正在为预期的目标努力，并邀请对方参与进来帮助自己实现目标。这样不仅可以实现换位思考，还可以让对方有参与的成就感。比如说，你可以这么问：“你是否认识从零开始创办小企业的人？我正在做相关的调查，想见一见有相关经历的人。”如果对方恰好了解该领域，你就可以全面探索了。如果没有，他们也会乐于向你引荐更合适的人选。如果他们确实不认识这样的人，你可以请求对方谅解，然后结束谈话。</p>
</li>
<li><p>灵活机动。下一次置身社交场合的时候，可以巧妙利用群体交谈中的动态变化脱身。注意观察一下一小群人在一起会讨论些什么。如果有一两个人新加入到这个小圈子，那么原来的人当中就可能有一两个借机离开。你不妨趁机悄悄离开，这个时候大家往往很难发现。</p>
</li>
<li><p>移花接木。如果在社交场合你已经和几个人交流过，不妨充当主持人的角色，让其他人彼此认识。指出他们有哪些共同的兴趣爱好，以便于他们开始交谈。当他们注意到对方，开始交谈之后，你就可以借机礼貌地离开了。因为你的引荐，他们彼此开始交谈变得容易多了，因此会心存感激。当然，你也可以继续自己的事情了。不过，要确保这么做的动机要合理。如果你只是为了摆脱某位无聊的人，那么，将此人引荐给别人，给别人带来麻烦，你也会遭厌恶的。</p>
</li>
</ul>
<p>结语 不积跬步无以至千里</p>
<p>我们从哪里开始呢？</p>
<ul>
<li><p>认识到自己的性格和脾气。</p>
</li>
<li><p>接受自己的独特性。</p>
</li>
<li><p>发挥自己的独特性，并以此为基础，和他人交流。</p>
</li>
<li><p>第一步：审时度势。</p>
</li>
<li><p>第二步：相互陪伴。</p>
</li>
<li><p>第三步：事先准备。</p>
</li>
<li><p>第四步：学会观察。</p>
</li>
<li><p>第五步：进展评估。</p>
</li>
<li><p>第六步：评估和称赞。</p>
</li>
</ul>
<p>（1）不要忽视其他人的感受。我们总以为，如果我们不去理睬某个人的感受，或者将其化小，感受就会自然消失。实际上，事情会因此变得更糟糕。我们要仔细倾听，以此判断对方的感受，并提供帮助。如果足够真诚，彼此之间的信任就可以建立起来。</p>
<p>（2）如果某人很沮丧，不要咄咄逼人地去劝说。对方需要的是感同身受，而不是建议。我们都有过这样的经历：想和对方推心置腹说说心里话，可是，对方却不断地提建议，试图解决问题。</p>
<p>（3）如果他人需要稍长的时间才能“切中要点”的话，千万不要让自己走神。如果走神了，立刻让自己回到对方所说的内容上来，并集中注意力倾听。确保自己不要一直插话，补充对方言语中的暂停等空白。这样的话，他们会觉得你很贸然，似乎很急于从交谈中脱身。</p>
<p>（4）不要受第一印象的误导。我们和他人交谈的时间越长，就越能了解隐藏在表面之下的内容。我们应该这么想：无论对方是谁，交谈中我们所听到的、所看到的都并非全部。最近我给一个公共组织的职员开研讨会授课。当天第一个走进会场的人跟我聊了很多，说到了他的工作，他觉得别人的行为和他想象的如何不同以及他在公司的种种经历等。他给我的第一印象就是傲慢、独断，这并非我所期盼的。这样的人很容易把会场搞得一团糟。可是，慢慢地，我发现他并非真的傲慢和独断——他负责整个公司的安全问题，可是，就在研讨会的前一天晚上，有人就因为违反了安全程序而死亡。我一开始定义的“傲慢”其实是交谈中他表达安全问题时的激动情绪。三天的研讨会结束的时候，他对于公司职员细致的关怀和情感赢得了全体参会人员的尊重和信任。</p>
<p>（5）讲述个人经历时，一定要确保准确。因为你无法确定对方是否也身在其中，如果你的言辞夸张，对于细节描述不准确，他们就会产生质疑。</p>
<p>（6）如果和他人刚刚见面，千万不要发生争论。如果对方不认识你，彼此之间就不存在信任。没有信任，他们就没有理由花时间和精力听你陈述了。</p>
<p>（7）一定避免以下“交谈杀手”： ●未经请求，给对方提建议（对方会将此视为傲慢）</p>
<p>纠正他人（比如，他人所说的细节、使用的语言表达以及所做的总结等） ●显示出不感兴趣（如果没有兴趣，还有什么好谈的呢？） ●道听途说（对方会认为你也会到他人那里说他们的是非） ●在对方说到一半时，替他/她把句子说完整（这是他们的事，不需要你来做）</p>
<p>（1）在表达自己的观点前，先仔细倾听对方的观点，考虑对方的感受。我们总是喜欢立刻表述自己的观点，告诉对方他们应该怎样。但是，如果在仔细倾听之前就给出回复，对方可能也不会采纳我们的观点。如果贸然给出对方不希望的建议，就等于在暗示对方他们无法独自应对。</p>
<p>（2）对新鲜话题保持足够的敏感。彼此认识再久，你也很可能没有完全了解对方。迪克是我的好朋友，我们认识十多年了。上周他和妻子一起来我家，我们围坐在露天阳台，看到很多鸟儿攒动在屋檐下的鸟食器周围，这个时候，他开始描述那些鸟儿的种类、名称、特点，他说自己曾经花了好几年自学鸟类知识。可是，我们认识这么久，我对此真的一无所知。几乎每个人都有我们不知道的知识或经历。因此，在每次交谈时，我们要特别注意去挖掘。</p>
<p>（3）遵守黄金法则：己所不欲，勿施于人。想一想交谈中对方做哪些事情会让你觉得无益，然后自己在交谈过程中要格外注意。</p>
<p>（4）假设交谈结束后你的另一半或朋友会让你重复交谈的内容，那你就要更加仔细地倾听，记住更多的信息了。</p>
<p>（5）确定自己真的想要倾听对方。这一点千万不要弄虚作假。如果不感兴趣，你的肢体语言和面部表情会出卖你。就我个人而言，我会在交谈前花些时间提醒自己仔细倾听，这对我交谈中的注意力会有很大影响。我会告诉自己，交谈很重要，我一定要认真去听。</p>
<p>（6）听他人说话的时候，记住之前讨论过的“过滤器”。任何话语都被生活经历和思维模式过滤，所以，你所理解的，未必是对方真正想表述的。</p>
<h2 id="结束交谈"><a href="#结束交谈" class="headerlink" title="结束交谈"></a>结束交谈</h2><p>交谈中你只需管好自己就可以了，因为你没有办法控制他人的回复，因此也不要让他人的回复影响你的观点。</p>
<p>当然，交谈中不存在“选购”，但是，我们总要和不同的人接触，在这个过程中我们会选择自己想要继续联络的人。要从现实出发。一开始的时候放慢速度，控制自己的进程，享受每一步的前进。先在自己感觉安适的范围内交谈，然后再逐步拓展领域。时间长了，交谈的领域就会越来越广了。</p>
<p>交谈中你会感觉自信、安适，但是，不要想着把所有的压力感都去掉。只有在一定的压力下，交谈才会真正进展顺利。现实生活中并没有真正的随意交谈。任何有益的事情都需要我们付出努力，但是，所有的努力都应建立在自信的基础上。</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式</title>
    <url>/p/c6374498.html</url>
    <content><![CDATA[<p>在软件工程中，设计模式（design pattern）是對软件设计中普遍存在（反覆出現）的各种问题，所提出的解決方案。</p>
<a id="more"></a>

<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>what：定义创建对象的接口，让子类来决定实例化哪个类</p>
<p>why：分离产品的创建和使用</p>
<h3 id="抽象工程模式"><a href="#抽象工程模式" class="headerlink" title="抽象工程模式"></a>抽象工程模式</h3><p>what：封装一组具有同一主题的单独工厂</p>
<p>why：使产品接口与产品主题分离</p>
<h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p>what：通过接口抽象、装配、对象实现分离复杂的创建配置过程</p>
<p>why：解决复杂对象的创建过程的封装问题</p>
<h3 id="对象池-object-pool-pattern"><a href="#对象池-object-pool-pattern" class="headerlink" title="对象池:object pool pattern"></a>对象池:object pool pattern</h3><p>what:在对象池中管理对象的创建、销毁</p>
<p>why：优化初始化、实例化代价高、需求频繁的对象的管理和访问效率</p>
<h3 id="惰性初始模式"><a href="#惰性初始模式" class="headerlink" title="惰性初始模式"></a>惰性初始模式</h3><p>what：懒加载、延迟物件创建</p>
<p>why：节省资源和调高速率</p>
<h3 id="原始模式："><a href="#原始模式：" class="headerlink" title="原始模式："></a>原始模式：</h3><p>what：复制一个存在的实例而不是新建实例</p>
<p>why：比起创建复杂或耗时的资源，复制资源效率更好</p>
<h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>what：只拥有一个全局对象</p>
<p>why：便于协调整体行为</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式：adapter-pattern"><a href="#适配器模式：adapter-pattern" class="headerlink" title="适配器模式：adapter pattern"></a>适配器模式：adapter pattern</h3><p>what：类自己的接口包裹在一个已经存在的类里面</p>
<p>why：隐藏具体实现、便于后期修改、兼容判断跳转</p>
<h3 id="桥接模式："><a href="#桥接模式：" class="headerlink" title="桥接模式："></a>桥接模式：</h3><p>what：分离事物对象和具体行为、具体特征</p>
<p>why：分离各自的独立变化</p>
<h3 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h3><p>what：把多个对象组成树状结构来表示局部与整体</p>
<p>why：可以对待单个对象和对象的组合</p>
<h3 id="装饰模式："><a href="#装饰模式：" class="headerlink" title="装饰模式："></a>装饰模式：</h3><p>what：向某个对象动态地添加更多的功能</p>
<p>why：修饰模式是除类继承外另一种扩展功能的方法</p>
<h3 id="外观模式：facade-pattern"><a href="#外观模式：facade-pattern" class="headerlink" title="外观模式：facade pattern"></a>外观模式：facade pattern</h3><p>what：定义高层接口</p>
<p>why：优化复杂的子系统的使用</p>
<h3 id="享元：flyweight-pattern"><a href="#享元：flyweight-pattern" class="headerlink" title="享元：flyweight pattern"></a>享元：flyweight pattern</h3><p>what：共享物件</p>
<p>why：减少重复读取某物件产生的内存消耗<br>（单例？）</p>
<h3 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h3><p>what：为其它对象提供一个代理以控制这个对象的访问</p>
<p>why：事件传递优化</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h3><p>what：流处理模式</p>
<p>why：命令、对象的链式处理</p>
<h3 id="命令模式：Command-pattern"><a href="#命令模式：Command-pattern" class="headerlink" title="命令模式：Command pattern"></a>命令模式：Command pattern</h3><p>what：行为参数统一封装，命令封装成对象</p>
<p>why：可重复、取消</p>
<h3 id="解释器："><a href="#解释器：" class="headerlink" title="解释器："></a>解释器：</h3><p>what：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>
<p>why：复杂、多参、解释型、定义型功能实现封装</p>
<h3 id="迭代器模式："><a href="#迭代器模式：" class="headerlink" title="迭代器模式："></a>迭代器模式：</h3><p>what：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节</p>
<p>why：简化遍历、多样遍历</p>
<h3 id="中介者模式："><a href="#中介者模式：" class="headerlink" title="中介者模式："></a>中介者模式：</h3><p>what：定义中介对象，封装系统中对象间的交互方式</p>
<p>why：避免交互对象出现精密耦合；独立改变一组对象之间的交互方式而不影响其他对象。</p>
<h3 id="备忘录模式："><a href="#备忘录模式：" class="headerlink" title="备忘录模式："></a>备忘录模式：</h3><p>what：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态</p>
<p>why：保留中间状态便于还原</p>
<h3 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h3><p>what：定义对象间一种一对多的依赖关系，当对象改变状态，所有依赖于它的对象都会得到通知并自动更新。</p>
<p>why：解决一对多的重度关联和耦合</p>
<h3 id="状态模式：state-pattern"><a href="#状态模式：state-pattern" class="headerlink" title="状态模式：state pattern"></a>状态模式：state pattern</h3><p>what：允许一个对象在其内部状态改变时改变它的行为</p>
<p>why：封装转换规则，简化条件判断<br>where：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为</p>
<h3 id="策略模式：strategy-pattern"><a href="#策略模式：strategy-pattern" class="headerlink" title="策略模式：strategy pattern"></a>策略模式：strategy pattern</h3><p>what：定义一系列算法，封装每一个算法让它们可以相互替换。</p>
<p>why：多个算法的互相替换和管理</p>
<h3 id="模板模式："><a href="#模板模式：" class="headerlink" title="模板模式："></a>模板模式：</h3><p>what：定义模板结构，将具体内容延迟到子类中实现</p>
<p>why：提高代码复用性和扩展性、实现反向控制</p>
<h3 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h3><p>what：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>
<p>why：对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去；假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>这个男人来自地球：人类在时间长河里的影子</title>
    <url>/p/66ce3802.html</url>
    <content><![CDATA[<p>科幻可以是《阿凡达》那种奇幻、可以是《流浪地球》那种宏大、可以是《星际穿越》那种严肃，但它们探讨的都是人类的未来，在人类社会上加多一块科学的积木后会有什么改变，而《这个男人来自地球》的这块积木是人类的寿命。</p>
<p>历史教授 Joh.OldMan 在离职聚会上，宣布自己活了大概一万四千年，肉体的成长在他大概35岁的时候就停止，衰老更是从来没找上门，他经历了史前社会、在两河流域游荡了两千多年，是巴比伦的公民、拜访过佛祖、见证过罗马的崛起、引导了基督教的发展、是耶稣传说的本体。</p>
<p>是故事还是真实？来访的大学同事们有的震惊、有的愤怒、有人觉得有趣、有人觉得可恨，当一个个问题在主角面前解答而且没人能够找到漏洞时，不知道是否有人后悔参加这次聚会，是否有人狂喜遇到人类历史的见证人？</p>
<p>在故事的最后，在慢慢变小的火炉旁，Joh.OldMan 在众人的祈祷、愤怒中宣布这只是一个故事，只是一个学识渊博的教授编出来的故事而已，相信历史的可以继续相信，坚持信仰的不需担心信念的颠覆，所有人都得到了答案，一个安心的答案，一个可以继续平常生活下去的答案，皆大欢喜。</p>
]]></content>
      <tags>
        <tag>mov</tag>
      </tags>
  </entry>
  <entry>
    <title>逃避自由:自由也意味着孤独</title>
    <url>/p/e86d4348.html</url>
    <content><![CDATA[<p>1，弗洛伊德的观点，人是有欲望的→社会必须压抑欲望→欲望升华→产生人类文明。换言之，他认为历史是人类心里力量的结果，而心里力量本身是不受社会影响的。弗洛姆观点不同，他认为，社会具有压抑和创造两个功能，而弗洛伊德认为社会仅仅负责压抑欲望。</p>
<p>2，“追求财富的迫切愿望，只是某些文化所特有的需求”，“追求财富作为人类行为的最主要动机是表面的”。这种说法我觉得比较有意思，也就是说，其实财富在满足人的基本需求之后，它具有的便是社会性了，拥有大量财富，是人能有更良好社会感觉的工具，而不是财富本身带来的满足。</p>
<p>3，“宗教与民族主义，以及任何习俗和任何信仰，不论多么荒诞不经，微不足道，只要能使个人与他人联系起来，就能使人逃避最害怕的一件事，孤独”</p>
<a id="more"></a>
<p>人害怕孤独有两个原因，一是，不与人合作，人就无法生存，尤其是儿童，被人抛弃，甚至意味着死亡。二是，人的渺小感，生命若无从属，若无某些意义与方向，就会被自身的无意义感压垮，疑惑将使其丧失活动即生命的能力。</p>
<p>4，“人获得愈多自由，愈个人化，就愈别无他择。或者通过自发性的爱和创造性的工作来使自己与世界联结起来，或者通过那些会破坏他的自由和他个人自我完整的与世界的联结方式来寻求某些安全”，虽然看似绕口，其实还是颇有道理的，弗洛姆的对许多东西的解释都是通过“逃避孤独”这个关键概念，他对于爱情和专制这两样看似截然不同的东西的解释都可以从这句话中窥见一二。</p>
<p>5，“婴儿脱离母体，精神仍然未脱离，有原始关联，之后的教育（即给儿童设置一些限制和挫折），使儿童区分出自己与世界，自己与母亲”，从文中看，此过程大约是充满痛苦的，因此在将来的爱情中，或者说男女的关系上，是成人唯一能再度体验到合而为一的感觉，这样的感觉是极具安全感的同时也就极具诱惑，因此也是最有利于逃避孤独的，记得不知道在哪看到过，男女交合是上帝给人最后的一片止痛药，止痛药虽然有效，但不可滥用，滥用之后便再也没有东西可以抵御与生具来的孤独了。</p>
<p>6，“日益发展的个体化过程的一个方面就是自我力量的增长，就是日益增长的孤独”</p>
<p>7，“世界与他人是强有力且充满危险的，自己会有一种无力量和忧虑的感觉”</p>
<p>8，“人类会产生一种冲动使自己完全隐没在外界中”</p>
<p>9，“原始宗教证明人与自然的一体感，即人与自然的原始关联”，我想他这里说的，原始关联，也许就类似前面说的母亲与孩子的原始关联，于是就想到了我国传统的“天人合一”的思想，可是现在不能很确定的知道“天人合一”的精确定义，从字面上看，貌似和弗洛姆的原始宗教有相同之处，莫非我们的“天人合一”思想是某种原始宗教的残留？</p>
<p>10，“现在人在幻觉下生活，他自以为他了解他所想要的东西，而实际上他所想要的是他人所希望他要的东西”</p>
<p>总结一下，《逃避自由》大致的意思，就是之所以几乎同一时间出现了各种形式的专政，如希特勒，如苏联等等，一般通常的认为是由于他们采取了欺骗的办法上台之后，拥有巨大权力，人民没有能力将他推翻，但是弗洛姆认为这只是问题的一方面，专制的某些做法，其实是暗合了人类心底的某些恐惧和向往的，因此才会有这样巨大的影响力。</p>
<p>一如刚离母胎的婴儿，虽然从生理意义上成为独立个体，却失去了以往的安全保障。</p>
<p>自由的，也就意味着孤独的。天堂是永远的失去了。</p>
<p>作为个人，你难道不曾体会过面对庞大社会时的孤立与无助？难道不曾因为自我与他人的不同而诚惶诚恐？难道不曾因为无法得到群体的认同面临被边缘化的处境而感到深深的战栗？难道不曾一次次陷入疑惑，疑惑自己的思想究竟真的是自己的，还是这个社会灌输给你的？</p>
<p>「他自由了，但这也意味着：他是孤独的，他被隔离了，他受到来自各方面的威胁，他没有文艺复兴时代资本家所拥有的财富和权力，也已失去了与人及宇宙的统一感，于是他被一种个人无可救药，一无所有的感觉所笼罩。」</p>
<p>在「上帝死了，理性万岁」的呼声中，极权主义的横空出世着实让人大跌眼镜，也让人们开始意识到「逃避自由」的问题。弗洛姆如此总结：</p>
<p>「人类对自己具有独立行动的能力这一点丧失信心，是法西斯主义能实现其政治目标的肥沃土壤。」</p>
]]></content>
      <tags>
        <tag>book</tag>
        <tag>mind</tag>
      </tags>
  </entry>
  <entry>
    <title>选择与思考--给青年的十二封信</title>
    <url>/p/c1698559.html</url>
    <content><![CDATA[<p>判断一本书是好是坏，有一种方法，就是看在不同时期阅读能否带来不同的感触。</p>
<p>一本书，少年看争锋，青年看谋略，中年看局势，正是因为你见识阅历的成长，慢慢能够领略到作者更底层的想法。</p>
<p>朱光潜先生的《给青年的十二封信》语言真诚、简单明理，而且全文没有高高在上的威压，平平淡淡得就像喝茶聊天般，表示就信仰、新年、理想、人生道德、审美等观念上的危机与迷茫，以‘过来人‘的身份探讨一番。</p>
<a id="more"></a>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>“人类学问逐天进步，不努力跟着跑，便落伍退后了。”</p>
<p>尤其在现在这种信息化社会，信息技术的迭代升级就是快、快、快。一个的行业总会有从萌芽、发展、成熟、没落的过程，但在现在一个行业在资本和技术的推动下，可以用短短的1～2年就到达成熟期，那么同样代表我们生存的技术迭代速度也大大加快。</p>
<p>“书读不尽，需要有所选择，选择有价值、能反复读的书籍，有些书读完索然无味那还不如不读，多读一本没有价值的书，就少读了一本有价值的书，需要用批评态度去衡量书的内容。”</p>
<p>如果因为焦虑无头苍蝇式学习，那么你可能除了自我满足以外什么都没得到，信息时代拒绝屏蔽信息比接受信息来得更重要，弱水三千只取一瓢，少是少了点，但每一瓢水都是你自己真正需要的。</p>
<h2 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h2><p>“人生在世，除了工作与物质享受外，还需要有情趣，在精神上的慰藉和享受，否则，生活就太枯燥、单调、寂寞了。”</p>
<p>“长大一岁，感觉兴趣的敏锐力便迟钝一分，兴趣也是需要培养的。”</p>
<p>自古人生何其乐,偷得浮生半日闲。</p>
<h2 id="动与静"><a href="#动与静" class="headerlink" title="动与静"></a>动与静</h2><p>“愁生于郁，解愁的方法在于泄；郁由于静，求泄的方法在于动。”</p>
<p>“闲愁之苦！人生还是那么个人生，世界还是那么个世界”</p>
<p>“世界上最快活的人不仅是最活动的人，也是最能领略的人。所谓领略，就是能在生活中寻出趣味。好比喝茶，渴汉只管满口吞咽，会喝茶的人地一口一口的细啜，能领略其中风味。”</p>
<p>“我生平不怕呆人，也不怕聪明过度的人，只是对着没有趣味的人，要勉强同他说应酬话，真是觉得苦也。”</p>
<h2 id="实事"><a href="#实事" class="headerlink" title="实事"></a>实事</h2><p>“你应该回头看看你自己是什么样的一个人，看看政府是什么样的一个政府，看看人民是什么样的一个人民。”</p>
<p>“读书不忘救国，救国不忘读书。”</p>
<p>“大事小事都要有人做。”</p>
<p>对于学生、对于学术，看不见实际意义是一种深深焦虑，但实事不只在理论的也在生活中的小事上。</p>
<h2 id="理念与现实"><a href="#理念与现实" class="headerlink" title="理念与现实"></a>理念与现实</h2><p>“要么冲突，要么妥协。冲突就是烦恼，妥协就是堕落。”</p>
<p>“不在沉默中爆发,就在沉默中死亡。”</p>
<p>“取舍，敢于在歧路上有所取舍”</p>
<p>少则得，多则惑。</p>
<h2 id="恋爱价值观"><a href="#恋爱价值观" class="headerlink" title="恋爱价值观"></a>恋爱价值观</h2><p>“一般人误解恋爱，动于一时飘忽的性欲冲动而发生婚姻关系，境过则情迁，色衰则爱弛。这虽名为恋爱实则只是纵欲。”</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>“舞台的悲剧生于冲突之得解决，人生的悲剧则多生于冲突之不得解决。世间许多人站在歧路上只徘徊顾虑，既不肯有所舍，便不能有所取；世间也有许多人既走上这一条路，又念念不忘那一条路，不免差误时光。 ”</p>
<p>“这些毛病都在于“摆脱不开”，这是人生悲剧的起源。认定一个目标，便专心致志向那里走，其余一切都置之度外，这是成功的秘诀，也是免除烦恼的秘诀。 ”</p>
<h2 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h2><p>“科学愈进步，人类征服环境的能力也愈大。征服环境的能力愈大，本确是人生一大幸福。但同时也易生流弊。困难日益少，而人类也愈把事情看得太容易，做一件事不免愈轻浮粗率，而坚苦卓绝的成就也便日愈稀罕。 ”</p>
<p>“生活的多方面，需要我们去知（know），还需要感（feel）”</p>
<p>“言有尽而意无穷”</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>“顺着自然所给的本性生活着，像草木虫鱼一样，生活自身就是方法，生活自身也就是目的。 ”</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把握当前，内心保持平静但要有探索世界的好奇心，多读书、多交友，了解他人，接受自己，拒绝信息污染。</p>
<p>人生是一辈子的事。</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>道可道：《老子》的要义与诘难</title>
    <url>/p/c1da1465.html</url>
    <content><![CDATA[<h2 id="一、《老子》的要义"><a href="#一、《老子》的要义" class="headerlink" title="一、《老子》的要义"></a>一、《老子》的要义</h2><h3 id="1、老子其人与《老子》其书"><a href="#1、老子其人与《老子》其书" class="headerlink" title="1、老子其人与《老子》其书"></a>1、老子其人与《老子》其书</h3><p>“老子”到底是个什么人？在《史记》中就有三个不同的版本。后世研究者莫衷一是。</p>
<p>“老子”到底是一个人还是同属一个思想流派的几代人的统称？至今众说纷纭。</p>
<p>历代《老子》的注解多如牛毛。可以说，有多少种注解，就有多少个版本的《老子》。</p>
<p>由于年代久远，资料散轶，对老子其人与《老子》其书，其实并没有真实可靠的定论。但是，并不能因为没有定论，就认为某一种说法和版本是正确的。“存疑”是合乎理性的，“盖棺定论”是荒谬的。</p>
<a id="more"></a>

<h3 id="2、《老子》是写给什么人看的？这本书的写作目的是什么？"><a href="#2、《老子》是写给什么人看的？这本书的写作目的是什么？" class="headerlink" title="2、《老子》是写给什么人看的？这本书的写作目的是什么？"></a>2、《老子》是写给什么人看的？这本书的写作目的是什么？</h3><p>《老子》是写给统治者看的，目的是教导他们如何治国。</p>
<p>《老子》不是写给被统治者看的，不是写给弱者看的，不是写给loser看的。这本书里面没有心灵鸡汤，没有阴谋诡计，没有神仙上帝。</p>
<p>《老子》的表述方式虽然玄之又玄，但是其标靶却是现实中的眼前事。</p>
<h3 id="3、《老子》思想的要点是什么？"><a href="#3、《老子》思想的要点是什么？" class="headerlink" title="3、《老子》思想的要点是什么？"></a>3、《老子》思想的要点是什么？</h3><p>四个字——崇本息末。</p>
<p>以种树为例，人应该重点养护地下不可见的树根，为其施肥、浇水，这样，地上可见的枝叶自能繁盛。如果反过来照顾枝叶而不顾树根，则短期内可能看到一个虚假繁荣的景象，长期则树木枯败。</p>
<p>再以养生为例，如果一个人生活规律、运动适度、营养均衡、心情愉悦，就会容光焕发。如果他只顾在脸上涂脂抹粉，熬夜、不运动、营养失衡、心情恶劣，虽然短期内看上去很美，时间一长，生命必会枯竭，容颜必会衰老。</p>
<p>做人做事，都把重心放在最关键的核心要点上，长期投入，似缓实速。</p>
<h3 id="4、怎么理解“无为”？"><a href="#4、怎么理解“无为”？" class="headerlink" title="4、怎么理解“无为”？"></a>4、怎么理解“无为”？</h3><p>“无为”不是什么都不做，而是顺应规律和形势，不胡乱作为。</p>
<p>历史上，朝代更迭之后，新的统治者还未稳固中央集权，来不及严加管束，任由百姓发展时，国家最兴旺，人民最幸福。一旦新的秩序建立，统治者开始严加管束，则国家开始衰弱。</p>
<p>每当有汉武帝这种强有力的君主出现时，必然会导致百业凋敝，人民困苦。</p>
<p>我们也要清楚，“君之道”与“臣之道”并不相同。君虚静无为，而臣则要积极有为。君臣关系，就像人体的意识与器官，前者不要胡乱干预，后者则要恪尽职守。</p>
<h3 id="5、怎么理解“无为而无不为”？"><a href="#5、怎么理解“无为而无不为”？" class="headerlink" title="5、怎么理解“无为而无不为”？"></a>5、怎么理解“无为而无不为”？</h3><p>治理一个国家，就像在无边无际的大海上驾驶一艘船，应该视天气和风浪的情况而选择进退，才是长治久安之道。</p>
<p>明智之人，都懂得“形势比人强”。</p>
<p>如果驾驶员一定要达到某个目标，无视外界情况和船员安危，不停地加大马力、转换航向，则船有覆灭之险。</p>
<h3 id="6、中西思想分野"><a href="#6、中西思想分野" class="headerlink" title="6、中西思想分野"></a>6、中西思想分野</h3><p>熊逸先生认为，西方哲学是“爱智求真”之学，一开始并没有什么明确目的，只是单纯地满足人的好奇心和求知欲，但却由此产生了基础科学，并在世间产生了巨大的功用。</p>
<p>中国先秦思想则是“实用之学”，一开始就是为了解决实际问题而来，结果问题始终没有得到有效解决。<br>归结原因，是不是“崇本息末”的反面——“舍本求末”？</p>
<p>有一段时间，哲哲曾经热衷于研究“生涯规划”，也时常给自己设计很多计划，树立很多目标。但以老子的眼光来看，很多都是乱作为。</p>
<p>首先说说“生涯规划”。要想制定成功的“生涯规划”，人必须拥有“上帝视野”，能够清晰地看到自己这一生中的形势、变化、机缘。但是，我能看得清楚这些吗？如果看不清楚，所谓“生涯规划”岂不是一个大笑话？<br>其次谈谈人生目标。我的人生目标，比如“三千卷”、“一百景”、“千里奔”等等，当然不错，但也要根据具体情况来调整。到了不同的人生阶段，就应该有不同的重点。</p>
<p>还是那四个字——“崇本息末”。每天好好睡觉，合理运动与饮食，顺其自然，心情愉悦；根据自己的特质，爱智求真，享受乐趣；在工作中发现价值，解决问题，满足需求。此外，不要胡思乱想。</p>
<h2 id="二、对《老子》的诘难"><a href="#二、对《老子》的诘难" class="headerlink" title="二、对《老子》的诘难"></a>二、对《老子》的诘难</h2><h3 id="1、物极必反吗？"><a href="#1、物极必反吗？" class="headerlink" title="1、物极必反吗？"></a>1、物极必反吗？</h3><p>如果说万事万物发展到了极致，必定会走向自己的反面，那么，“大胖必瘦”？“巨富必贫”？“强国必弱”？以上三例，与“强者恒强”比起来，孰更有理？</p>
<h3 id="2、柔弱胜刚强吗？"><a href="#2、柔弱胜刚强吗？" class="headerlink" title="2、柔弱胜刚强吗？"></a>2、柔弱胜刚强吗？</h3><p>道家及中医，常以“舌”常在而“牙”早掉为例，论证“柔弱胜刚强”的道理。但是要知道，坚硬的牙齿之所以脱落，是因为柔弱的牙龈出现了问题。如果牙龈不出问题，牙齿的存在时间要比舌头长得多。</p>
<p>《老子》强调：“坚强者死之徒，柔弱者生之徒”。</p>
<p>对比《易经》上的：“天行健，君子以自强不息。”</p>
<p>哪个更有理？</p>
<p>至于“水滴石穿”，那也是柔弱的“水”加上了“时间”和“地球引力”的势能，以“更刚强”胜“刚强”，而非以“柔弱胜刚强”。</p>
<h3 id="3、后发制人或先发制人？"><a href="#3、后发制人或先发制人？" class="headerlink" title="3、后发制人或先发制人？"></a>3、后发制人或先发制人？</h3><p>《老子》上说：“吾有三宝”，最后一宝是“不敢为天下先”。</p>
<p>但又说：“为之于未有，治之于未乱”。</p>
<p>那么，到底是后发制人好，还是先发制人好？</p>
<p>对于主动权，是争夺还是放弃？</p>
<h3 id="4、有容乃大还是无容乃大？"><a href="#4、有容乃大还是无容乃大？" class="headerlink" title="4、有容乃大还是无容乃大？"></a>4、有容乃大还是无容乃大？</h3><p>老子盛赞“海”与“谷”，认为它们“有容乃大”。</p>
<p>但是，天比大海和山谷更大，却把雨水倾泻于下。天明明是“无容”，为什么会“更大”？</p>
<h3 id="5、谦下还是进取？"><a href="#5、谦下还是进取？" class="headerlink" title="5、谦下还是进取？"></a>5、谦下还是进取？</h3><p>很多无权无势的老百姓以《老子》中的“谦下”作为道德标准来要求自己，殊不知，《老子》这本书是写给统治者而非被统治者看的。“谦下”必须要有实力作为保障，还要以战略思考明确方向，否则，单纯的“谦下”，就是无原则的退让。</p>
<h3 id="6、“道可道”还是“道不可道”？"><a href="#6、“道可道”还是“道不可道”？" class="headerlink" title="6、“道可道”还是“道不可道”？"></a>6、“道可道”还是“道不可道”？</h3><p>如果“道可道，非常道”是真理，那么这句话本身，以及五千言的《老子》，讲的都不是真理。</p>
<h3 id="7、类比能作为思辨依据吗？"><a href="#7、类比能作为思辨依据吗？" class="headerlink" title="7、类比能作为思辨依据吗？"></a>7、类比能作为思辨依据吗？</h3><p>纵观《老子》一书，使用了大量的类比——以自然现象类比治国法则，比如“天地不仁，以万物为刍狗”，所以“圣人不仁，以百姓为刍狗”。但是，类比不能证实，更不能作为思辨依据。</p>
<p>比如马克•奥勒留在《沉思录》中，看到蚂蚁、蜜蜂、小鸟的勤劳，得出“人不应该睡懒觉”的结论。但是，如果他生活在只有树獭的国度，会不会又得出“人应该每天睡到自然醒”的结论？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尊敬一个人，但不能停止了解他。</p>
<p>面对经典，有两种态度：一是跪在思想巨人的脚下，二是站在思想巨人的肩膀上。</p>
]]></content>
      <tags>
        <tag>book</tag>
        <tag>mind</tag>
      </tags>
  </entry>
  <entry>
    <title>阿加莎•克里斯蒂自传:热爱生活</title>
    <url>/p/3adc4be.html</url>
    <content><![CDATA[<p>阿加莎•克里斯蒂,侦探小说女王的自传，这位创作了《无人生还》、《东方快车谋杀案》、《尼罗河上的惨案》等经典名作的小说家，在本书中回顾童年，回顾成长，回顾离别，回顾这五十多年的写作生涯，字里行间充满对生活的热爱和期盼。</p>
<p>童年的士绅教育让阿加莎在幼年就接触了音乐、写作、舞蹈、绘画等艺术熏陶，是当时一位典型的贵族小姐，但与其他人不同的是作者的父母对她的关爱和理解，在让作者学习文化艺术时，一直鼓励作者独立思考和勇敢探索，其中阿加莎的母亲在这方面更是影响很大，一位独立、勇敢、果断、良善的母亲是阿加莎童年最好的榜样，父亲的去世并没让阿加莎陷入困境，她依然勇敢得探索着自己的生活，无论是在一战参加护工行列，还是新婚后生活未稳定时就敢和丈夫一起去环球旅行，都可以看到阿加莎的勇气和果断。</p>
<p>作者一生创作了八十余部侦探小说，创作生涯长达五十多年，在创作过程中经历了一战和二战，经历了第一次婚姻和离婚，经历了最爱的亲人的离去，经历女儿的长大成人，又遇到了生命中相爱的那个人，这么漫长的时间里，回忆中更多描述的是她对生活的热爱和好奇心，她对于火车旅行的热爱，她对于自然的热爱，她对于国家的热爱，她对于人的喜爱，在她笔下的人们都是面目可爱的，她笔下的巴格达宛如仙境，就像她写就的关于犯罪与罪恶的推理小说一般,她似乎想要摒去一切生活中的痛苦与恶念，为人们展现美好与善良。或许这个世界变幻不断，但是持续不断寻找美好的心灵永远不会改变。</p>
<p>在垂暮之年，她依然会回忆起过去那些美好的时刻，通过本书，阿加莎为她的读者提供一种快乐，一丝希望，一点勇气，一种喜欢活着的生活态度，一种对于未知能充满向往的期盼，就像在自序中写到的那样：“我想，一个人能参与到自己毫不知情的某些事之中，正是人生最吸引人的因素之一。”那么，我们不论何时都可以期待那属于“自己毫不知情的某些事”，开始属于自己的冒险旅程！</p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>音符节拍</title>
    <url>/p/a6096f68.html</url>
    <content><![CDATA[<p>开发中遇到一个关于音符节拍的需求，整理下相关知识，扩展下音乐常识。</p>
<h2 id="1，什么叫拍？"><a href="#1，什么叫拍？" class="headerlink" title="1，什么叫拍？"></a>1，什么叫拍？</h2><p>一拍就是音乐中用来定义音的长度的单位，但是根据曲作者的要求，这个基本单位的时长也是可以变化的。比如作者规定一分钟60拍，那么一拍就是1秒。</p>
<h2 id="2，什么是音符？"><a href="#2，什么是音符？" class="headerlink" title="2，什么是音符？"></a>2，什么是音符？</h2><p>音符就是用来表示这个音的长度的符号。同一个音，怎么在谱子上表达它需要发声多长时间呢？人们就规定了一套规则来说明这个长度。这就是音符。至于四分音符，八分音符，十六分音符这些都只是个名字，你可以不用去理解。只需要明白这些翻倍的数字表示他们所代表的时长减半。</p>
<h2 id="3，-什么叫四分音符为一拍？"><a href="#3，-什么叫四分音符为一拍？" class="headerlink" title="3， 什么叫四分音符为一拍？"></a>3， 什么叫四分音符为一拍？</h2><p>那么结合什么是拍子和什么是音符，我们现在可以解释什么叫四分音符为一拍了。也就是字面意思了。在谱子上写作四分音符的这个符号，在这首曲子中演奏一拍的时长。如果一拍是一秒就演奏一秒，一拍是半秒就演奏半秒。再结合四分音符，八分音符，十六分音符依次减半的规定。那么就有了，当四分音符为一拍时，八分音符为半拍。十六分音符为四分之一拍。再乘以一拍对应的时间。就是这些音符所需要被演奏的时长，（在我之前假设的前提下）也就是1秒，半秒，四分之一秒。同理，二分音符和全音就是2秒和4秒。</p>
<h2 id="4，什么叫小节？"><a href="#4，什么叫小节？" class="headerlink" title="4，什么叫小节？"></a>4，什么叫小节？</h2><p>关于小节的概念你可以这么理解，它就像是你写一个曲子最基本的节奏循环单位。比如圆舞曲，很多都是三拍子的，所以跳起舞来可以有一哒哒，二哒哒，三哒哒，这样的感觉。这就是节奏的意思了。所以一个小节，就是规定我这个曲子是按怎么样的节奏在演奏着，是哒哒哒，哒哒哒，还是哒哒哒哒，哒哒哒哒。</p>
<h2 id="5，4-4-3-4-6-8-这样的符号是什么意思？"><a href="#5，4-4-3-4-6-8-这样的符号是什么意思？" class="headerlink" title="5，4/4, 3/4, 6/8 这样的符号是什么意思？"></a>5，4/4, 3/4, 6/8 这样的符号是什么意思？</h2><p>先强调一次，3/4这种写法和分数一点关系都没有，在这里并不意味着0.75。大家也不用尝试着把它和几分之几秒或者拍拿去比较，这样比较容易把自己搞糊涂。</p>
<p>之前我们已经懂了什么叫四分音符为一拍，什么叫小节。下面我们就把这两个概念合在一起，4/4这个符号的意思是四分音符为一拍，每小节有四拍。分母的4表明是几分音符为一拍，分子的4表明一小节有几拍。因此同理类推，3/4这个符号表示四分音符为一拍，每小节三拍，6/8这个符号表示8分音符为一拍，每小节6拍。</p>
<h2 id="6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？"><a href="#6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？" class="headerlink" title="6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？"></a>6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？</h2><p>这是作曲家自己规定的，不同的曲谱都可以不一样，比如我上面举到过的6/8拍中，就是八分音符为一拍，而不是四分音符。</p>
<h2 id="7，为什么在简谱中是四分音符对应一个阿拉伯数字？"><a href="#7，为什么在简谱中是四分音符对应一个阿拉伯数字？" class="headerlink" title="7，为什么在简谱中是四分音符对应一个阿拉伯数字？"></a>7，为什么在简谱中是四分音符对应一个阿拉伯数字？</h2><p>首先说明，这只是简谱几法自己规定的而已，以四分音符为一拍，所以四分音符才是正好是一个数字，其他的就在它的基础上在后面加横线表示时长加倍，加下划线表示时长减半。</p>
<p>以一分钟60拍，3/4拍为例，把它们全部串起来铺开来说一次就是：该曲谱规定，一拍的长度为一秒，且以四分音符为一拍，每一个小节有三拍，也就是三个四分音符的演奏长度，也就是三秒。在该前提下，八分音符为半拍，十六分音符为四分之一拍。</p>
]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>麦田里的守望者:牢笼</title>
    <url>/p/677f07e4.html</url>
    <content><![CDATA[<p>阅读难度：★★★★☆，话题深度：★★★★☆</p>
<p>key: 纯真、迷失、成年、自我、罪恶、愤怒、逃避</p>
<p>婴儿的哭啼声不一定是生命的祝福，也可能是对世界的不满。</p>
<blockquote>
<p>“你可知道那首歌吗，‘你要是在麦田里捉到了我’？我将来喜欢——”“是‘你要是 在麦因里遇到了我’！”老菲芘说。“是一首诗。罗伯特.彭斯写的。” “我知道那是罗伯特.彭斯写的一首涛。” 她说的对。那的确是“你要是在麦田里遇到了我”。可我当时并不知道。 “我还以为是‘你要是在麦田里捉到了我’呢，”我说。“不管怎样，我老是在想象， 有那么一群小孩子在一大块麦田里做游戏。几千几万个小孩子，附近没有一个人——没有一 个大人，我是说——除了我。我呢，就站在那混帐的悬崖边。我的职务是在那儿守望，要是 有哪个孩子往悬崖边奔来，我就把他捉住——我是说孩子们都在狂奔，也不知道自己是在往 哪儿跑，我得从什么地方出来，把他们捉住。我整天就干这样的事。我只想当个麦田里的守 望者。我知道这有点异想天开，可我真正喜欢干的就是这个。我知道这不象话。</p>
</blockquote>
<blockquote>
<p>一个不成熟男子的标志是他愿意为某种事业英勇地死去，一个成熟男子 的标志是他愿意为某种事业卑贱地活着</p>
</blockquote>
<blockquote>
<p>你永远找不到一个舒服、宁静的地方，因为这样的地方并不存在。</p>
</blockquote>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>2018阅览记录</title>
    <url>/p/4709c0ad.html</url>
    <content><![CDATA[<blockquote>
<p>什么是好的作品？可以经历时光的作品就是好的作品。</p>
</blockquote>
<p>2018年的学习大体分为技术、管理、人文、心理、思哲，主要的平台是图书、电影、动漫和音乐，与2017年相比，2018年的学习更成体系，一般是针对某个主题进行学习，有意识得构建知识体系，具体作品记录如下，其实技术更多是通过网络资料积累，视频和书籍阅读较少。</p>
<a id="more"></a>

<h2 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h2><p>《iOS_Core_Animation_Advanced_Techniques》</p>
<p>《深入理解计算机系统》</p>
<p>《视频技术手册(第5版)》</p>
<p>《深入理解视频编解码技术——基于H.264标准及参考模型》</p>
<h2 id="管理："><a href="#管理：" class="headerlink" title="管理："></a>管理：</h2><p>《见识：商业的本质和人生的智慧》</p>
<p>《成功，动机与目标》</p>
<p>《决策与判断》</p>
<h2 id="历史："><a href="#历史：" class="headerlink" title="历史："></a>历史：</h2><p>《唐朝穿越指南长安及各地人民生活手册》</p>
<h2 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h2><p>《给青年的十二封信》</p>
<p>《娱乐至死》</p>
<p>《一句顶一万句》</p>
<p>《引爆点》</p>
<p>《裸猿》</p>
<p>《人类动物园》</p>
<p>《亲密关系》</p>
<p>《性别之战》</p>
<p>《ARTE》</p>
<p>《芳华》</p>
<p>《女狙击手（Битва за Севастополь）》</p>
<p>《亡念之扎姆德》</p>
<p>《战锤40k》</p>
<p>《DND龙与地下城》</p>
<p>《三十而立》</p>
<p>《银河帝国》艾萨克·阿西莫夫</p>
<ul>
<li>基地</li>
<li>基地与帝国</li>
<li>第二基地</li>
<li>基地前传</li>
<li>迈向基地</li>
<li>基地边缘</li>
<li>基地与地球</li>
</ul>
<p>《和谐.伊藤计划》</p>
<p>《虐杀器官.伊藤计划》</p>
<p>《步履不停》</p>
<p>《mother》</p>
<p>《你一生的故事》</p>
<h2 id="修养"><a href="#修养" class="headerlink" title="修养"></a>修养</h2><p>《观呼吸》</p>
<p>《内观》</p>
<p>《传习录》</p>
<p>《看自己》</p>
<h2 id="原著"><a href="#原著" class="headerlink" title="原著"></a>原著</h2><p>《Harry Potter and the sorcerer’s stone》</p>
<p>《The Little Prince》</p>
<h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><p>《生化奇兵》</p>
<p>《异域镇魂曲》</p>
<p>《上古卷轴4》</p>
<p>《月圆之夜》</p>
<p>《去月球》</p>
<p>《小小噩梦》</p>
<p>《the war of mine》</p>
<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>《复仇者联盟3》</p>
<p>《最终幻想7·圣童降临》</p>
<p>《天使之卵》</p>
<p>《吸血鬼猎人D》</p>
<p>《寻梦环游记》</p>
<p>《Lady Bird》</p>
<p>《无敌破坏王2》</p>
<p>《黑暗之魂3》</p>
<p>《异邦人：无皇刃谭》</p>
<p>《超能特工队2》</p>
<p>《超能特工队1》</p>
<h2 id="Cartoon"><a href="#Cartoon" class="headerlink" title="Cartoon"></a>Cartoon</h2><p>《恶魔人crybaby》</p>
<p>《怪 〜AYAKASHI》</p>
<p>《怪化猫》</p>
<h2 id="空之境界"><a href="#空之境界" class="headerlink" title="空之境界"></a>空之境界</h2><p>《俯瞰风景》<br>《杀人考察上》<br>《痛觉残留》<br>《迦蓝之洞》<br>《矛盾螺旋》<br>《忘却录音》<br>《杀人考察下》<br>《终章》<br>《未来福音上下》<br>《魔法使的新娘》</p>
<p>《鸟之歌》</p>
<p>《末日时在做什么？有没有空？可以来拯救吗？》</p>
<p>《大唐双龙传》</p>
<p>《凉宫春日的忧郁》</p>
<p>《重启咲良田》</p>
<p>《辉夜大小姐想让我告白 <del>天才们的恋爱头脑战</del>》</p>
<p>《宝石之国》</p>
<p>《戏精宿舍》</p>
<p>《声之形》</p>
<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>鬼束千寻</p>
<p>尼尔系列</p>
<p>王菲</p>
<p>窦唯</p>
<p>牛尾憲輔</p>
<p>梶浦由记</p>
<p>Blowin’in the wind of Bob Dylan</p>
<p>盛夏的果实 of 莫文蔚</p>
<p>Cecile Corbel的空灵</p>
]]></content>
      <categories>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS高度自适应的TextView</title>
    <url>/p/c3a525c9.html</url>
    <content><![CDATA[<h1 id="如何实现UITextView文本框高度随文字行数自动增减呢？"><a href="#如何实现UITextView文本框高度随文字行数自动增减呢？" class="headerlink" title="如何实现UITextView文本框高度随文字行数自动增减呢？"></a>如何实现UITextView文本框高度随文字行数自动增减呢？</h1><h2 id="思路1、UITextView的Delegate方法"><a href="#思路1、UITextView的Delegate方法" class="headerlink" title="思路1、UITextView的Delegate方法"></a>思路1、UITextView的Delegate方法</h2><p><code>-textViewDidChange:</code></p>
<p>在Text变化时计算文字高度，刷新TextView高度</p>
<p>问题：Text变化与实际有出入，此时的问题变化还没有存储到TextView的Text中，现在进行计算会得到上一个状态下的文字高度，导致TextView高度刷新延迟，换行第二个文字才增加高度，如果采用这个方法，就要进行文字拼接，再计算文字高度。</p>
<h2 id="思路2、TextView本质是一个ScrollView"><a href="#思路2、TextView本质是一个ScrollView" class="headerlink" title="思路2、TextView本质是一个ScrollView"></a>思路2、TextView本质是一个ScrollView</h2><p>文字高度超出TextView高度会自动增加contentSize属性的height，而且增加的高度刚好就是TextView需要改变的高度</p>
<a id="more"></a>
<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>设置默认UITextView的contentSize高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static float TextViewContentSizeDefaultHeight &#x3D; xxx;</span><br></pre></td></tr></table></figure>

<p>KVO监听TextViewInput的contentSize变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;  </span><br><span class="line">[self.TextViewInput addObserver:self forKeyPath:@&quot;contentSize&quot; options:options context:nil];  </span><br><span class="line">[self addSubview:self.TextViewInput];</span><br></pre></td></tr></table></figure>

<p>变化处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if (![object isKindOfClass:[BRPlaceholderTextView class]]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;contentSize&quot;])&#123;</span><br><span class="line">        DLog(@&quot;%@&quot;,change);</span><br><span class="line">        static BOOL hasInit;</span><br><span class="line">        if (!hasInit) &#123;</span><br><span class="line">            hasInit &#x3D; YES;</span><br><span class="line">            return;  </span><br><span class="line">        &#125;</span><br><span class="line">        CGFloat changeHeight &#x3D; self.TextViewInput.contentSize.height - UUInputTextViewDefaultContentHeight;</span><br><span class="line">        if (changeHeight &gt; UUInputTextViewMaxHeight - UUInputTextViewDefaultContentHeight) &#123;</span><br><span class="line">            changeHeight &#x3D; UUInputTextViewMaxHeight - UUInputTextViewDefaultContentHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        [self mdf_changeLayoutByChangeContentHeight:changeHeight];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意要注销KVO</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">    [self.TextViewInput removeObserver:self forKeyPath:@&quot;contentSize&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>围城：爱熄灭了灯，心围一座城</title>
    <url>/p/c0f50cbc.html</url>
    <content><![CDATA[<p>什么是爱情？什么是婚姻？</p>
<p>《围城》 一直听说但确没读过，这次碰巧翻阅，发现文笔清淡有趣，完全没有想象中的沉重，对男女情爱、婚姻的描写真是精妙，在这里做下部分文摘。</p>
<a id="more"></a>

<h2 id="文摘"><a href="#文摘" class="headerlink" title="文摘"></a>文摘</h2><blockquote>
<p>忠厚老实人的恶毒，像饭里的砂砾或者出骨鱼片里未净的刺，会给人一种不期待的伤痛。</p>
</blockquote>
<blockquote>
<p>“你嘴凑上来，我对你嘴说，这话就一直钻到你心里，省得走远路，拐了弯从耳朵里进去。”</p>
</blockquote>
<blockquote>
<p>方鸿渐看着发呆，觉得也陪淑英双双死了，萧条黯淡，不胜身后魂归之感。</p>
</blockquote>
<blockquote>
<p>鸿渐偷看苏小姐的脸，光洁得像月光泼上去就会滑下来，眼睛里也闪活着月亮，嘴唇上月华洗不淡的红色变为滋润的深暗。</p>
</blockquote>
<blockquote>
<p>“我要坐远一点——你太美了！这月亮会作弄我干傻事。”</p>
</blockquote>
<blockquote>
<p>觉得剩余的今夜只像海水浴的跳板，自己站在板的极端，会一跳冲进明天的快乐里，又兴奋，又战栗。</p>
</blockquote>
<blockquote>
<p>我爱的人，我要能够占领他整个生命，他在碰见我以前，没有过去，留着空白等待我——”</p>
</blockquote>
<blockquote>
<p>可是心里忘不了他，好比牙齿钳去了，齿腔空着作痛，更好比花盆里种的小树，要连根拔它，这花盆就得迸碎。</p>
</blockquote>
<blockquote>
<p>同乡一位庸医是他邻居，仰慕他的名望，杀人有暇，偶来陪他闲谈。这位庸医在本乡真的是“三世行医，一方尽知”，总算那一方人抵抗力强，没给他祖父父亲医绝了种，把四方剩了三方。</p>
</blockquote>
<blockquote>
<p>从前愚民政策是不许人民受教育，现代愚民政策是只许人民受某一种教育。不受教育的人，因为不识字，上人的当，受教育的人，因为识了字，上印刷品的当，</p>
</blockquote>
<blockquote>
<p>鸿渐只有感佩，想女人这怪东西，要体贴起人来，真是无微不至，汗毛孔的折叠里都给她温存到。</p>
</blockquote>
<blockquote>
<p>高松年发奋办公，亲兼教务长，精明得真是睡觉还睁着眼睛，戴着眼镜，做梦都不含糊的。</p>
</blockquote>
<blockquote>
<p>一片无话可说的空白时间，像白漫漫一片水，直向开足马达的汽车迎上来，望着发急而又无处躲避。</p>
</blockquote>
<blockquote>
<p>有时候一个人，并不想说谎话，说话以后，环境转变，他也不得不改变原来的意向。</p>
</blockquote>
<blockquote>
<p>刘小姐把她拉进去了，自信没给客人瞧见脸色。以后的谈话，只像用人工呼吸来救淹死的人，挽回不来生气。</p>
</blockquote>
<blockquote>
<p>他嘴快把这些话告诉她，她不作声。他和她讲话，她回答的都是些“唔”，“哦”。他问她为什么不高兴，她说并未不高兴。他说：“你瞒不过我。”她说：“你知道就好了。我要回宿舍了。”鸿渐道：“不成，你非讲明白了不许走。”她说：“我偏要走。”鸿渐一路上哄她，求她，她才说：“你希望的好葡萄在后面呢，我们是坏葡萄，别倒了你的胃口。”</p>
</blockquote>
<blockquote>
<p>否则，他讲她的语气，不会那样幽默。他对她也许不过像自己对柔嘉，可见结婚无需太伟大的爱情，彼此不讨厌已经够结婚资本了。<br>柔嘉回过脸来，幽远地说：“你真是爱我，不用我说，就会知道。唉！这是勉强不来的。要等我说了，你才体贴到，那就算了！一个陌生人跟我一路同来，</p>
</blockquote>
<blockquote>
<p>现在想想结婚以前把恋爱看得那样郑重，真是幼稚。老实说，不管你跟谁结婚，结婚以后，你总发现你娶的不是原来的人，换了另外一个。早知道这样，结婚以前那种追求、恋爱等等，全可以省掉。</p>
</blockquote>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://movie.douban.com/subject/1291818/" target="_blank" rel="noopener">饮食男女</a></p>
<p><a href="https://book.douban.com/subject/1079252/" target="_blank" rel="noopener">爱情笔记</a></p>
]]></content>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Apple 开发账号续费支付失败处理：未能认证证件</title>
    <url>/p/c03bda42.html</url>
    <content><![CDATA[<p>2020 Apple 开发账号续费支付失败处理，错误提示是：未能认证证件；</p>
<p>在这里记录下问题、分析和解决方法；</p>
<a id="more"></a>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>1、你使用的信用卡必须是支持双币结算的。即visa标记+银联或者是mastercard+银联，这样的卡才可以进行双币结算</p>
<p>2、续费时的账单地址、姓名必须和持卡人一致</p>
<p>3、账单信息中的姓名即是信用卡左下角的钢印大写中文拼音！不能修改为其他人。</p>
<p>4、账单信息中的邮箱一定不要用qq或者163邮箱，请使用企业邮箱！如果你只有QQ或者是163的邮箱，你去申请一个别的邮箱。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>分析1：</p>
<p>如果不支持双币结算，那账号会不法支付，直接失败</p>
<p>分析2：</p>
<p>账单地址、姓名必须和持卡人一致，国内银行安全校验</p>
<p>分析3：</p>
<p>账单姓名信息要和信用卡信息一致，国内银行安全校验</p>
<p>分析4：</p>
<p>尽量用企业邮箱，外汇管制，个人邮箱失败概率很大，用本公司的企业邮箱基本一次通过</p>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>大国政治的悲剧:中美关系</title>
    <url>/p/d38aabac.html</url>
    <content><![CDATA[<p>其实，不是中国能否和平崛起的问题，而是西方（主要是美国）能否接受中国和平崛起的问题，或西方基督教世界能否接受世俗文明崛起的问题。</p>
<p>国际体系的三个特征一并导致了国家间的相互提防：</p>
<ol>
<li>缺乏一个凌驾于国家之上并能保护彼此不受侵犯的中央权威；</li>
<li>国家总是具有用来进攻的军事能力；</li>
<li>国家永远无法得知其他国家的意图。有了这一担心——不可能完全一劳永逸地消除<a id="more"></a>

</li>
</ol>
<p>克林顿政府的外交政策内涵大体上可以用国际关系的三个主要自由主义理论来解读：</p>
<p>（1）经济上相互依赖的繁荣国家彼此不可能发动战争的“经济相互依赖和平论”；<br>（2）民主国家彼此不打仗的“民主和平论”；<br>（3）国际制度能使国家避免战争并集中建立合作关系的“国际制度和平论”。</p>
<p>聪明的观察者应该清楚地注意到，美国是说一套，做一套。</p>
<p>自由主义对国际政治的乐观之见建立在三个核心信念之上，这些信念是该理论所有流派耳熟能详的共识。第一，自由主义者把国家看成国际政治中的主要行为体。第二，他们强调，国家的内部属性存在很多变数，其差异对国家的行为产生深刻的影响。</p>
<p>第一，“经济相互依赖和平论”指出，国家间经济的高度相互依存使它们不可能彼此发动战争.<br>第二，“民主和平论”声称，民主国家不会对其他民主国家发动战争.<br>第三，“国际制度和平论”强调，国际制度提升国家间的合作前景，并能极其有效地减少战争的可能性. </p>
<p>第一，和自由主义者一样，现实主义者也把国家看成世界政治中的主要行为体。<br>但现实主义者重视大国，因为这些国家主宰和塑造着国际政治，同时也引发致命的战争。<br>第二，现实主义者认为，大国行为主要受其外部环境而不是内部属性的影响<br>第三，现实主义者认为，对权力的追求支配国家的思维，国家为权力而竞争.  </p>
<p>第一个命题是，国际体系处于无政府状态。这并不意味它四处充满混乱和无序。</p>
<p>现实主义关于无政府状态的概念与冲突毫无关系；这一概念说明的只是一种序列状态原则，即国际体系由众多独立国家组成，但并不存在任何凌驾于这些独立国家之上的中央权威机构。4换句话说，这些国家的主权是与生俱来的，因为国际体系中没有更高的统治机构。5政府之上不再有政府。</p>
<p>第二个命题是，大国本身具备某些用于进攻的军事力量，为其彼此伤害甚至摧毁提供必要的资本。虽然有些国家比其他国家更具军事实力，并因此更加危险，但国家本身就是彼此潜在的危险。</p>
<p>第三个命题是，国家永远无法把握其他国家的意图。尤其是，任何国家都不能肯定另一个国家不会以进攻性军事力量攻击它</p>
<p>第四个命题是，生存是大国的首要目标。具体而言，国家力图维护自己的领土完整和国内政治秩序的自治。</p>
<p>第五个命题是，大国是理性的行为体。它们清楚自己的外部环境，并从战略高度考虑如何从中求得生存</p>
<h2 id="权力本身并非总能反映财富的梯级"><a href="#权力本身并非总能反映财富的梯级" class="headerlink" title="权力本身并非总能反映财富的梯级"></a>权力本身并非总能反映财富的梯级</h2><p>第一，国家把其财富的不同部分转化为军事实力；<br>第二，财富转化为军事实力的效率因情况不同而各异，有时对均势产生重要的影响；<br>第三，大国组建各式各样的军事力量，而且那些选择也关系到对军事平衡的估价。</p>
<p>（1）成为全球唯一的地区霸主；<br>（2）尽可能多地控制世界财富；<br>（3）支配它们所在地区的地面力量均势；<br>（4）拥有核优势。</p>
<h2 id="两极是不同结构中最稳定的"><a href="#两极是不同结构中最稳定的" class="headerlink" title="两极是不同结构中最稳定的"></a>两极是不同结构中最稳定的</h2><p>第一，两极体系中冲突的机会相对更少，只有一种涉及大国的可能的冲突组合。当大国在两极体系中作战时，它们可能将小国拖进战争，而非大国对手。<br>第二，在两极体系中权力更可能在大国间公平分配，这是一个重要的稳定性的结构因素。而且，并没有多少机会让大国联合起来反对其他国家或利用小国。<br>第三，两极中误算的可能性不大，这减少了大国遭遇冲突的可能性。<br>第四，在世界政治中尽管害怕总是在起作用，但两极体系不会夸大萦绕在国家间的忧虑。</p>
<p>我的观点是，中国经济如果继续增长，就会像美国支配西半球一样支配亚洲。美国却要全力以赴阻止中国取得地区霸权。而中国的大部分邻国包括印度、日本、新加坡、韩国、俄罗斯和越南会联合美国遏制中国权力。结果将是激烈的安全竞争，战争颇有可能。说简单些，中国崛起之路大概并不平坦。</p>
<p>两国一定会竞相对有重要国家安全意义的商品和服务采取选择性出口控制。对于美国来说，可能的范例是巴黎统筹委员会（Coordinating Committee for Export Control，简写为CoCom），美国冷战期间成立这个组织就是要限制敏感技术传入苏联。</p>
<p>美国的发展史充满扩张与征服，这是生存的必由之路，中国崛起也会如此。</p>
<p><strong>在一个无序的世界中，所有国家都需要自保，因此，军事实力是最可靠的安全保障；我们不能确信他国的动机；所有国家的终极目标都是生存；所有国家都想最大限度地确保自己的安全；</strong></p>
]]></content>
      <tags>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title>瘟疫与人:共生</title>
    <url>/p/fe5a12af.html</url>
    <content><![CDATA[<p>人类与寄生物的生存在历史中不断出现，流行性病毒感染并不是现在社会出现的问题，它们一直都在，在罗马衰亡的背后，在蒙古征战的路上，在冒险者踏上美洲的船舶中，它们一直都在。</p>
<a id="more"></a>

<h2 id="现在社会中的瘟疫"><a href="#现在社会中的瘟疫" class="headerlink" title="现在社会中的瘟疫"></a>现在社会中的瘟疫</h2><p>新生活方式，让人们对流感有更多的防疫手段，过去致命的流感现在更多变成儿童病与文明社会疾病的模式的出现。</p>
<h2 id="人口密度与疾病爆发"><a href="#人口密度与疾病爆发" class="headerlink" title="人口密度与疾病爆发"></a>人口密度与疾病爆发</h2><p>通过观察过去大陆区域间疾病的传播，人口密度对疾病暴发有明显的约束，疾病暴发对欧陆政治体系的影响，暴发时对人口的平衡</p>
<h2 id="大陆间的疾病传染"><a href="#大陆间的疾病传染" class="headerlink" title="大陆间的疾病传染"></a>大陆间的疾病传染</h2><p>蒙古人横穿欧亚大陆。</p>
<p>人际运输以及货物运输能力对疾病传染的影响。</p>
<p>瘟疫，鼠疫等疾病的发作可能是多次的复发的周期性的。 </p>
<h2 id="跨越大洋的交流。"><a href="#跨越大洋的交流。" class="headerlink" title="跨越大洋的交流。"></a>跨越大洋的交流。</h2><p>新大陆遭遇性疾病是没有抵抗能力的。</p>
<p>印第安人的大量灭亡。</p>
<p>非洲黑奴的大量死亡。</p>
<h2 id="近代医学实践的影响"><a href="#近代医学实践的影响" class="headerlink" title="近代医学实践的影响"></a>近代医学实践的影响</h2><ul>
<li>疫苗接种计划</li>
<li>卫生系统改善</li>
<li>供水体系卫生条件提高</li>
<li>城市排泄物处理系统</li>
<li>有组织的灭蚊处暑除虫</li>
<li>消毒技术抗生素的使用</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>西西弗神话:藐视现实</title>
    <url>/p/fd024de.html</url>
    <content><![CDATA[<p>key：哲学、生活、荒诞、抗争、幸福</p>
<blockquote>
<p>真正严肃的哲学问题只有一个，那便是自杀。判断人生值不值得活，等于回答哲学的根本问题。</p>
</blockquote>
<p>荒谬：当人对世界的理性和幸福的热望，却碰到了这个非人的毫无意义杂乱无章的世界，荒谬就产生了。”人性总在呼唤着，而世界却总在不合理地静默着”。</p>
<a id="more"></a>

<h2 id="荒诞自由"><a href="#荒诞自由" class="headerlink" title="荒诞自由"></a>荒诞自由</h2><p>追求</p>
<blockquote>
<p>对于两个寿命相等的人，世界始终提供相同数量的经验。我们必须对此有所意识。感觉到自己的生活，自己的反抗，自己的自由，感觉越多越好，这就是生活，生活得越充实越好。</p>
</blockquote>
<blockquote>
<p>对于两个寿命相等的人，世界始终提供相同数量的经验。我们必须对此有所意识。感觉到自己的生活，自己的反抗，自己的自由，感觉越多越好，这就是生活，生活得越充实越好。</p>
</blockquote>
<h2 id="荒诞人"><a href="#荒诞人" class="headerlink" title="荒诞人"></a>荒诞人</h2><p>本源</p>
<blockquote>
<p>时间养活时间，生活服务生活 </p>
</blockquote>
<p>哪些更重要？</p>
<blockquote>
<p>靠希望生活的世人与世格格不入，在这个世上，善良让位于慷慨，柔情让位于雄性的沉默，亲和让位于孤胆的英勇。</p>
</blockquote>
<p>谁不是自私？</p>
<blockquote>
<p>有些人，生而为活；有些人，生而为爱。</p>
</blockquote>
<p>罪</p>
<blockquote>
<p>假如他不把世人放在眼里，他就是世人最凶恶的敌人。</p>
</blockquote>
<h2 id="戏剧"><a href="#戏剧" class="headerlink" title="戏剧"></a>戏剧</h2><p>虚假而短暂的生命</p>
<blockquote>
<p>在短短的时间里，演员使上述人物在五十平方公尺的舞台上诞生和死亡。荒诞从来没有表现得如此充分，如此长久。</p>
</blockquote>
<p>活着，以洋溢不断的活力</p>
<blockquote>
<p>重要的不是永恒的生命，而是永远的活力。</p>
</blockquote>
<h2 id="征服"><a href="#征服" class="headerlink" title="征服"></a>征服</h2><p>选择</p>
<blockquote>
<p>总会有一个时刻，必须在静观和行动之间作出抉择，所谓造就一个人成为一个男子汉。</p>
</blockquote>
<p>现实的局限和思想的自由</p>
<blockquote>
<p>个体什么也做不成，却什么都可以做。在这种奇妙的预备役期间，你们明白我为什么既激励个体又贬压个体。其实，是世界将其贬压，是我将其解放。我把个体的全部权利都给个体了。</p>
</blockquote>
<blockquote>
<p>人是他自身的目的，而且是唯一的目的。</p>
</blockquote>
<h2 id="抗争"><a href="#抗争" class="headerlink" title="抗争"></a>抗争</h2><blockquote>
<p>确实他们是无国之王。但他们比有国之君具有优势，因为他们知道各种各样的王国都是虚幻的。他们知道自身的全部伟大就在于此；一提起他们，就说隐藏的不幸，或幻灭的灰烬，那是徒劳无益的。被剥夺希望，并不就是绝望。人间的火焰完全抵得上天国的芳香。这里，我不能、谁也不能审判他们。其实他们并不力图成为优秀者，而试图成为征服者</p>
</blockquote>
<h2 id="荒诞创作"><a href="#荒诞创作" class="headerlink" title="荒诞创作"></a>荒诞创作</h2><blockquote>
<p>伟大的小说家是哲学小说家，就是说主题小说家的对立面。诸如巴尔扎克、萨德、麦尔维尔、司汤达、陀思妥耶夫斯基、普鲁斯特、马尔罗、卡夫卡，只举这么几个吧，他们就是如此。</p>
</blockquote>
<p>创作者要克服解释的冲动</p>
<blockquote>
<p>解释的诱惑最为强烈的创作中，作者能够克服这种诱惑吗？</p>
</blockquote>
<h3 id="基里洛夫"><a href="#基里洛夫" class="headerlink" title="基里洛夫"></a>基里洛夫</h3><blockquote>
<p>我将自杀，以证明我的违抗，确认我新的、了不起的自由。”</p>
</blockquote>
<blockquote>
<p>使一场难以形容的精神冒险在血泊中告终之前，基里洛夫说了一句话，古老得像世人的痛苦：“一切皆善。”</p>
</blockquote>
<blockquote>
<p>存在是虚幻的，又是永恒的。</p>
</blockquote>
<h3 id="没有前途的创作"><a href="#没有前途的创作" class="headerlink" title="没有前途的创作"></a>没有前途的创作</h3><p>独立的作品是破碎的，而所有的创作连贯起来却是有意义的，是否人生也是如此？某些时刻、经历是痛苦难堪，但以整个生命历程来看，生命总是有意义？  </p>
<blockquote>
<p>没准儿一系列作品，可能只是同一种思想的一系列近似。但是可以设想另一类创作家，他们可能用的是并列法。他们的作品好像互相间没有联系，在一定程度上还是相矛盾的。但，他们的作品一旦被重新放回其整体，就恢复了原来的次序，就这样从死亡获得了最终的意义，就接受了作者生命最亮眼的部分。</p>
</blockquote>
<p>作品因为人而伟大</p>
<blockquote>
<p>也许伟大的作品本身并不那么重要，更重要的在于要求人经得起考验，在于给人提供机会去战胜自己的幽灵和更接近一点赤裸裸的现实。</p>
</blockquote>
<h2 id="西西弗神话"><a href="#西西弗神话" class="headerlink" title="西西弗神话"></a>西西弗神话</h2><p>现代人的自由在哪里？在这个没有恶龙，没有邪恶，没有折磨的世界里，日常已经变成苦难？可笑！</p>
<blockquote>
<p>当今的工人一辈子天天做同样的活计，其命运不失为荒诞。但他只有在意识到荒诞的极少时刻，命运才是悲壮的。</p>
</blockquote>
<p><strong>我让西西弗留在山下，让世人永远看得见他的负荷！然而西西弗却以否认诸神和推举岩石这一至高无上的忠诚来诲人警世。他也判定一切皆善。他觉得这个从此没有救世主的世界既非不毛之地，抑非渺不足道。那岩石的每个细粒，那黑暗笼罩的大山每道矿物的光芒，都成了他一人世界的组成部分。攀登山顶的拼搏本身足以充实一颗人心。应当想像西西弗是幸福的。</strong></p>
]]></content>
      <tags>
        <tag>哲思</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐的美学本质</title>
    <url>/p/bb5034f.html</url>
    <content><![CDATA[<h2 id="音乐的美学本质"><a href="#音乐的美学本质" class="headerlink" title="音乐的美学本质"></a>音乐的美学本质</h2><p>音乐怎么听？</p>
<p>艺术怎么懂？</p>
<p>视觉、文学、听觉，三大艺术，关键在于感知和共鸣，而不是能够用文字和数理去解释它。</p>
<p><strong>音乐何需懂！</strong></p>
<a id="more"></a>

<h2 id="音乐可以懂—让人浮想联翩—联觉"><a href="#音乐可以懂—让人浮想联翩—联觉" class="headerlink" title="音乐可以懂—让人浮想联翩—联觉"></a>音乐可以懂—让人浮想联翩—联觉</h2><p>温度、味觉、嗅觉</p>
<p>音乐—联觉</p>
<p>东坡肉不需要理解，吃就行</p>
<p>欣赏音乐只需要本能</p>
<p>音乐可以不需要理解</p>
<p>音乐理解没有标准答案</p>
<p>联觉对应是触发感知的关键</p>
<h2 id="为什么我们需要艺术"><a href="#为什么我们需要艺术" class="headerlink" title="为什么我们需要艺术"></a>为什么我们需要艺术</h2><p>音体美</p>
<p>理性和感性培养</p>
<p>听觉培养</p>
<p>热爱某种乐器—音乐-生活-幸福</p>
<p>艺术教育与成功</p>
<p>感性质量</p>
<p>审美心智</p>
<p>适宜提升多样</p>
<p>音乐鉴赏</p>
]]></content>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
</search>
