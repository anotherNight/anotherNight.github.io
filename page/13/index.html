<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jundongwu.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录思考的地方">
<meta property="og:type" content="website">
<meta property="og:title" content="俊东的Blog">
<meta property="og:url" content="https://jundongwu.com/page/13/index.html">
<meta property="og:site_name" content="俊东的Blog">
<meta property="og:description" content="记录思考的地方">
<meta property="og:locale" content="cn">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jundongwu.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>俊东的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">俊东的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">少则得，多则惑</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/67d90507.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/67d90507.html" class="post-title-link" itemprop="url">中国人心里的苦 -《一句话顶一万句》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-07 18:16:15" itemprop="dateCreated datePublished" datetime="2018-12-07T18:16:15+08:00">2018-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：<a href="https://book.douban.com/review/5584795/" target="_blank" rel="noopener">https://book.douban.com/review/5584795/</a></p>
<p>作者：southstarj</p>
<p>刘震云53岁了，在公共场合里总是穿着一件对襟的黑色夹袄，说是妈妈亲手做的，这让他看起来很像个乡下来的手艺人。刘震云写小说已经写了30多年，故乡延津的老乡们不觉得当作家是个多荣耀的事儿，就是个靠编瞎话为生的说书人。所以他也不觉得写作是件多么高尚的事情，他最讨厌的就是所谓的知识分子那种俯瞰苍生的态度，他觉得与其跟这些人在一起凑个饭局，说些言不由衷的大话，到不如跟村里的舅舅，表哥们聊天更有意思，更有收益。他经常回自己的老家老庄村。老家的父老乡亲，那些卖豆腐、剃头、杀猪、贩驴的，他能跟他们说到一起。他们说的话更接近生活的本质，更知心，“一句顶一万句”。</p>
<p>刘震云的外祖母生前给刘震云讲了一个故事，“她有一个叔叔，一辈子没娶上老婆，跟家里的一头牛成了好朋友。有一天这头牛死了，叔叔三天没有说话。第四天凌晨，他离家出走了。后来，四乡八镇都找了，所有的井也打捞了，不见叔叔的身影。”这个故事让刘震云很震惊，是什么原因让一个这样的一个普通的养牛人离开自己的故乡和亲人，要去到领一个陌生的地方？因为一头牛的死掉，自己熟悉的地方已经变得陌生，所以只能去一个更陌生的地方去寻找一种新的生活。在刘震云开来，这就是精神上却都在“高级”流浪和漂泊。不要说精神的痛苦只有知识分子才有。</p>
<p>怀着这样的一个想法，刘震云用了三年时间，写下了新的长篇小说《一句顶一万句》，书中的话是两个主人公，这两个主人公，一个叫杨百顺，一个叫牛爱国，他们是在心里杀过人的“杀人犯”，一个人特别想找到另一个人。找他的目的非常简单，就是想告诉他一句知心的话。</p>
<p>“一个人的孤独不是孤独，一个人找另一个人，一句话找另一句话，才是真正的孤独。”小说中塑造了很多世间的百姓，卖豆腐的，剃头的，杀猪的，贩驴的，染布的，开饭铺的，还有提刀上路杀人的……每个人都在寻找一个可以说上知心话的朋友，一个人找另外一个知心朋友不容易，你可能跟这个人是好朋友，但是你们在一块的话未必能说得上话，其实比人找人不容易的是话找话，《一句顶一万句》反映了一种中国式的孤独和友情观。</p>
<p>“《论语》的第一句话就是：有朋自远方来，不亦乐乎？《一句顶一万句》的孤独就是对这句话的注解。”文学评论家李敬泽说，“不同于西方文学作品中人与世界的对抗产生的孤独不同，杨百顺他们的孤独又是另外一种孤独，杨百顺的问题是他总觉得这个世界上应该有那么一句话，应该有那么一个道理，他说不出来，他等着到茫茫人海中去找希望有个人能够说出来，能够找到，但是他找不到。他的孤独是他手里没攥着那么一个他自己绝对信的那么一句话。他想找那么一句话，这种不确定性，构成了一种更大的孤独。”</p>
<p>什么才是朋友?《一句顶一万句》里朋友的关系充满了不确定性，因为一句话，一件小事，知心的人可以瞬间一刀两断，就像刘震云说说：“朋友的关系是危险的。”生活的细节决定了生活的偶然，在刘震云看来,正是细节中的人和事，才构成了小说中所有命运的跌宕转折，因为中国人永远都是活在细节里的，而细节会变的，细节变了，生活变了，朋友也就变了，于是小说中的人物，不得不接受这种命运的变化，去另外一个更陌生的地方寻找新的生活。</p>
<p>“寻找”是《一句顶一万句》的母体，写作对于刘震云来讲也是一个寻找知心朋友的过程。他说不是自己创作了这些人物，是这些人物跟他出来谈话。他在《一地鸡毛》中找到了小林，在《手机》中找到了严守一，在《我叫刘跃进》中找到了刘跃进，这次在《一句顶一万句》中找到了杨百顺和牛爱国，还有传教的老詹，杀猪的老曾，剃头的老裴……。就是这些小人物，却都是刘震云真正可以说知心话的朋友。“与书中人物结伴而行，晓行夜宿，披肝沥胆，说的都是知心话”，他找的人越来越深，与这些人谈的话题也越来越深，《一句顶一万句》谈到了杀人，绿帽子，和孤独的事，这些话是凶险的，只能跟知心的人说，与杨百顺和牛爱国说这些话，刘震云也会被自己突然写出来的句子吓一跳，“知心话绝对不是滔滔不绝的，所以书里的句子很短，句号很多，没有形容词，朋友在一起谈知心话的时候那些形容和比喻是没用的。朋友在一起说的都是朴素的话，真实的话，和知心的话，这三种话是有力量的，所以我觉得我自己写的比原来好。”</p>
<p>有了这样的写作，刘振云就不再孤独。他说摆脱孤独是他写作的动机原因和目的，在书里交了朋友就也不孤单。在他不写做的时候反倒累了，总是感觉没着没落，“不知道自己从哪里来到哪里去我是谁了”，“写作的每一天都很愉快，不写作的间隙却很沮丧，就像喝酒一样，有酒喝喝醉的时候很愉快，第二天醒了就很难过”，所以刘震云说自己的最佳状态，就是像李白一样“但愿长醉不愿醒”，但他是要醉在写作里的。</p>
<p>“我肯定是个好作者，因为我写作不累”。刘振云说，“写作这个不是祖传的，我外祖父的爹曾经开创过一个村庄，叫老庄村。他逃荒逃到一片盐碱地，就靠熬盐、熬碱为生。我觉得他是个智慧的人，一个新创的村庄叫老庄，显得深，因为新，确实也有点虚张声势和作贼心虚的感觉，出门就吆喝，老庄的盐来了，老庄的碱来了，人家说老哥，怎么没听说过这个村啊？他说“有点远！”远来的和尚会念经，于是老庄的盐碱也就形成了品牌，周围村庄吃的都是老刘家的碱和盐。”</p>
<p>“我外祖父的爹真是个聪明人，这聪明背后，是河南人面对生活的态度。经常有人说我是幽默的，这个幽默不是话语的幽默，真正上升到文学的层面，话语的幽默会让人讨厌的，我的幽默是事情本身的幽默，也不是事情本身幽默，是事后边的这里理很拧把，明明看着不行的事情，大家都要去做，不做到成了不对的，这就变成了幽默。我们面对艰辛和苦难的时候，幽默会把铁像冰一样融化掉，如果说祖传，我的幽默的出产地也是我外祖父的爹开创的那个老庄村的盐碱地里，这个地点是祖传的。在苦难的地方长出幽默的大树，会更幽默。”刘震云说。</p>
<p>读这本书本打算放松一下，可读的过程中，心里越来越抓挠，苦涩得很。</p>
<p>书里的故事很简单，就像邻居的大爷和你闲扯，讲讲村里其他人的事情似的。可一页页翻下去，故事又不简单，刘震云说到的这些人：卖豆腐的、贩驴的、杀猪的、剃头的……这些似乎毫不相干的人的命运，却莫名其妙地交织在一起。无论是几十年前的爷爷辈儿，还是80年代的新中国，人们的生活变了，可人的内心却没有变。写到最后，这些人之间的关系，无非是分成“说得上话”和“说不上话”两种。书里的每一个人，都为了和别人“说不上话”苦了一辈子。</p>
<p>读这本书之前，本来以为这种苦只有我们这一代年轻人才有。大学寝室里，四个人各自开着电脑做着各自的事情，一晚上互相之间一句话不说，这似乎已经成为常态；曾经一起吃饭聊天吹牛逼的高中同学，进了大学就没怎么再说过话；也同样因为说不上话，身边的一对对分分合合……看了小说才知道，原来从两千年前中国人就都因为这个原因心里苦着。这种苦不是别的，就是孤独。</p>
<p>中国人喜欢热闹，是因为一大帮人闹哄哄的时候可以暂时忘了孤独，可当又不得不自己一个人的时候，又要觉得孤独了。书里面牛爱国陷入困境的时候曾经琢磨过：这世上的人有千千万，可能去投奔的却只有两三个。平日里和老婆说不上话，已经觉得孤独了，遇到走投无路的情况，就更加觉得孤苦无依，只好去千里之外找曾经“说的上话”的战友。可有的时候，离家已经千里之外，却还是“心里乱”，只好走得更远。孔子两千年前就曰过：“有朋自远方来，不亦乐乎？”，我们都以为是老朋友从大老远的地方赶来，心里很开心。可书里老汪说得好：你们都不明白孔老夫子的心思。从远方来的这个人，是不是朋友还两说着呢，反倒是因为和自己没什么关系，才能放心地把心里话说给他听。心里话说了，就舒坦了。</p>
<p>我们又何尝不是这样呢，和熟人说话，有些心里话得掂量着说；但和网上的陌生人聊天，反正谁也不认识谁，反倒是什么心里话都讲了。校内网出来了，微博实名制了，又把熟人圈子强行拉到了网上，于是大家说话，又开始掂量了。可话憋着总是难受，于是大家就发些不疼不痒的自拍和水贴，脑子费在了这些琐碎事上，也就暂时忘却了孤独感。这和喜欢热闹没什么本质区别，晚上躺在床上，汹涌的孤独感还是压得人喘不过气来。又有人发明了“微信”，晚上睡觉也能“摇”。可难免有人无法接受这种欺骗自己的做法，要么让自己不停忙碌从而忘记，否则只好独自承受。</p>
<p>可这心里的苦究竟是为了什么，书里没有给出明确的回答，但是我们也许可以从老詹的身上看到些什么。老詹是在延津传了一辈子天主教的意大利人，举手投足已经和中国的老头没什么区别。他这一辈子只在延津发展了八个教徒，但是他却从来没有放弃过传教。或许那八个教徒都不够虔诚，但是老詹绝对是从心底信了主。临死的时候也把自己设计的教堂草图放在身边。即便全延津的人，带上新乡天主教会的人都不待见他，但他仍然相信他能和主说上话。</p>
<p>中国人没有信仰不是什么新鲜话题了，当然，我们不用改，这就是我们的本性。西方人信神，我们信的是人。我们无法摆脱人际关系对我们的影响，家庭、朋友、领导、圈子……只要在中国生活，躲也躲不掉。神是有定性的，可人是没有定性的。甚至可能因为一句话，朋友变成了仇人；或是几十年后突然遇到，曾经的仇人变成了朋友。在中国人这里，朋友不一定说得上话，说得上话的不一定是朋友，就这么乱七八糟的，都在壳的外边。壳的里边，永远是一颗孤独的心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/c19912ca.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/c19912ca.html" class="post-title-link" itemprop="url">基于CocoaPod的Swift组件化开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 18:40:59" itemprop="dateCreated datePublished" datetime="2018-12-06T18:40:59+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h2><p>私人Repo的构建和组件发布，相关资料可以看Cocoapods创建私有podspec,基本流程类似，但由于Swift在CocoaPod中是动态库形式存在，有些问题需要处理</p>
<h2 id="2-组件化，Swift4-2"><a href="#2-组件化，Swift4-2" class="headerlink" title="2. 组件化，Swift4.2"></a>2. 组件化，Swift4.2</h2><p>目标是基于CocoaPod封装基础的组件，暂不讨论项目架构</p>
<h3 id="2-1-Module-‘xxx’-has-no-member-named-‘yyy’"><a href="#2-1-Module-‘xxx’-has-no-member-named-‘yyy’" class="headerlink" title="2.1 Module ‘xxx’ has no member named ‘yyy’"></a>2.1 Module ‘xxx’ has no member named ‘yyy’</h3><p>1.文件没有对应方法，实际是引用出现错误，点击对应.swift文件，展开Xcode右边工作栏，在’file inspector’（文件图标）分类下的Target Membership，选上对应的项目包即可。</p>
<p>2.类的权限错误，检查是否要用public修饰，因为在 target 外只能调用到 public 的代码</p>
<h3 id="2-2-dyld-lazy-symbol-binding-failed-Symbol-not-found"><a href="#2-2-dyld-lazy-symbol-binding-failed-Symbol-not-found" class="headerlink" title="2.2 dyld: lazy symbol binding failed: Symbol not found:"></a>2.2 dyld: lazy symbol binding failed: Symbol not found:</h3><p>开发的组件依赖了其它第三方库，在’file inspector’（文件图标）的Target Membership取消第三方文件的引用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://swifter.tips/property-access/" target="_blank" rel="noopener">https://swifter.tips/property-access/</a></p>
<p><a href="https://www.jianshu.com/p/18db54655246" target="_blank" rel="noopener">https://www.jianshu.com/p/18db54655246</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/cb922651.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/cb922651.html" class="post-title-link" itemprop="url">十七岁的悬崖 -- 《死人经》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-06 17:10:17" itemprop="dateCreated datePublished" datetime="2018-12-06T17:10:17+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[转载]十七岁的悬崖——关于《死人经》三主角的解构与重筑</p>
<p>作者：浪的传人</p>
<p><a href="https://tieba.baidu.com/p/3078330714" target="_blank" rel="noopener">https://tieba.baidu.com/p/3078330714</a></p>
<p>对我来说，读过《死人经》，印象最深的画面莫过于第一卷结末处，顾慎为与霍允两人逃离金鹏堡的瞬间。列作人墙的金鹏杀手们整齐逼来，十七岁的少年扬头望望，然后自悬崖上纵身跃下，在红顶大鹏自天顶垂下的羽翼上面缓缓升起，就此离开改变他一生的地方。</p>
<p>　　上官如还是霍允，其实是个蛮没有意义的话题。死人经不是一部从头到脚充斥象征与隐喻的小说——当然也可以说是，取决于你愿不愿意去穿凿附会——如你所知，对于一部小说而言，可供穿凿附会是最美好的品质。那么我可以说，上官如代表顾慎为的过去——遥远的记忆、美好的憧憬和消逝的梦想；霍允代表顾慎为的现在——压抑的神经、伤痕累累的躯体，以及些许莫名其妙的遗憾，这些遗憾是指向上官如的。连接过去与现在之间的则是顾慎为本人。有时是一点期许——这是通向上官如的一端；有时是一点指望——这是通向霍允的一端。无论期许还是指望，这个人物都看不到未来。事实上没有人看得到未来。</p>
<p>　　上官如。这是汤姆叔叔式故事当中的人物。当然，这样说起来就像是某种刻板的套路与定式——显而易见，一种套路的生命力能够顽强持续两百年，就一定是有道理的。这种定式在老时代是桦木屋里的老黑奴，在新时代是办公室里的新白领，天平另一端则由白人少爷换成了霸道总裁——如你所见，这两者之间并无不同。所以你看，非洲的炎夏和腰缠草裙手执长矛的老酋长，桌凳摇摇晃晃的破烂酒吧和面目模糊的黑黢黢人群，皇宫上空高来高去的女飞贼和另一个因遥远而显得微微可爱的江湖……太阳底下并无新事，十一岁的上官如趴在十四岁的顾慎为肩膀上面听到的那些故事，和印第安先民们奔驰过的土地上、满脸褶子的老汤姆给小主人讲过的没有一个字不同，那些关于一个截然不同世界的日光和鲜血，有如同质一样流淌着，因其遥远而不再令人惊怖。然后这些故事撞在那座悬崖上面戛然而止，寂静的夜里，一个人背着另一个走在狭窄的石梁上，数着满天的星辰多如繁星，这样一幕本身定格成为日后会被不断提起的故事。</p>
<p>　　某种意义上，上官如就是过去的顾慎为。十四岁，十一岁——需要抱歉地说，顾慎为在他十一岁的时候，不会有上官如这样的决断、凶狠与万众瞩目的魅力——十四岁的时候仍然没有。所以对于另一条世界线上的小少爷顾慎为而言，十公子是他难以企及的模板，素未谋面的邻家孩子，但毫无疑问，那时的他是小心翼翼走在这条路上的。韦小宝与康熙的游戏扭打纯属天然，顾慎为与上官如的接近则是刻意而为。他当然会这样做。书中提过吧，顾慎为直到见过十公子后才真正开了窍，“我不知道怎样做一个好奴才，但我知道主人喜欢怎样的奴才”，灵光一现，有什么东西从天灵盖上喷薄而出，因为他看见上官如的同时就看见了自己，如果不是家破人亡被掳走为奴，他本该努力成为那样的人。从这个意义上讲，上官如不仅是他的过去，还是他的理想——很多时候这两样事情难以分开。</p>
<p>　　我小时候常喜欢回忆过去，长大后这种情绪才慢慢淡忘。中间的变化大概是从三五年前开始的，充分证明了走上社会这件事情是多么操蛋而又令人无从抗拒。起初，在横跨两栋楼房之间的消防梯上穿梭来去、为抄一点回家的近路而翻越两三座高墙是美好的，这就是说，曾经拥有自由、勇气、莽撞以及夜晚来临时啸叫回旋于整个城市楼群中间的风；那个时候我十一岁。后来，在隆冬雪后结冰的道路上纵车飞驰、在炎夏的操场上把皮球射入两辆自行车搭成的球门中间是美好的，这就是说，曾经拥有疯狂、精力、执着以及跑道边上为你加油呐喊的一群小姑娘；那个时候我十六岁。然后，在夕阳西下的操场上寻找某个身影、春天来临的时候在墙角的树荫下折断一根柳枝是美好的，这就是说，曾经拥有青涩、懵懂、未来以及晨起早读时穿越窗子和一叠成绩单的扑啦啦的风；那个时候我十九岁。再后来，在午夜的插线板、小台扇和啤酒瓶子中间看西班牙夺冠、平安夜莫名其妙收到冻得冷硬的苹果是美好的，这就是说，曾经拥有青春、理想、死党以及宿舍阳台上把巢筑在破纸箱里的一对白鸽；那个时候我二十三岁。最后，所有上述过程好像那种老式显像管电视突然断了电，化为一团模糊的白斑消失在一片雪花的正中央，这就是说，虽然如上所说，曾经几乎拥有过可供列举的一切，那些已经不够重要，或者不够可爱；这个时候我二十六岁，在读完一本题为《死人经》的小说后泛起一些不那么清晰的想法，迫切地要把它们诉诸笔端。我讲这些是为了证明，过去或曰回忆，往往同所谓理想是一码事，因你对它们的所有权和支配权而被任意创造和重铸，最后你就被这个天底下最庞大的骗局紧紧攫住，无力自拔。十几年前，十岁不到的我在两栋大楼之间的消防梯上面辗转腾挪时，决不会承认那一刻如上文描写般美好，事实上我的双手在颤抖，掌心在流汗，因为一旦失足落下，不管三楼或是五楼，都足够把我摔到屁滚尿流，说不定小命不保——这种感觉听起来熟悉，实际上很久没有过了。</p>
<p>　　所以对于顾慎为来说，上官如是类似回忆与理想糅合在一起的事物，但这些回忆和理想都因为曾经存在、与无法再现，而显得格外惹人厌憎。这是有关少年心事的小秘密，他不会讲给你听，没有任何人会讲给你听。这就是为什么有人说上官如像活在另一条故事线上——她简直是活在另一个平行时空里，带着男主角本该和期待实现的二三四五种可能性，一点点掰开揉碎给你看。任性，倔狠，率直，信任，圣母心……顾慎为必须被她吸引，因为那些全都是曾经在他面前展开的羊肠曲径。顾慎为也必须同她分道扬镳，因为彼时的顾慎为，是斩断了所有那些可能性后的产物，他成功避开了上官如出没的所有平行时空，坚定不移地选择了最后一个，不是因为荷女就在里面，而是他们殊途同归。</p>
<p>　　荷女，或者叫霍允，这样区分不见得有什么意义，因为她是顾慎为的现在，或者说她比顾慎为更加顾慎为，这两种说法之间也不见得有什么不同。就在那座命运的悬崖边上，红顶大鹏负着顾慎为飞向天空，荷女沿着曾经的敌人、今后的同伴们留下的钉痕落向大地，而上官如被他们轻易遗落在金鹏堡的回忆当中，从此不再和母亲说一句话——我以为这是不可思议的关于十七岁的喻示，赶在任何人发现这一点之前。往生崖前，升天入地，这是最重要的第一卷的结尾，是男主角对于少年时代的全部告别，是传说中他向读者最后一次露出微笑的地方，下一次出场将是三年之后，他将变为无笑无泪亦无惧的西域之主，雪山龙王，横扫所有胆敢横亘在他路上的敌人，然后失去全部向往爱的能力。三年后，十年后，十六年后——上一个以这样的笔法取得巨大成功的人是金庸，往往作者愿意这样宕开一笔的时候，就是他希望稍微偷一下懒的时候，唱一支温柔的摇篮曲，曲子一结束，读者一醒来，主角就变身，从眼角眉梢尽是稚气戾气的青涩剑客蜕变成名满天下的神雕侠，比巴拉巴拉仙小魔女更夸张。侠而不是大侠，这一切还要留待他第二次在千军万民的欢呼声中进入那座襄阳城，就此打通朝往五绝登基路上的最后一道障碍。对于顾慎为，金鹏堡就是他的襄阳城，他需要以第二次的进入彻底结束成人礼，进入而不是摧毁，所以他不需要亲手杀死仇人独步王，不需要毁弃承载他前半生最不堪记忆的石堡，因为成就不是否认，新生无需弑旧——然而在那之前，在归来之前，他首先需要离开。</p>
<p>　　顾慎为无法离开，因为红顶大鹏不会在那一瞬间出现在他的身下。或者他早已在上官雨时第一次暗算他的时候死去，因为不会这样巧，落崖人直直摔进大鹏鸟的巢穴。甚而至于他面朝青空，遥远地方有鹰唳滑过，耳畔风声劲急，他期待的奇迹并不见踪影，因为根本没有大鹏这样的神物存在于世，这东西存在这件事情的本身，就和外挂一样不对头。</p>
<p>　　那一年上官如十四岁，顾慎为十七岁，站在十七岁的悬崖边上，他决心要抛离成长为真正男人之前的一切过往——所以他将上官如抛在身后，那是他的过去。同时被丢弃的还有许许多多不切实际的指望与可能——那也是上官如，从此他再不会在梦中成为顾家大少，应酬唱和，承欢膝下，考进清华或者北大——最后一件是我十七岁时的指望，和顾慎为一样，我自悬崖跳下的时候，把它们随手扔得不见影踪，直到现在看来，那不见得有什么帮助。</p>
<p>　　往生崖畔，离别之前，顾慎为遭遇了有生以来最严厉的一场背叛，来自霍允——或者说，来自他自己，在我们的文章里，对于顾慎为和霍允这两个人并不作区分。实迷途其未远，觉今是而昨非，人们最熟悉的背叛者恰恰是自己，这本是理所当然的事情，年轻人经常在一早醒来后变成另外一个人，虽然这一般来说难以察觉。来自十七岁的背叛像一把锋快的剑，干净利落地将另一个顾慎为由他身体里斩了出去。这个顾慎为来自现在，他的身体里面同样没有了上官如的存在；他漂浮在虚空当中，眼看就要坠下去，难以生存，那么他的身体里面一定多出了什么沉浊的东西，令他重逾巨石——我猜那东西叫做信仰，信念，理想，或者其他任何乱七八糟的名字，十七岁，怀揣沉重信仰的少年，愚蠢，冲动，像喝下整瓶闷倒驴一样容易上头，于是他如同炸弹一样落下去，在遥远的山脚砸出轰鸣和巨大的火光——在一个没有红顶大鹏的正常世界里面，这就是顾慎为最后的结局。老实说，我不喜欢这样的结局，尽管相同的事情每时每刻都在发生——但或许正是因为每时每刻都在发生，我们才需要一点小说来提供不一样的场景，不然的话，这个世界未免太面目可憎。</p>
<p>　　所以，在那个命运的三岔路口，最终也只有一个人能够逃脱。这个人抛掉了光怪陆离的过去与不切实际的理想，背叛了写在印花纸笺上的诺言，挥刀斩飞了残留的一点点信仰，在十七岁的悬崖上，以最低的姿态匍匐而下，双手紧紧锁死粗不盈指的细小岩洞，每一次呼吸都伴随魂飞魄散的深重危机，那意味着从两栋楼房中间的消防梯上翻滚着坠下，然后靠轮椅与导尿管度过余生。他是顾慎为，是霍允，是荷女，是千万人——都一样的，那根本无关紧要。他抬起眼，望见那头红顶大鹏翼若垂天之云，抟扶摇而上九万里，背上有人单腿支拄，影在北溟，身至万里，朝发而夕返，然后望向他说：夏虫不可语冰，蟪蛄岂知春秋。</p>
<p>　　这样说的时候，那个人衣不沾尘。</p>
<p>　　嗯，这么看起来感觉就正常一点了。大鹏鸟出现在悬崖前的那一刻顾慎为完成了他的蜕变，从此长出一张标准的主角脸，我身带光环哟，走三关，举手投足间都是八奇领域，我知道你知道我知道你知道我知道你不知道——小说嘛，大家都是这么写的。而唯一逃脱的霍允，此时正匍匐尘埃，真正的顾慎为一退再退，最后退缩在她蜷起的身上，眼望向高远天空上那个光芒万丈的主角顾慎为，那原本是他的指望，想成为主角的指望。每个人都曾有过，可不是每个人都曾实现。</p>
<p>　　返回来说霍允。</p>
<p>　　双女主很难写，不仅是因为其中一个会不打招呼地变成女二，根本的问题出在大部分人写出来的故事根本没有女主——不要说女主了，有人连男主都不会写呢，不要苛求他们。我要夹带私货了，将夜里叶红鱼简直一万个好顶赞，没有抱上床真是太可惜了。顺便，我觉得一个角色能让读者产生“谁他妈要看主角啊快把XX叫出来”的念头，是对作者最美好的褒扬，以上。用这个标准比划一下的话，上官如某几个瞬间达到了，霍允始终像差着一口气，不大清楚差在哪里了。当然这也不重要。一个人物能达到怎样的高度是由情节推动的，从作者开始谋篇布局的时候就能看出很多人物最终能走到哪里，这种地方往往最考较功力。</p>
<p>　　所以，就不难理解为什么上官如和霍允拥有数量同样庞大且互相看不大对眼的粉丝——都写在人设里呢。上官如代表顾慎为的过去，象征某个因其消逝而被无限美化的世界，那个世界里的顾慎为十七岁，每天晚上洗凉水澡，冬天不穿秋裤，一顿饭吃两个半馒头，一口气跑五千米，百米十二秒五，立定摸高两米七，在床上像一部上足了发条的打桩机，在球场上不知疲倦地奔跑，晃过三个人射门，而球场边上……有一个纤细的身影开心地替他保管衣服和矿泉水，微笑着看他睥睨万物。</p>
<p>　　而另一个世界里，天色暗下来，操场上方的灯光渐次熄灭，顾慎为一个人坐在空荡荡的人工草皮上面，脱下球鞋，费力地控着灌进鞋帮的黑色胶粒。白花花的汗碱浮起在他消瘦的后背上，手指甲刮过去，刺拉拉地响。</p>
<p>　　我不是很清楚更喜欢上官如的都是什么人，因此只能尽自己的能力去揣想和描摹——但是说实话，如果上述第一个世界曾经存在，我也不会太喜欢第二个，除非我自己现在正是一部打桩机——可惜又不是。那即是说，虽然前一个世界里有高来高去、专盗皇宫物件的女飞贼和午夜时分升起在石梁上方的星辉，我还是可以将它们全部舍弃，并不是因为后一个世界里我不用在地铁里挤出一身臭汗，也不是因为后一个世界里我可以坐在三百平米的阳台上端着茶碗看夕阳慢慢掉下远处的小山，只是因为我就生活在后一个世界里，仅此而已。当我不发神经的时候，会觉得这比什么都重要。</p>
<p>　　霍允代表顾慎为的现在，大致就是这么个意思。相似的人生，相似的经历，相似的武功，战斗中互相倚为后背——我以为最后一条是个不尴不尬的暗示，关于人如何对待一个不那么完美的自己。顾慎为给出的答案是：你要发疯，我陪你；你跑丢了，我追你；你要砍我，给你砍——前提是不能当真砍死了。我要有这么一个女朋友，早二百年给她踹飞，省得三辈子内再见到——顾慎为就不能。但我既不佩服也不同情他，因为你总不可能早二百年把自己踹飞，早一刻钟都做不到。在草屋里面对坐编席，时刻提防着对面的女人突然一刀砍过来的时候，顾慎为大概就是这样的心情。这一点上我对他完全理解，很少人能够给自己打出十全十美的分数，但出于种种原因，首先还是得学会接受。比如我也想做一部那种两层楼高、长着一百万个齿轮的隧道掘进机，但是生活还是要继续，不可能某一天发癫去做手术——其实真的去做也不是不可以的事，不过这样一来就扯远了。</p>
<p>　　所以，就我个人而言，不发神经的时候，会更喜欢霍允一点；但是也有发神经的时候，这个时候就更喜欢上官如。大部分曾经历过前后两个世界的人想必也是这样的——我指的不是发神经。两个世界中间是一条名为不忿的细而敏感的线，有时这个世界用的力气大一些，这个时候顾慎为就会和上官如拉拉手，亲亲嘴，把灯关上做一些不害臊的事情；有时那个世界用的力气大一些，这个时候顾慎为就会在失忆的霍允身边一待六年，喂喂鸡，养养狗，然后看着它们慢慢老死，在花园的墓碑上面一笔一划镌刻下它们的名字。全部的不同不过是那段时光里的执着。如你所知，回忆过去这件事情并不总像字面上那么美好，我会为迟到忐忑，为作业烦恼，被从座位上轰起来回家拿习题册子，在路上被小腿那么高的京巴撵得满世界跑，之后连打了二十天的狂犬疫苗——可是看着顾慎为背着熟睡的上官如缓缓走在浸过脚趾的夜雾中，我就把它们全部忘掉啦。</p>
<p>　　故事的最后，上官如一个人笑着离开，去追寻儿时浪迹江湖的愿望，因为“没有我你也能过得很好”。霍允呢，和顾慎为一起，继续走在他们未知的路上，一辈子这样相爱相杀下去，可是“所有人都知道，他们不会结婚”。在这一个瞬间，作者脱出了所有可见不可见的束缚与隔膜，将一切交给早已写定的命运，对过去、现在与未来作了一次精准的切割。就在那座十七岁的悬崖上，猎猎风啸，苍鹰啼鸣，江天似海，白云如野，我们的主人公第一次学会了与一个不完美的自己永远生活下去，那是每个人穷极一生要去完成的任务，允生允死，谁都无法放弃。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/22942e95.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/22942e95.html" class="post-title-link" itemprop="url">The data couldn’t be read because it isn’t in the correct format错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-05 19:09:36" itemprop="dateCreated datePublished" datetime="2018-12-05T19:09:36+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="打包导出（Export）失败"><a href="#打包导出（Export）失败" class="headerlink" title="打包导出（Export）失败"></a>打包导出（Export）失败</h1><h2 id="可能1-Xcode配置错误"><a href="#可能1-Xcode配置错误" class="headerlink" title="可能1:Xcode配置错误"></a>可能1:Xcode配置错误</h2><p>点击Xcode的导出（Export）时提示The data couldn’t be read because it isn’t in the correct format.或者使用Jenkins等</p>
<p>用脚本打包提示如下错误：</p>
<p>原因是Xcode9帮你添加了一个Code Signing Style的配置字段，该字段需要和Automatically manage signing对应，使用Automatically manage signing时该字段的值需要为Automatic，不使用Automatically manage signing时该字段的值需要为Manual，上述错误就是因为配置不对应导致的，修改对应即可。</p>
<h2 id="可能2-Ruby环境错误"><a href="#可能2-Ruby环境错误" class="headerlink" title="可能2:Ruby环境错误"></a>可能2:Ruby环境错误</h2><p>另一中可能是电脑的Ruby环境错误，如没有指定Ruby版本等，可以通过nvm –help命令检查下</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/c3fb7d7d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/c3fb7d7d.html" class="post-title-link" itemprop="url">note:20181204</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-04 16:38:52" itemprop="dateCreated datePublished" datetime="2018-12-04T16:38:52+08:00">2018-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="闻道而行"><a href="#闻道而行" class="headerlink" title="闻道而行"></a>闻道而行</h2><p>子路有闻，未之能行，唯恐有闻</p>
<h2 id="管理和影响"><a href="#管理和影响" class="headerlink" title="管理和影响"></a>管理和影响</h2><p>你不可能掌握所有事情，所以去管理你能够掌握的事，让它不要脱离你的掌握；去影响你不能掌握的事，让它向你希望的方向发展。</p>
<h2 id="已知-未知"><a href="#已知-未知" class="headerlink" title="已知/未知"></a>已知/未知</h2><p>妨碍我们学习的不是未知的，而是已知的，尤其是那种略知一二的。</p>
<h2 id="喜欢"><a href="#喜欢" class="headerlink" title="喜欢"></a>喜欢</h2><p>那是极好，可是我不喜欢。</p>
<h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><p>沟通不是为了征服，而是为了幸福。</p>
<h2 id="善良"><a href="#善良" class="headerlink" title="善良"></a>善良</h2><p>没有善良是不行的，仅有善良是不够的。</p>
<h2 id="饭菜"><a href="#饭菜" class="headerlink" title="饭菜"></a>饭菜</h2><p>做菜的重要性，超越于吃。</p>
<h2 id="承认自己"><a href="#承认自己" class="headerlink" title="承认自己"></a>承认自己</h2><p>我们之所以会不安是因为我们有良心。为了摆脱不安，最简单的方法是承认自己的错误。</p>
<h2 id="长短"><a href="#长短" class="headerlink" title="长短"></a>长短</h2><p>与其想方设法弥补你的短处，不如千方百计发挥你的长处。历史上没有那个人是因为没有缺点而名垂青史的。</p>
<h2 id="家"><a href="#家" class="headerlink" title="家"></a>家</h2><p>整齐的那是宾馆，方便的才是家。</p>
<h2 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h2><p>自由是需要资本的，人的能力越大他越自由。</p>
<h2 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h2><p>父母和孩子之间融洽的家庭关系是对孩子最好的教育。</p>
<h2 id="英雄主义"><a href="#英雄主义" class="headerlink" title="英雄主义"></a>英雄主义</h2><p>世上只有一种英雄主义，那就是看清了这个世界但仍然爱它。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/5386f8e6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/5386f8e6.html" class="post-title-link" itemprop="url">什么能改变一个人的本质？ -- 异域镇魂曲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-20 19:10:21" itemprop="dateCreated datePublished" datetime="2018-11-20T19:10:21+08:00">2018-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>异域镇魂曲，黑岛工作室独立制作的第一款“龙与地下城“类型的游戏，同时用最艰涩、受众最少的“异度风景”（Planescape）来作为游戏背景，推出后引起市场的剧烈响应，有人奉为神作，有人觉得莫名其妙，在大多数游戏评测平台获得极高评价的同时，游戏的销量极其不佳，与其说是游戏，更像一部小说、一个故事，关于诡异、迷幻和艰难。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/p/5386f8e6.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/1d676992.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/1d676992.html" class="post-title-link" itemprop="url">Cocoapods创建私有podspec</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-31 15:39:15" itemprop="dateCreated datePublished" datetime="2018-10-31T15:39:15+08:00">2018-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>创建一个私有的podspec包括如下那么几个步骤：</p>
<ol>
<li>创建并设置一个私有的Spec Repo。</li>
<li>创建Pod的所需要的项目工程文件，并且有可访问的项目版本控制地址。</li>
<li>创建Pod所对应的podspec文件。</li>
<li>本地测试配置好的podspec文件是否可用。</li>
<li>向私有的Spec Repo中提交podspec。</li>
<li>在个人项目中的Podfile中增加刚刚制作的好的Pod并使用。</li>
<li>更新维护podspec。</li>
<li>创建私有Spec Repo</li>
</ol>
<p>先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的</p>
<ol>
<li>├── Specs</li>
<li>└── [SPEC_NAME]</li>
<li>└── [VERSION]</li>
<li>└── [SPEC_NAME].podspec</li>
</ol>
<p>因此我们需要创建一个类似于master的私有Spec Repo，可以fork官方的Repo</p>
<p>创建完成之后在Terminal中执行如下命令</p>
<ol>
<li>pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</li>
<li>pod repo add NewRepo <a href="http://github.com/newrepo/NewRepo.git" target="_blank" rel="noopener">http://github.com/newrepo/NewRepo.git</a></li>
</ol>
<p>此时如果成功的话进入到 <code>~/.cocoapods/repos</code> 目录下就可以看到 <code>NewRepo</code> 这个目录了。至此第一步创建私有 <code>Spec Repo</code> 完成。</p>
<p>PS：如果有其他合作人员共同使用这个私有 <code>Spec Repo</code> 的话在他有对应 <code>Git</code> 仓库的权限的前提下执行相同的命令添加这个 <code>Spec Repo</code> 即可。</p>
<p>创建 <code>Pod</code> 项目工程文件</p>
<p>创建新的组件项目，可以使用Using Pod Lib Create来创建项目</p>
<ol>
<li>$ pod lib create PodDemoLibrary</li>
</ol>
<p>之后四个问题，</p>
<ol>
<li>是否需要一个例子工程；</li>
<li>选择一个测试框架；</li>
<li>是否基于View测试；</li>
<li>类的前缀；</li>
</ol>
<p>具体介绍可以去看官方文档，我这里选择的是 1.yes；2.Specta/Expecta；3.yes；4.JD。 </p>
<p>问完这4个问题他会自动执行pod install命令创建项目并生成依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tree PodDemoLibrary -L 2</span><br><span class="line">PodDemoLibrary</span><br><span class="line">├── Example                                  #demo APP</span><br><span class="line">│   ├── PodDemoLibrary</span><br><span class="line">│   ├── PodDemoLibrary.xcodeproj</span><br><span class="line">│   ├── PodDemoLibrary.xcworkspace</span><br><span class="line">│   ├── Podfile                              #demo APP 的依赖描述文件</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods                                  #demo APP 的依赖文件</span><br><span class="line">│   └── Tests</span><br><span class="line">├── LICENSE                               #开源协议 默认MIT</span><br><span class="line">├── Pod                                       #组件的目录</span><br><span class="line">│   ├── Assets                            #资源文件</span><br><span class="line">│   └── Classes                              #类文件</span><br><span class="line">├── PodDemoLibrary.podspec           #第三步要创建的podspec文件</span><br><span class="line">└── README.md                                #markdown格式的README</span><br><span class="line">9 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>以上是项目生成的目录结构及相关介绍。</p>
<p>接下来就是向Pod文件夹中添加库文件和资源，并配置podspec文件，我把一个网络模块的组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/PodDemoLibrary中了，然后编辑demo工程，测试组件。</p>
<p>注：这里需要注意的是每当你向Pod中添加了新的文件或者以后更新了podspec的版本都需要重新执行一遍pod update命令。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>
<p>通过Cocoapods创建出来的目录本身就在本地的Git管理下，我们需要做的就是给它添加远端仓库，同样去GitHub或其他的Git服务提供商那里创建一个私有的仓库，拿到SSH地址，然后cd到PodDemoLibrary目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;Initial Commit of Library&quot;</span><br><span class="line">$ git remote add origin &lt;git ssh url&gt;          #添加远端仓库</span><br><span class="line">$ git push origin master     #提交到远端仓库</span><br></pre></td></tr></table></figure>

<p>因为 <code>podspec</code> 文件中获取 <code>Git</code> 版本控制的项目还需要 <code>tag</code> 号，所以我们要打上一个 <code>tag</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &#39;0.1.0&#39;</span><br><span class="line">$ git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure>

<p>做完这些就可以开始编辑podspec文件了，它是一个Ruby的文件，把编辑器的格式改成Ruby就能看到语法高亮，下面我贴上我的podspec文件，并在后面以注释的形式说明每个字段的含义，没有涉及到的字段可以去官方文档查阅</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             &#x3D; &quot;PodDemoLibrary&quot;    #名称</span><br><span class="line">s.version          &#x3D; &quot;0.1.0&quot;             #版本号</span><br><span class="line">s.summary          &#x3D; &quot;Just Testing.&quot;     #简短介绍，下面是详细介绍</span><br><span class="line">s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">Testing Private Podspec.</span><br><span class="line">* Markdown format.</span><br><span class="line">* Don&#39;t worry about the indent, we strip it!</span><br><span class="line">DESC</span><br><span class="line">s.homepage         &#x3D; &quot;&lt;git project url&gt;&quot;                           #主页,这里要填写可以访问到的地址，不然验证不通过</span><br><span class="line"># s.screenshots     &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot;           #截图</span><br><span class="line">s.license          &#x3D; &#39;MIT&#39;              #开源协议</span><br><span class="line">s.author           &#x3D; &#123; &quot;abc&quot; &#x3D;&gt; &quot;abc@gmail.com&quot; &#125;                   #作者信息</span><br><span class="line">s.source           &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.git&quot;, :tag &#x3D;&gt; &quot;0.1.0&quot; &#125;      #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span><br><span class="line"># s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;twitter_username&gt;&#39;                       #多媒体介绍地址</span><br><span class="line">s.platform     &#x3D; :ios, &#39;8.0&#39;            #支持的平台及版本</span><br><span class="line">s.requires_arc &#x3D; true                   #是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span><br><span class="line">s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39;     #代码源文件地址，**&#x2F;*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span><br><span class="line">s.resource_bundles &#x3D; &#123;</span><br><span class="line">&#39;PodDemoLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">&#125;                                       #资源文件地址</span><br><span class="line">s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39;   #公开头文件地址</span><br><span class="line">s.frameworks &#x3D; &#39;UIKit&#39;                  #所需的framework，多个用逗号隔开</span><br><span class="line">s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;   #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span><br><span class="line">end&lt;&#x2F;twitter_username&gt;</span><br></pre></td></tr></table></figure>

<p>编辑完podspec文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，验证需要执行一下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure>

<p>当你看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; PodDemoLibrary (0.1.0)</span><br><span class="line">PodDemoLibrary passed validation.</span><br></pre></td></tr></table></figure>

<p>时，说明验证通过了，不过这只是这个podspec文件是合格的，不一定说明这个Pod是可以用的，我们需要在本地做一下验证，这就是第四步的内容了，第四步在具体说明。</p>
<h2 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h2><p>如果从第二步过来，已经有了现成的项目，那么就需要给这个项目创建一个podspec文件，创建它需要执行Cocoapods的另外一个命令，官方文档在这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec create PodDemoLibrary git@github.com:abc&#x2F;PodDemoLibrary.git</span><br></pre></td></tr></table></figure>

<p>执行完之后，就创建了一个podspec文件，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure>

<p>验证无误就可以进入下一步了。</p>
<p>本地测试podspec文件</p>
<p>我们可以创建一个新的项目，在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 在Podfile中我们可以这样编辑，有两种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;7.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, :path &#x3D;&gt; &#39;~&#x2F;code&#x2F;Cocoapods&#x2F;podTest&#x2F;PodDemoLibrary&#39;      #指定路径</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, :podspec &#x3D;&gt; &#39;~&#x2F;code&#x2F;Cocoapods&#x2F;podTest&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.podspec&#39;  #指定podspec文件</span><br></pre></td></tr></table></figure>

<p>然后执行pod install命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了，不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/PodDemoLibrary中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。</p>
<p>在项目中编写代码，测试库文件无误后就可以开始下一步了，提交podspec到Spec Repo中。</p>
<p>向Spec Repo提交podspec</p>
<p>向Spec Repo提交podspec需要完成两点一个是podspec必须通过验证无误，在一个就是删掉无用的注释（这个不是必须的，为了规范还是删掉吧）。</p>
<p>向我们的私有Spec Repo提交podspec只需要一个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push NewRepo PodDemoLibrary.podspec  #前面是本地Repo名字 后面是podspec名字</span><br></pre></td></tr></table></figure>

<p>完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/NewRepo目录下查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── PodDemoLibrary</span><br><span class="line">│   └── 0.1.0</span><br><span class="line">│       └── PodDemoLibrary.podspec</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被Push上去了。</p>
<p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pod search PodDemoLibrary</span><br><span class="line">-&gt; PodDemoLibrary (0.1.0)</span><br><span class="line">Just Testing.</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, &#39;~&gt; 0.1.0&#39;</span><br><span class="line">- Homepage: https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;PodDemoLibrary</span><br><span class="line">- Source:   https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;PodDemoLibrary.git</span><br><span class="line">- Versions: 0.1.0 [NewRepo repo]</span><br></pre></td></tr></table></figure>

<p>这里说的是添加到私有的Repo，如果要添加到Cocoapods的官方库了，可以使用trunk工具，具体可以查看官方文档。</p>
<h3 id="使用制作好的Pod"><a href="#使用制作好的Pod" class="headerlink" title="使用制作好的Pod"></a>使用制作好的Pod</h3><p>在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下代码即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#指出Pod源地址，否则只会在官方地址中寻找</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;newRepo&#x2F;NewRepo.git&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod &#39;PodDemoLibrary&#39;, &#39;~&gt; 0.1.0&#39;</span><br></pre></td></tr></table></figure>

<p>然后执行pod update，更新库依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。</p>
<h3 id="更新维护podspec"><a href="#更新维护podspec" class="headerlink" title="更新维护podspec"></a>更新维护podspec</h3><p>最后再来说一下制作好的podspec文件后续的更新维护工作，比如如何添加新的版本，如何删除Pod。</p>
<p>我已经制作好了PodDemoLibrary的0.1.0版本，现在我对他进行升级工作，这次我添加了更多的模块到PodDemoLibrary之中，包括工具类，底层Model及UIKit扩展等，这里又尝试了一下subspec功能，给PodDemoLibrary创建了多个子分支。</p>
<p>具体做法是先将源文件添加到Pod/Classes中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在Pod/Classes下有创建了四个子目录，完成之后继续编辑之前的PodDemoLibrary.podspec，这次增加了subspec特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             &#x3D; &quot;PodDemoLibrary&quot;</span><br><span class="line">s.version          &#x3D; &quot;1.0.0&quot;</span><br><span class="line">s.summary          &#x3D; &quot;Just Testing.&quot;</span><br><span class="line">s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">Testing Private Podspec.</span><br><span class="line">* Markdown format.</span><br><span class="line">* Don&#39;t worry about the indent, we strip it!</span><br><span class="line">DESC</span><br><span class="line">s.homepage         &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary&quot;</span><br><span class="line"># s.screenshots     &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot;</span><br><span class="line">s.license          &#x3D; &#39;MIT&#39;</span><br><span class="line">s.author           &#x3D; &#123; &quot;abc&quot; &#x3D;&gt; &quot;abc@gmail.com&quot; &#125;</span><br><span class="line">s.source           &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.git&quot;, :tag &#x3D;&gt; &quot;1.0.0&quot; &#125;</span><br><span class="line"># s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;twitter_username&gt;&#39;</span><br><span class="line">s.platform     &#x3D; :ios, &#39;8.0&#39;</span><br><span class="line">s.requires_arc &#x3D; true</span><br><span class="line">#s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line">#s.resource_bundles &#x3D; &#123;</span><br><span class="line">#  &#39;PodDemoLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">#&#125;</span><br><span class="line">#s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">s.subspec &#39;NetWorkEngine&#39; do |networkEngine|</span><br><span class="line">networkEngine.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;NetworkEngine&#x2F;**&#x2F;*&#39;</span><br><span class="line">networkEngine.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;NetworkEngine&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">networkEngine.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;DataModel&#39; do |dataModel|</span><br><span class="line">dataModel.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;DataModel&#x2F;**&#x2F;*&#39;</span><br><span class="line">dataModel.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;DataModel&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;CommonTools&#39; do |commonTools|</span><br><span class="line">commonTools.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;CommonTools&#x2F;**&#x2F;*&#39;</span><br><span class="line">commonTools.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;CommonTools&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">commonTools.dependency &#39;OpenUDID&#39;, &#39;~&gt; 1.0.0&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;UIKitAddition&#39; do |ui|</span><br><span class="line">ui.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;UIKitAddition&#x2F;**&#x2F;*&#39;</span><br><span class="line">ui.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;UIKitAddition&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">ui.resource &#x3D; &quot;Pod&#x2F;Assets&#x2F;MLSUIKitResource.bundle&quot;</span><br><span class="line">ui.dependency &#39;PodDemoLibrary&#x2F;CommonTools&#39;</span><br><span class="line">end</span><br><span class="line">s.frameworks &#x3D; &#39;UIKit&#39;</span><br><span class="line">#s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;</span><br><span class="line">#s.dependency &#39;OpenUDID&#39;, &#39;~&gt; 1.0.0&#39;</span><br><span class="line">end&lt;&#x2F;twitter_username&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们创建了subspec所以项目整体的依赖dependency，源文件source_files，头文件public_header_files，资源文件resource等都移动到了各自的subspec中，每个subspec之间也可以有相互的依赖关系，比如UIKitAddition就依赖于CommonTools。</p>
<p>编辑完成之后，在测试项目里pod update一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的tag-&gt;1.0.0。</p>
<p>最后再次使用pod lib lint验证编辑好的podsepc文件，没有自身的WARNING或者ERROR之后，就可以再次提交到Spec Repo中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push NewRepo PodDemoLibrary.podspec</span><br></pre></td></tr></table></figure>

<p>之后再次到~/.cocoapods/repos/NewRepo目录下查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── PodDemoLibrary</span><br><span class="line">│   ├── 0.1.0</span><br><span class="line">│   │   └── PodDemoLibrary.podspec</span><br><span class="line">│   └── 1.0.0</span><br><span class="line">│       └── PodDemoLibrary.podspec</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>已经有两个版本了，使用pod search可以看到记录</p>
<p>完成这些之后，在实际项目中我们就可以选择使用整个组件库或者是组件库的某一个部分了，对应的Podfile中添加的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#x2F;NetWorkEngine&#39;, &#39;1.0.0&#39;  #使用某一个部分</span><br><span class="line">pod &#39;PodDemoLibrary&#x2F;UIKitAddition&#39;, &#39;1.0.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, &#39;1.0.0&#39;   #使用整个库</span><br></pre></td></tr></table></figure>

<p>最后介绍一下如何删除一个私有Spec Repo，只需要执行一条命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo remove NewRepo</span><br></pre></td></tr></table></figure>

<p>这样这个Spec Repo就在本地删除了，我们还可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo add NewRepo git@github.com:abc&#x2F;NewRepo.git</span><br></pre></td></tr></table></figure>

<p>再把它给加回来。</p>
<p>如果我们要删除私有Spec Repo下的某一个podspec怎么操作呢，此时无需借助Cocoapods，只需要cd到~/.cocoapods/repos/NewRepo目录下，删掉库目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf PodDemoLibrary</span><br></pre></td></tr></table></figure>

<p>然后在将Git的变动push到远端仓库即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all .</span><br><span class="line">$ git ci -m &quot;remove unuseful pods&quot;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="noopener">使用Cocoapods创建私有podspec</a></p>
<p><a href="http://guides.cocoapods.org/making/private-cocoapods.html" target="_blank" rel="noopener">Private Pods</a></p>
<p><a href="http://blog.grio.com/2014/11/creating-a-private-cocoapod.html" target="_blank" rel="noopener">Creating a Private CocoaPod</a></p>
<p><a href="https://objectpartners.com/2014/06/25/developing-private-in-house-libraries-with-cocoapods/" target="_blank" rel="noopener">Developing Private In-House Libraries with CocoaPods</a></p>
<p><a href="https://www.jianshu.com/p/c94d394f0be7" target="_blank" rel="noopener">制作自己的cocoapods</a></p>
<p><a href="https://www.jianshu.com/p/1e5927eeb341" target="_blank" rel="noopener">Cocoapods使用私有库中遇到的坑</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/45fd89a7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/45fd89a7.html" class="post-title-link" itemprop="url">Realm-Swift使用入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-29 17:55:36" itemprop="dateCreated datePublished" datetime="2018-10-29T17:55:36+08:00">2018-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Realm适用iOS和Android平台，本身相比sqlite、CoreData操作简单，在这里记录下使用方式；<br>（Swift4.2）</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pod ‘RealmSwift’</code></p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>打开 Realm 数据库</p>
<p>要打开一个 Realm 数据库，首先需要初始化一个新的 Realm 对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let realm &#x3D; try! Realm()</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(myDog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将会初始化出一个默认 Realm 数据库。</p>
<h3 id="配置-Realm-数据库"><a href="#配置-Realm-数据库" class="headerlink" title="配置 Realm 数据库"></a>配置 Realm 数据库</h3><p>可配置本地 Realm 数据库在磁盘上的路径；</p>
<p>对于可同步 Realm 数据库而言，可以配置管理用户，以及服务器上的远程路径；</p>
<h3 id="配置版本迁移"><a href="#配置版本迁移" class="headerlink" title="配置版本迁移"></a>配置版本迁移</h3><p>压缩功能，高效地利用磁盘空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func setDefaultRealmForUser(username: String) &#123;</span><br><span class="line">    var config &#x3D; Realm.Configuration()</span><br><span class="line">    &#x2F;&#x2F; 使用默认的目录，但是请将文件名替换为用户名</span><br><span class="line">    config.fileURL &#x3D; config.fileURL!.deletingLastPathComponent().appendingPathComponent(&quot;\(username).realm&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将该配置设置为默认 Realm 配置</span><br><span class="line">    Realm.Configuration.defaultConfiguration &#x3D; config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作-Realm-对象"><a href="#操作-Realm-对象" class="headerlink" title="操作 Realm 对象"></a>操作 Realm 对象</h3><p>对象的自更新</p>
<p>Object 实例是底层数据的动态体现，会自动进行更新；因此这意味着无需去刷新对象的当前状态。修改某个对象的属性，会立即影响到所有指向该对象的其他实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let myDog &#x3D; Dog()</span><br><span class="line">myDog.name &#x3D; &quot;Fido&quot;</span><br><span class="line">myDog.age &#x3D; 1</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(myDog)</span><br><span class="line">&#125;</span><br><span class="line">let myPuppy &#x3D; realm.objects(Dog.self).filter(&quot;age &#x3D;&#x3D; 1&quot;).first</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    myPuppy!.age &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;age of my dog: \(myDog.age)&quot;) &#x2F;&#x2F; &#x3D;&gt; 2</span><br></pre></td></tr></table></figure>

<p>这不仅使得 Realm 保证高速和高效，同时还让代码更为简洁、更为灵活。如果您的 UI 代码基于某个特定的 Realm 对象来实现，那么在触发 UI 重绘以前，您根本无需进行数据刷新或者重新检索。</p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>对象的所有更改（添加、修改和删除）都必须在写入事务内完成。</p>
<p>Realm 对象可以被实例化，还可作为未管理对象使用（例如，还未添加到 Realm 数据库），并且使用方式与其它正常 Swift 对象无异。然而，如果要在线程之间共享对象，或者在应用启动后反复使用，那么您必须将这些对象添加到 Realm 数据库中。向 Realm 数据库中添加对象必须在写入事务内完成。由于写入事务将会产生无法忽略的性能消耗，因此您应当检视您的代码，以确保尽可能减少写入事务的数量。</p>
<p>warning：Realm 的写入操作是同步以及阻塞进行的，它并不会异步执行。如果线程 A 开始进行写入操作，然后线程 B 在线程 A 结束之前，对相同的 Realm 数据库也执行了写入操作，那么线程 A 必须要在线程 B 的写入操作发生之前，结束并提交其事务。写入事务会在 beginWrite() 执行时自动刷新，因此重复写入并不会产生竞争条件。</p>
<h3 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h3><p>Realm 提供了一系列更新对象的方法，根据使用场景的不同， 每个方法都有各自的优缺点。</p>
<h4 id="直接更新"><a href="#直接更新" class="headerlink" title="直接更新"></a>直接更新</h4><p>您可以在写入事务中，通过设置对象的属性从而完成更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在事务中更新对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    author.name &#x3D; &quot;Thomas Pynchon&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键值编码"><a href="#键值编码" class="headerlink" title="键值编码"></a>键值编码</h4><p>Object、Result 和 List 均允许使用 键值编码(KVC)。 当您需要在运行时决定何种属性需要进行更新的时候， 这个方法就非常有用了。<br>批量更新对象时，为集合实现 KVC 是一个很好的做法， 这样就不用承受遍历集合时为每个项目创建访问器 所带来的性能损耗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; realm.objects(Person.self)</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    persons.first?.setValue(true, forKeyPath: &quot;isFirst&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将每个 person 对象的 planet 属性设置为 &quot;Earth&quot;</span><br><span class="line">    persons.setValue(&quot;Earth&quot;, forKeyPath: &quot;planet&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过主键更新"><a href="#通过主键更新" class="headerlink" title="通过主键更新"></a>通过主键更新</h4><p>如果数据模型类中包含了主键，那么 可以使用 Realm().add(_:update:)，从而让 Realm 基于主键来自动更新或者添加对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 book 对象，其主键与之前存储的 book 对象相同</span><br><span class="line">let cheeseBook &#x3D; Book()</span><br><span class="line">cheeseBook.title &#x3D; &quot;Cheese recipes&quot;</span><br><span class="line">cheeseBook.price &#x3D; 9000</span><br><span class="line">cheeseBook.id &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; 更新这个 id &#x3D; 1 的 book</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(cheeseBook, update: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个主键值为 “1” 的 Book 对象已经存在于数据库当中 ，那么该对象只会进行更新。如果不存在的话， 那么一个全新的 Book 对象就会被创建出来，并被添加到数据库当中。</p>
<p>您可以通过传递一个子集，其中只包含打算更新的值， 从而对带有主键的对象进行部分更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设主键为 &#96;1&#96; 的 &quot;Book&quot; 对象已经存在</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Book.self, value: [&quot;id&quot;: 1, &quot;price&quot;: 9000.0], update: true)</span><br><span class="line">    &#x2F;&#x2F; book 对象的 &#96;title&#96; 属性仍旧保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有定义主键，那么最好不要对这类对象传递 update: true 参数。</p>
<p>请注意，对于可空属性 而言， 在更新对象的时候，nil 仍会被视为有效值。如果您提供了一个属性值存在 nil 的字典，那么这个设定会被应用到应用当中，并且这些属性值也会被清空。 为了确保不会出现意外的数据丢失， 在使用此方法之前请再三确认， 只提供了想要进行更新的属性值。</p>
<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><p>在写入事务中，将要删除的对象传递给 Realm().delete(_:) 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cheeseBook 存储在 Realm 数据库中</span><br><span class="line">&#x2F;&#x2F; 在事务中删除对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.delete(cheeseBook)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您同样也可以删除存储在 Realm 数据库当中的所有数据。请注意，Realm 文件会保留在磁盘上所占用的空间，从而为以后的对象预留足够的空间，从而实现快速存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从 Realm 数据库中删除所有对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.deleteAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询将会返回一个 Results 实例，其中包含了一组 Object 对象。Results 的接口与 Array 基本相同，并且可以使用索引下标来访问包含在 Results 当中的对象。与 Array 所不同的是，Results 只能持有一个 Object 子类类型。</p>
<p>所有的查询操作（包括检索和属性访问）在 Realm 中都是延迟加载的。只有当属性被访问时，数据才会被读取。</p>
<p>查询结果并不是数据的拷贝：（在写入事务中）修改查询结果会直接修改磁盘上的数据。与之类似，您可以从 Results 当中的 Object 来直接遍历关系图。</p>
<p>除非对结果进行了访问，否则查询的执行将会被推迟（Lazy）。这意味着 将多个临时 Results 关联在一起，然后对数据进行排序和条件检索的操作， 并不会执行中间状态处理之类的额外工作。</p>
<p>一旦执行了查询，或者添加了通知模块， 那么 Results 将时刻与 Realm 数据库当中的数据保持一致， 如有可能，会在后台线程中执行再一次查询操作。</p>
<p>从 Realm 数据库中检索对象的最基本方法是 Realm().objects(_:)，这个方法将会返回 Object 子类类型在默认 Realm 数据库当中的查询到的所有数据，并以 Results 实例的形式返回。</p>
<p><code>let dogs = realm.objects(Dog.self) // 从默认的 Realm 数据库中遍历所有 Dog 对象</code></p>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>如果您对 NSPredicate 有所了解的话，那么您就已经掌握了在 Realm 中进行查询的方法了。Objects、Realm、List 和 Results 均提供了相关的方法，从而只需传递 NSPredicate 实例、断言字符串、或者断言格式化字符串来查询特定的 Object 实例，这与对 NSArray 进行查询所类似。</p>
<p>例如，下面这个例子通过调用 Results().filter(_:…) 方法，从默认 Realm 数据库中遍历出所有棕黄色、名字以 “B” 开头的狗狗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用断言字符串来查询</span><br><span class="line">var tanDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39; AND name BEGINSWITH &#39;B&#39;&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 NSPredicate 来查询</span><br><span class="line">let predicate &#x3D; NSPredicate(format: &quot;color &#x3D; %@ AND name BEGINSWITH %@&quot;, &quot;tan&quot;, &quot;B&quot;)</span><br><span class="line">tanDogs &#x3D; realm.objects(Dog.self).filter(predicate)</span><br></pre></td></tr></table></figure>

<p>参见 Apple 的断言编程指南来获取更多关于构建断言的信息，此外还可以使用我们的 NSPredicate Cheatsheet。Realm 支持大多数常见的断言：</p>
<p>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</p>
<p>比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!= 和 BETWEEN 支持 Int、Int8、Int16、Int32、Int64、Float、Double 以及 Date 这几种属性类型，例如 age == 45；</p>
<p>比较是否相同：== 和 !=，例如，Results().filter(“company == %@”, company)；</p>
<p>比较操作符 == 和 != 支持布尔属性；</p>
<p>对于 String 和 Data 属性而言，支持使用 ==、!=、BEGINSWITH、CONTAINS 和 ENDSWITH 操作符，例如 name CONTAINS ‘Ja’；</p>
<p>对于 String 属性而言，LIKE 操作符可以用来比较左端属性和右端表达式：? 和 可用作通配符，其中 ? 可以匹配任意一个字符， 匹配 0 个及其以上的字符。例如：value LIKE ‘?bc*’ 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</p>
<p>字符串的比较忽略大小写，例如 name CONTAINS[c] ‘Ja’。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。[c] 修饰符可以与 [d] 修饰符结合使用；</p>
<p>字符串的比较忽略变音符号，例如 name BEGINSWITH[d] ‘e’ 能够匹配到 étoile。这个修饰符可以与 [c] 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见当前的限制一节来了解详细信息。）</p>
<p>Realm 支持以下组合操作符：“AND”、“OR” 和 “NOT”，例如 name BEGINSWITH ‘J’ AND age &gt;= 32；</p>
<p>包含操作符：IN，例如 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</p>
<p>空值比较：==、!=，例如 Results().filter(“ceo == nil”)。请注意，Realm 将 nil 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，nil 等同于自身；</p>
<p>ANY 比较，例如 ANY student.age &lt; 21；</p>
<p>List 和 Results 属性支持聚集表达式：@count、@min、@max、@sum 和 @avg，例如 realm.objects(Company.self).filter(“employees.@count &gt; 5”) 可用以检索所有拥有 5 名以上雇员的公司。</p>
<p>支持子查询，不过存在以下限制：</p>
<p>@count 是唯一一个能在 SUBQUERY 表达式当中使用的操作符；</p>
<p>SUBQUERY(…).@count 表达式只能与常量相比较；</p>
<p>目前仍不支持关联子查询。</p>
<p>参见 Results().filter(_:…)。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Results 允许您指定一个排序标准，然后基于关键路径、属性或者多个排序描述符来进行排序。例如，下列代码让上述示例中返回的 Dog 对象按名字进行升序排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对颜色为棕黄色、名字以 &quot;B&quot; 开头的狗狗进行排序</span><br><span class="line">let sortedDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39; AND name BEGINSWITH &#39;B&#39;&quot;).sorted(byKeyPath: &quot;name&quot;)</span><br></pre></td></tr></table></figure>

<p>关键路径同样也可以是某个多对一关系属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var name &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var dog: Dog?</span><br><span class="line">&#125;</span><br><span class="line">class Dog: Object &#123;</span><br><span class="line">    @objc dynamic var name &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var age &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dogOwners &#x3D; realm.objects(Person.self)</span><br><span class="line">let ownersByDogAge &#x3D; dogOwners.sorted(byKeyPath: &quot;dog.age&quot;)</span><br></pre></td></tr></table></figure>

<p>请注意，sorted(byKeyPath:) 和 sorted(byProperty:) 不支持 将多个属性用作排序基准，此外也无法链式排序（只有最后一个 sorted 调用会被使用）。 如果要对多个属性进行排序，请使用 sorted(by:)方法，然后向其中输入多个 SortDescriptor 对象。</p>
<p>欲了解更多信息，参见：</p>
<p>Results().sorted(_:)</p>
<p>Results().sorted(byKeyPath:ascending:)</p>
<p>注意，在对查询进行排序的时候，只能保证 Results 的次序不变。 出于性能考量，插入次序将无法保证。 如果您希望维护插入次序， 那么可以在这里查看解决方案。</p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。</p>
<p>如果您需要获取一个棕黄色狗狗的结果集，然后在此基础上再获取名字以 ‘B’ 开头的棕黄色狗狗，那么您可以像这样将这两个查询连接起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tanDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39;&quot;)</span><br><span class="line">let tanDogsWithBNames &#x3D; tanDogs.filter(&quot;name BEGINSWITH &#39;B&#39;&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="结果的自更新"><a href="#结果的自更新" class="headerlink" title="结果的自更新"></a>结果的自更新</h3><p>Object 实例是底层数据的动态体现，其会自动进行更新，这意味着您无需去重新检索结果。它们会直接映射出 Realm 数据库在当前线程中的状态，包括当前线程上的写入事务。唯一的例外是，在使用 for…in 枚举时，它会将刚开始遍历时满足匹配条件的所有对象给遍历完，即使在遍历过程中有对象被过滤器修改或者删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let puppies &#x3D; realm.objects(Dog.self).filter(&quot;age &lt; 2&quot;)</span><br><span class="line">puppies.count &#x2F;&#x2F; &#x3D;&gt; 0</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Dog.self, value: [&quot;name&quot;: &quot;Fido&quot;, &quot;age&quot;: 1])</span><br><span class="line">&#125;</span><br><span class="line">puppies.count &#x2F;&#x2F; &#x3D;&gt; 1</span><br></pre></td></tr></table></figure>

<p>所有的 Results 对象均有此特性，无论是匹配查询出来的还是链式查询出来的。</p>
<p>Results 属性不仅让 Realm 数据库保证高速和高效，同时还让代码更为简洁、更加灵活。例如，如果视图控制器基于查询结果来实现，那么您可以将 Results 存储在属性当中，这样每次访问就不需要刷新以确保数据最新了。</p>
<p>您可以订阅 Realm 通知，以了解 Realm 数据何时发生了更新，比如说可以决定应用 UI 何时进行刷新，而无需重新检索 Results。<br>由于结果是自动更新的，因此不要迷信下标索引和总数会保持不变。Results 不变的唯一情况是在快速枚举的时候，这样就可以在枚举过程中，对匹配条件的对象进行修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try! realm.write &#123;</span><br><span class="line">    for person in realm.objects(Person.self).filter(&quot;age &#x3D;&#x3D; 10&quot;) &#123;</span><br><span class="line">        person.age +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以使用键值编码 来对 Results 执行相关操作。</p>
<h3 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h3><p>大多数其他数据库技术都提供了从检索中对结果进行“分页”的能力（例如 SQLite 中的 “LIMIT” 关键字）。这通常是很有必要的，可以避免一次性从硬盘中读取太多的数据，或者将太多查询结果加载到内存当中。</p>
<p>由于 Realm 中的检索是惰性的，因此这行这种分页行为是没有必要的。因为 Realm 只会在检索到的结果被明确访问时，才会从其中加载对象。</p>
<p>如果由于 UI 相关或者其他代码实现相关的原因导致您需要从检索中获取一个特定的对象子集，这和获取 Results 对象一样简单，只需要读出您所需要的对象即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 循环读取出前 5 个 Dog 对象</span><br><span class="line">&#x2F;&#x2F; 从而限制从磁盘中读取的对象数量</span><br><span class="line">let dogs &#x3D; try! Realm().objects(Dog.self)</span><br><span class="line">for i in 0..&lt;5 &#123;&#x3D;&quot;&quot; let&#x3D;&quot;&quot; dog&#x3D;&quot;dogs[i]&quot; ...&#x3D;&quot;&quot; &#125;&#x3D;&quot;&quot; &lt;&#x3D;&quot;&quot; code&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="本地迁移"><a href="#本地迁移" class="headerlink" title="本地迁移"></a>本地迁移</h3><p>通过设置 Realm.Configuration.schemaVersion 以及 Realm.Configuration.migrationBlock 可以定义本地迁移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">let config &#x3D; Realm.Configuration(</span><br><span class="line">    &#x2F;&#x2F; 设置新的架构版本。必须大于之前所使用的</span><br><span class="line">    &#x2F;&#x2F; （如果之前从未设置过架构版本，那么当前的架构版本为 0）</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置模块，如果 Realm 的架构版本低于上面所定义的版本，</span><br><span class="line">    &#x2F;&#x2F; 那么这段代码就会自动调用</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        &#x2F;&#x2F; 我们目前还未执行过迁移，因此 oldSchemaVersion &#x3D;&#x3D; 0</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有什么要做的！</span><br><span class="line">            &#x2F;&#x2F; Realm 会自行检测新增和被移除的属性</span><br><span class="line">            &#x2F;&#x2F; 然后会自动更新磁盘上的架构</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通知 Realm 为默认的 Realm 数据库使用这个新的配置对象</span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; config</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 现在我们已经通知了 Realm 如何处理架构变化，</span><br><span class="line">&#x2F;&#x2F; 打开文件将会自动执行迁移</span><br><span class="line">let realm &#x3D; try! Realm()</span><br></pre></td></tr></table></figure>

<h2 id="值的更新"><a href="#值的更新" class="headerlink" title="值的更新"></a>值的更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; Realm.Configuration(</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; enumerateObjects(ofType:_:) 方法将会遍历</span><br><span class="line">            &#x2F;&#x2F; 所有存储在 Realm 文件当中的 &#96;Person&#96; 对象</span><br><span class="line">            migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in</span><br><span class="line">                &#x2F;&#x2F; 将两个 name 合并到 fullName 当中</span><br><span class="line">                let firstName &#x3D; oldObject![&quot;firstName&quot;] as! String</span><br><span class="line">                let lastName &#x3D; oldObject![&quot;lastName&quot;] as! String</span><br><span class="line">                newObject![&quot;fullName&quot;] &#x3D; &quot;\(firstName) \(lastName)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; Realm.Configuration(</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        &#x2F;&#x2F; 我们目前还未执行过迁移，因此 oldSchemaVersion &#x3D;&#x3D; 0</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 重命名操作必须要在 &#96;enumerateObjects(ofType: _:)&#96; 调用之外进行</span><br><span class="line">            migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>当整个 Realm 数据库发生变化时，就会发送 Realm 通知；如果只有个别对象被修改、添加或者删除，那么就会发送集合通知。</p>
<p>通知只会在最初所注册的注册的线程中传递，并且该线程必须拥有一个正在运行的 Run Loop</p>
<p>Realm 通知</p>
<p>通知处理模块可以对整个 Realm 数据库进行注册。每次涉及到 Realm 的写入事务提交之后，无论写入事务发生在哪个线程还是进程中，通知处理模块都会被激活：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 Realm 通知</span><br><span class="line">let token &#x3D; realm.observe &#123; notification, realm in</span><br><span class="line">    viewController.updateUI()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 随后</span><br><span class="line">token.invalidate()</span><br></pre></td></tr></table></figure>

<h3 id="集合通知"><a href="#集合通知" class="headerlink" title="集合通知"></a>集合通知</h3><p>可以通过传递到通知模块当中的 RealmCollectionChange 参数来访问这些变更。该对象存放了受删除 (deletions)、插入 (insertions) 以及修改 (modifications) 所影响的索引信息。</p>
<h3 id="对象通知"><a href="#对象通知" class="headerlink" title="对象通知"></a>对象通知</h3><p>Realm 支持对象级别的通知。可以在特定的 Realm 对象上进行通知的注册，对象被删除、修改时获取相应的通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class StepCounter: Object &#123;</span><br><span class="line">    @objc dynamic var steps &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stepCounter &#x3D; StepCounter()</span><br><span class="line">let realm &#x3D; try! Realm()</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(stepCounter)</span><br><span class="line">&#125;</span><br><span class="line">var token : NotificationToken?</span><br><span class="line">token &#x3D; stepCounter.observe &#123; change in</span><br><span class="line">    switch change &#123;</span><br><span class="line">    case .change(let properties):</span><br><span class="line">        for property in properties &#123;</span><br><span class="line">            if property.name &#x3D;&#x3D; &quot;steps&quot; &amp;&amp; property.newValue as! Int &gt; 1000 &#123;</span><br><span class="line">                print(&quot;Congratulations, you&#39;ve exceeded 1000 steps.&quot;)</span><br><span class="line">                token &#x3D; nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;An error occurred: \(error)&quot;)</span><br><span class="line">    case .deleted:</span><br><span class="line">        print(&quot;The object was deleted.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨线程使用-Realm-数据库"><a href="#跨线程使用-Realm-数据库" class="headerlink" title="跨线程使用 Realm 数据库"></a>跨线程使用 Realm 数据库</h2><p>在不同的线程中使用同一个 Realm 文件，必须每一个线程初始化一个新的Realm 实例。</p>
<p>不支持跨线程共享Realm 实例。Realm 实例要访问相同的 Realm 文件还必须使用相同的 Realm.Configuration。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Realm 没有提供对 JSON 的直接支持，可以使用 NSJSONSerialization.JSONObjectWithData(_:options:) 的输出</p>
<h2 id="常见限制"><a href="#常见限制" class="headerlink" title="常见限制"></a>常见限制</h2><p>Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如：</p>
<p>类名称的长度最大只能存储 57 个 UTF8 字符。</p>
<p>属性名称的长度最大只能支持 63 个 UTF8 字符。</p>
<p>Data 和 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。</p>
<p>每个单独的 Realm 文件大小无法超过应用在 iOS 系统中所被允许使用的内存量——这个量对于每个设备而言都是不同的，并且还取决于当时内存空间的碎片化情况(关于此问题有一个相关的 Radar：rdar://17119975)。如果您需要存储海量数据的话，那么可以选择使用多个 Realm 文件并进行映射。</p>
<p>对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>尽管 Realm 文件可以被多个线程同时访问，但是您不能直接跨线程传递 Realms、Realm 对象、查询和查询结果。如果您需要跨线程传递 Realm 对象的话，您可以使用 ThreadSafeReference API。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Setter 和 Getter：因为 Realm 在底层数据库中重写了 setters 和 getters 方法，所以您不可以在您的对象上再对其进行重写。一个简单的替代方法就是：创建一个新的 Realm 忽略属性，该属性的访问起可以被重写， 并且可以调用其他的 getter 和 setter 方法。</p>
<p>自动增长属性：Realm 没有线程且进程安全的自动增长属性机制，而这在其他数据库中常常用来产生主键。然而，在绝大多数情况下，对于主键来说，我们需要的是一个唯一的、自动生成的值，因此没有必要使用顺序的、连续的、整数的 ID 作为主键，因此一个独一无二的字符串主键通常就能满足需求了。一个常见的模式是将默认的属性值设置为 NSUUID().UUIDString 以产生一个唯一的字符串 ID。</p>
<p>自动增长属性另一种常见的动机是为了维持插入之后的顺序。在某些情况下，这可以通过向某个 List中添加对象，或者使用 NSDate() 默认值的 createdAt 属性。</p>
<p>Objective-C 中的属性：如果您需要在 Objective‑C 中访问 Realm Swift 模型的话，那么注意所有 List以及 RealmOptional 属性都不可用（就像其他 Swift 独有的数据类型一样）——如果有必要的话，您可以添加封装的 getter 和 setter 方法，将其在 NSNumber 或者 NSArray 之间进行转化。此外，早于 Xcode 7 Beta 5 之前的版本有一个 已知的Swift bug，它会导致自动生成的 Objective‑C 头文件（-Swift.h）无法通过编译。您就必须将 List 类型的属性设置为 private 或者 internal。请前往 GitHub issue #1925了解更多信息。</p>
<p>Object 子类的自定义构造器：当您创建 Object 子类模型的时候，您或许会想要添加自己的构造器方法，以便增加便利性。</p>
<p>由于 Swift 内省机制中现有的一些限制，我们不能给这个类中添加指定构造器(designated initializer)。相反，它们需要被标记为便利构造器(convenience initializer)，使用相同名字的 Swift 关键词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyModel: Object &#123;</span><br><span class="line">    @objc dynamic var myValue &#x3D; &quot;&quot;</span><br><span class="line">    convenience init(myValue: String) &#123;</span><br><span class="line">        self.init() &#x2F;&#x2F; 请注意这里使用的是 &#39;self&#39; 而不是 &#39;super&#39;</span><br><span class="line">        self.myValue &#x3D; myValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/fa3fafc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/fa3fafc.html" class="post-title-link" itemprop="url">What Remains of Edith Finch - Home</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-23 19:04:46" itemprop="dateCreated datePublished" datetime="2018-09-23T19:04:46+08:00">2018-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="伊迪丝·芬奇的记忆"><a href="#伊迪丝·芬奇的记忆" class="headerlink" title="伊迪丝·芬奇的记忆"></a>伊迪丝·芬奇的记忆</h1><p><img src="/imags/blog_edith_finch_home.png" alt=""></p>
<p>死亡并不是逝者一个人的事，它还会给活下来的人心中留下些东西，是阴影还是阳光，则取决于我们如何看它。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/p/fa3fafc.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/6c2e93eb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/6c2e93eb.html" class="post-title-link" itemprop="url">Git 常用命令速查表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-31 16:46:42" itemprop="dateCreated datePublished" datetime="2018-08-31T16:46:42+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git add</td>
<td>添加至暂存区</td>
</tr>
<tr>
<td>git add–interactive</td>
<td>交互式添加</td>
</tr>
<tr>
<td>git apply</td>
<td>应用补丁</td>
</tr>
<tr>
<td>git am</td>
<td>应用邮件格式补丁</td>
</tr>
<tr>
<td>git annotate</td>
<td>等同于 git blame</td>
</tr>
<tr>
<td>git archive</td>
<td>文件归档打包</td>
</tr>
<tr>
<td>git bisect</td>
<td>二分查找</td>
</tr>
<tr>
<td>git blame</td>
<td>文件逐行追溯</td>
</tr>
<tr>
<td>git branch</td>
<td>分支管理</td>
</tr>
<tr>
<td>git cat-file</td>
<td>版本库对象研究工具</td>
</tr>
<tr>
<td>git checkout</td>
<td>检出到工作区、切换或创建分支</td>
</tr>
<tr>
<td>git cherry-pick</td>
<td>提交拣选</td>
</tr>
<tr>
<td>git citool</td>
<td>图形化提交，相当于 git gui 命令</td>
</tr>
<tr>
<td>git clean</td>
<td>清除工作区未跟踪文件</td>
</tr>
<tr>
<td>git clone</td>
<td>克隆版本库</td>
</tr>
<tr>
<td>git commit</td>
<td>提交</td>
</tr>
<tr>
<td>git config</td>
<td>查询和修改配置</td>
</tr>
<tr>
<td>git describe</td>
<td>通过里程碑直观地显示提交ID</td>
</tr>
<tr>
<td>git diff</td>
<td>差异比较</td>
</tr>
<tr>
<td>git difftool</td>
<td>调用图形化差异比较工具</td>
</tr>
<tr>
<td>git fetch</td>
<td>获取远程版本库的提交</td>
</tr>
<tr>
<td>git format-patch</td>
<td>创建邮件格式的补丁文件。参见 git am 命令</td>
</tr>
<tr>
<td>git grep</td>
<td>文件内容搜索定位工具</td>
</tr>
<tr>
<td>git gui</td>
<td>基于Tcl/Tk的图形化工具，侧重提交等操作</td>
</tr>
<tr>
<td>git help</td>
<td>帮助</td>
</tr>
<tr>
<td>git init</td>
<td>版本库初始化</td>
</tr>
<tr>
<td>git init-db*</td>
<td>等同于 git init</td>
</tr>
<tr>
<td>git log</td>
<td>显示提交日志</td>
</tr>
<tr>
<td>git merge</td>
<td>分支合并</td>
</tr>
<tr>
<td>git mergetool</td>
<td>图形化冲突解决</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名</td>
</tr>
<tr>
<td>git pull</td>
<td>拉回远程版本库的提交</td>
</tr>
<tr>
<td>git push</td>
<td>推送至远程版本库</td>
</tr>
<tr>
<td>git rebase</td>
<td>分支变基</td>
</tr>
<tr>
<td>git rebase–interactive</td>
<td>交互式分支变基</td>
</tr>
<tr>
<td>git reflog</td>
<td>分支等引用变更记录管理</td>
</tr>
<tr>
<td>git remote</td>
<td>远程版本库管理</td>
</tr>
<tr>
<td>git repo-config*</td>
<td>同于 git config</td>
</tr>
<tr>
<td>git reset</td>
<td>重置改变分支“游标”指向</td>
</tr>
<tr>
<td>git rev-parse</td>
<td>将各种引用表示法转换为哈希值等</td>
</tr>
<tr>
<td>git revert</td>
<td>反转提交</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>git show</td>
<td>显示各种类型的对象</td>
</tr>
<tr>
<td>git stage*</td>
<td>等同于 git add</td>
</tr>
<tr>
<td>git stash</td>
<td>保存和恢复进度</td>
</tr>
<tr>
<td>git status</td>
<td>显示工作区文件状态</td>
</tr>
<tr>
<td>git tag</td>
<td>里程碑管理</td>
</tr>
</tbody></table>
<h2 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git commit-tree</td>
<td>从树对象创建提交</td>
</tr>
<tr>
<td>git hash-object</td>
<td>从标准输入或文件计算哈希值或创建对象</td>
</tr>
<tr>
<td>git ls-files</td>
<td>显示工作区和暂存区文件</td>
</tr>
<tr>
<td>git ls-tree</td>
<td>显示树对象包含的文件</td>
</tr>
<tr>
<td>git mktag</td>
<td>读取标准输入创建一个里程碑对象</td>
</tr>
<tr>
<td>git mktree</td>
<td>读取标准输入创建一个树对象</td>
</tr>
<tr>
<td>git read-tree</td>
<td>读取树对象到暂存区</td>
</tr>
<tr>
<td>git update-index</td>
<td>工作区内容注册到暂存区及暂存区管理</td>
</tr>
<tr>
<td>git unpack-file</td>
<td>创建临时文件包含指定 blob 的内容</td>
</tr>
<tr>
<td>git write-tree</td>
<td>从暂存区创建一个树对象</td>
</tr>
</tbody></table>
<h2 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git check-ref-format</td>
<td>检查引用名称是否符合规范</td>
</tr>
<tr>
<td>git for-each-ref</td>
<td>引用迭代器，用于shell编程</td>
</tr>
<tr>
<td>git ls-remote</td>
<td>显示远程版本库的引用</td>
</tr>
<tr>
<td>git name-rev</td>
<td>将提交ID显示为友好名称</td>
</tr>
<tr>
<td>git rev-list</td>
<td>显示版本范围</td>
</tr>
<tr>
<td>git show-branch</td>
<td>显示分支列表及拓扑关系</td>
</tr>
<tr>
<td>git show-ref</td>
<td>显示本地引用</td>
</tr>
<tr>
<td>git symbolic-ref</td>
<td>显示或者设置符号引用</td>
</tr>
<tr>
<td>git update-ref</td>
<td>更新引用的指向</td>
</tr>
<tr>
<td>git verify-tag</td>
<td>校验 GPG 签名的Tag</td>
</tr>
</tbody></table>
<h2 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git count-objects</td>
<td>显示松散对象的数量和磁盘占用</td>
</tr>
<tr>
<td>git filter-branch</td>
<td>版本库重构</td>
</tr>
<tr>
<td>git fsck</td>
<td>对象库完整性检查</td>
</tr>
<tr>
<td>git gc</td>
<td>版本库存储优化</td>
</tr>
<tr>
<td>git index-pack</td>
<td>从打包文件创建对应的索引文件</td>
</tr>
<tr>
<td>git pack-objects</td>
<td>从标准输入读入对象ID，打包到文件</td>
</tr>
<tr>
<td>git pack-redundant</td>
<td>查找多余的 pack 文件</td>
</tr>
<tr>
<td>git pack-refs</td>
<td>将引用打包到 .git/packed-refs 文件中</td>
</tr>
<tr>
<td>git prune</td>
<td>从对象库删除过期对象</td>
</tr>
<tr>
<td>git prune-packed</td>
<td>将已经打包的松散对象删除</td>
</tr>
<tr>
<td>git relink</td>
<td>为本地版本库中相同的对象建立硬连接</td>
</tr>
<tr>
<td>git repack</td>
<td>将版本库未打包的松散对象打包</td>
</tr>
<tr>
<td>git show-index</td>
<td>读取包的索引文件，显示打包文件中的内容</td>
</tr>
<tr>
<td>git unpack-objects</td>
<td>从打包文件释放文件</td>
</tr>
<tr>
<td>git verify-pack</td>
<td>校验对象库打包文件</td>
</tr>
</tbody></table>
<h2 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git fetch-pack</td>
<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>
</tr>
<tr>
<td>git receive-pack</td>
<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>
</tr>
<tr>
<td>git send-pack</td>
<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>
</tr>
<tr>
<td>git upload-archive</td>
<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>
</tr>
<tr>
<td>git upload-pack</td>
<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>
</tr>
</tbody></table>
<h2 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git imap-send</td>
<td>将补丁通过 IMAP 发送</td>
</tr>
<tr>
<td>git mailinfo</td>
<td>从邮件导出提交说明和补丁</td>
</tr>
<tr>
<td>git mailsplit</td>
<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>
</tr>
<tr>
<td>git request-pull</td>
<td>创建包含提交间差异和执行PULL操作地址的信息</td>
</tr>
<tr>
<td>git send-email</td>
<td>发送邮件</td>
</tr>
</tbody></table>
<h2 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git daemon</td>
<td>实现Git协议</td>
</tr>
<tr>
<td>git http-backend</td>
<td>实现HTTP协议的CGI程序，支持智能HTTP协议</td>
</tr>
<tr>
<td>git instaweb</td>
<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>
</tr>
<tr>
<td>git shell</td>
<td>受限制的shell，提供仅执行Git命令的SSH访问</td>
</tr>
<tr>
<td>git update-server-info</td>
<td>更新哑协议需要的辅助文件</td>
</tr>
<tr>
<td>git http-fetch</td>
<td>通过HTTP协议获取版本库</td>
</tr>
<tr>
<td>git http-push</td>
<td>通过HTTP/DAV协议推送</td>
</tr>
<tr>
<td>git remote-ext</td>
<td>由Git命令调用，通过外部命令提供扩展协议支持</td>
</tr>
<tr>
<td>git remote-fd</td>
<td>由Git命令调用，使用文件描述符作为协议接口</td>
</tr>
<tr>
<td>git remote-ftp</td>
<td>由Git命令调用，提供对FTP协议的支持</td>
</tr>
<tr>
<td>git remote-ftps</td>
<td>由Git命令调用，提供对FTPS协议的支持</td>
</tr>
<tr>
<td>git remote-http</td>
<td>由Git命令调用，提供对HTTP协议的支持</td>
</tr>
<tr>
<td>git remote-https</td>
<td>由Git命令调用，提供对HTTPS协议的支持</td>
</tr>
<tr>
<td>git remote-testgit</td>
<td>协议扩展示例脚本</td>
</tr>
</tbody></table>
<h2 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git archimport</td>
<td>导入Arch版本库到Git</td>
</tr>
<tr>
<td>git bundle</td>
<td>提交打包和解包，以便在不同版本库间传递</td>
</tr>
<tr>
<td>git cvsexportcommit</td>
<td>将Git的一个提交作为一个CVS检出</td>
</tr>
<tr>
<td>git cvsimport</td>
<td>导入CVS版本库到Git。或者使用 cvs2git</td>
</tr>
<tr>
<td>git cvsserver</td>
<td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td>
</tr>
<tr>
<td>git fast-export</td>
<td>将提交导出为 git-fast-import 格式</td>
</tr>
<tr>
<td>git fast-import</td>
<td>其他版本库迁移至Git的通用工具</td>
</tr>
<tr>
<td>git svn</td>
<td>Git 作为前端操作 Subversion</td>
</tr>
</tbody></table>
<h2 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git merge-base</td>
<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>
</tr>
<tr>
<td>git merge-file</td>
<td>针对文件的两个不同版本执行三向文件合并</td>
</tr>
<tr>
<td>git merge-index</td>
<td>对index中的冲突文件调用指定的冲突解决工具</td>
</tr>
<tr>
<td>git merge-octopus</td>
<td>合并两个以上分支。参见 git merge 的octopus合并策略</td>
</tr>
<tr>
<td>git merge-one-file</td>
<td>由 git merge-index 调用的标准辅助程序</td>
</tr>
<tr>
<td>git merge-ours</td>
<td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td>
</tr>
<tr>
<td>git merge-recursive</td>
<td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td>
</tr>
<tr>
<td>git merge-resolve</td>
<td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td>
</tr>
<tr>
<td>git merge-subtree</td>
<td>子树合并。参见 git merge 的 subtree 合并策略</td>
</tr>
<tr>
<td>git merge-tree</td>
<td>显式三向合并结果，不改变暂存区</td>
</tr>
<tr>
<td>git fmt-merge-msg</td>
<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>
</tr>
<tr>
<td>git rerere</td>
<td>重用所记录的冲突解决方案</td>
</tr>
</tbody></table>
<h2 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git bisect–helper</td>
<td>由 git bisect 命令调用，确认二分查找进度</td>
</tr>
<tr>
<td>git check-attr</td>
<td>显示某个文件是否设置了某个属性</td>
</tr>
<tr>
<td>git checkout-index</td>
<td>从暂存区拷贝文件至工作区</td>
</tr>
<tr>
<td>git cherry</td>
<td>查找没有合并到上游的提交</td>
</tr>
<tr>
<td>git diff-files</td>
<td>比较暂存区和工作区，相当于 git diff –raw</td>
</tr>
<tr>
<td>git diff-index</td>
<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>
</tr>
<tr>
<td>git diff-tree</td>
<td>比较两个树对象，相当于 git diff –raw A B</td>
</tr>
<tr>
<td>git difftool–helper</td>
<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>
</tr>
<tr>
<td>git get-tar-commit-id</td>
<td>从 git archive 创建的 tar 包中提取提交ID</td>
</tr>
<tr>
<td>git gui–askpass</td>
<td>命令 git gui 的获取用户口令输入界面</td>
</tr>
<tr>
<td>git notes</td>
<td>提交评论管理</td>
</tr>
<tr>
<td>git patch-id</td>
<td>补丁过滤行号和空白字符后生成补丁唯一ID</td>
</tr>
<tr>
<td>git quiltimport</td>
<td>将Quilt补丁列表应用到当前分支</td>
</tr>
<tr>
<td>git replace</td>
<td>提交替换</td>
</tr>
<tr>
<td>git shortlog</td>
<td>对 git log 的汇总输出，适合于产品发布说明</td>
</tr>
<tr>
<td>git stripspace</td>
<td>删除空行，供其他脚本调用</td>
</tr>
<tr>
<td>git submodule</td>
<td>子模组管理</td>
</tr>
<tr>
<td>git var</td>
<td>显示 Git 环境变量</td>
</tr>
<tr>
<td>git web–browse</td>
<td>启动浏览器以查看目录或文件</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>显示提交历史及每次提交的改动</td>
</tr>
<tr>
<td>git-mergetool–lib</td>
<td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td>
</tr>
<tr>
<td>git-parse-remote</td>
<td>包含于其他脚本中，提供操作远程版本库的函数</td>
</tr>
<tr>
<td>git-sh-setup</td>
<td>包含于其他脚本中，提供 shell 编程的函数库</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description">记录思考的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">172</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
