<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jundongwu.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录思考的地方">
<meta property="og:type" content="website">
<meta property="og:title" content="俊东的Blog">
<meta property="og:url" content="https://jundongwu.com/page/13/index.html">
<meta property="og:site_name" content="俊东的Blog">
<meta property="og:description" content="记录思考的地方">
<meta property="og:locale" content="cn">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jundongwu.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>俊东的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">俊东的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">少则得，多则惑</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/5386f8e6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/5386f8e6.html" class="post-title-link" itemprop="url">什么能改变一个人的本质？ -- 异域镇魂曲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-20 19:10:21" itemprop="dateCreated datePublished" datetime="2018-11-20T19:10:21+08:00">2018-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>异域镇魂曲，黑岛工作室独立制作的第一款“龙与地下城“类型的游戏，同时用最艰涩、受众最少的“异度风景”（Planescape）来作为游戏背景，推出后引起市场的剧烈响应，有人奉为神作，有人觉得莫名其妙，在大多数游戏评测平台获得极高评价的同时，游戏的销量极其不佳，与其说是游戏，更像一部小说、一个故事，关于诡异、迷幻和艰难。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/p/5386f8e6.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/1d676992.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/1d676992.html" class="post-title-link" itemprop="url">Cocoapods创建私有podspec</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-31 15:39:15" itemprop="dateCreated datePublished" datetime="2018-10-31T15:39:15+08:00">2018-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>创建一个私有的podspec包括如下那么几个步骤：</p>
<ol>
<li>创建并设置一个私有的Spec Repo。</li>
<li>创建Pod的所需要的项目工程文件，并且有可访问的项目版本控制地址。</li>
<li>创建Pod所对应的podspec文件。</li>
<li>本地测试配置好的podspec文件是否可用。</li>
<li>向私有的Spec Repo中提交podspec。</li>
<li>在个人项目中的Podfile中增加刚刚制作的好的Pod并使用。</li>
<li>更新维护podspec。</li>
<li>创建私有Spec Repo</li>
</ol>
<p>先来说第一步，什么是Spec Repo？它是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，它实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的</p>
<ol>
<li>├── Specs</li>
<li>└── [SPEC_NAME]</li>
<li>└── [VERSION]</li>
<li>└── [SPEC_NAME].podspec</li>
</ol>
<p>因此我们需要创建一个类似于master的私有Spec Repo，可以fork官方的Repo</p>
<p>创建完成之后在Terminal中执行如下命令</p>
<ol>
<li>pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</li>
<li>pod repo add NewRepo <a href="http://github.com/newrepo/NewRepo.git" target="_blank" rel="noopener">http://github.com/newrepo/NewRepo.git</a></li>
</ol>
<p>此时如果成功的话进入到 <code>~/.cocoapods/repos</code> 目录下就可以看到 <code>NewRepo</code> 这个目录了。至此第一步创建私有 <code>Spec Repo</code> 完成。</p>
<p>PS：如果有其他合作人员共同使用这个私有 <code>Spec Repo</code> 的话在他有对应 <code>Git</code> 仓库的权限的前提下执行相同的命令添加这个 <code>Spec Repo</code> 即可。</p>
<p>创建 <code>Pod</code> 项目工程文件</p>
<p>创建新的组件项目，可以使用Using Pod Lib Create来创建项目</p>
<ol>
<li>$ pod lib create PodDemoLibrary</li>
</ol>
<p>之后四个问题，</p>
<ol>
<li>是否需要一个例子工程；</li>
<li>选择一个测试框架；</li>
<li>是否基于View测试；</li>
<li>类的前缀；</li>
</ol>
<p>具体介绍可以去看官方文档，我这里选择的是 1.yes；2.Specta/Expecta；3.yes；4.JD。 </p>
<p>问完这4个问题他会自动执行pod install命令创建项目并生成依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tree PodDemoLibrary -L 2</span><br><span class="line">PodDemoLibrary</span><br><span class="line">├── Example                                  #demo APP</span><br><span class="line">│   ├── PodDemoLibrary</span><br><span class="line">│   ├── PodDemoLibrary.xcodeproj</span><br><span class="line">│   ├── PodDemoLibrary.xcworkspace</span><br><span class="line">│   ├── Podfile                              #demo APP 的依赖描述文件</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods                                  #demo APP 的依赖文件</span><br><span class="line">│   └── Tests</span><br><span class="line">├── LICENSE                               #开源协议 默认MIT</span><br><span class="line">├── Pod                                       #组件的目录</span><br><span class="line">│   ├── Assets                            #资源文件</span><br><span class="line">│   └── Classes                              #类文件</span><br><span class="line">├── PodDemoLibrary.podspec           #第三步要创建的podspec文件</span><br><span class="line">└── README.md                                #markdown格式的README</span><br><span class="line">9 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>以上是项目生成的目录结构及相关介绍。</p>
<p>接下来就是向Pod文件夹中添加库文件和资源，并配置podspec文件，我把一个网络模块的组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/PodDemoLibrary中了，然后编辑demo工程，测试组件。</p>
<p>注：这里需要注意的是每当你向Pod中添加了新的文件或者以后更新了podspec的版本都需要重新执行一遍pod update命令。<br>测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。</p>
<p>通过Cocoapods创建出来的目录本身就在本地的Git管理下，我们需要做的就是给它添加远端仓库，同样去GitHub或其他的Git服务提供商那里创建一个私有的仓库，拿到SSH地址，然后cd到PodDemoLibrary目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;Initial Commit of Library&quot;</span><br><span class="line">$ git remote add origin &lt;git ssh url&gt;          #添加远端仓库</span><br><span class="line">$ git push origin master     #提交到远端仓库</span><br></pre></td></tr></table></figure>

<p>因为 <code>podspec</code> 文件中获取 <code>Git</code> 版本控制的项目还需要 <code>tag</code> 号，所以我们要打上一个 <code>tag</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &#39;0.1.0&#39;</span><br><span class="line">$ git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure>

<p>做完这些就可以开始编辑podspec文件了，它是一个Ruby的文件，把编辑器的格式改成Ruby就能看到语法高亮，下面我贴上我的podspec文件，并在后面以注释的形式说明每个字段的含义，没有涉及到的字段可以去官方文档查阅</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             &#x3D; &quot;PodDemoLibrary&quot;    #名称</span><br><span class="line">s.version          &#x3D; &quot;0.1.0&quot;             #版本号</span><br><span class="line">s.summary          &#x3D; &quot;Just Testing.&quot;     #简短介绍，下面是详细介绍</span><br><span class="line">s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">Testing Private Podspec.</span><br><span class="line">* Markdown format.</span><br><span class="line">* Don&#39;t worry about the indent, we strip it!</span><br><span class="line">DESC</span><br><span class="line">s.homepage         &#x3D; &quot;&lt;git project url&gt;&quot;                           #主页,这里要填写可以访问到的地址，不然验证不通过</span><br><span class="line"># s.screenshots     &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot;           #截图</span><br><span class="line">s.license          &#x3D; &#39;MIT&#39;              #开源协议</span><br><span class="line">s.author           &#x3D; &#123; &quot;abc&quot; &#x3D;&gt; &quot;abc@gmail.com&quot; &#125;                   #作者信息</span><br><span class="line">s.source           &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.git&quot;, :tag &#x3D;&gt; &quot;0.1.0&quot; &#125;      #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span><br><span class="line"># s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;twitter_username&gt;&#39;                       #多媒体介绍地址</span><br><span class="line">s.platform     &#x3D; :ios, &#39;8.0&#39;            #支持的平台及版本</span><br><span class="line">s.requires_arc &#x3D; true                   #是否使用ARC，如果指定具体文件，则具体的问题使用ARC</span><br><span class="line">s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39;     #代码源文件地址，**&#x2F;*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span><br><span class="line">s.resource_bundles &#x3D; &#123;</span><br><span class="line">&#39;PodDemoLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">&#125;                                       #资源文件地址</span><br><span class="line">s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39;   #公开头文件地址</span><br><span class="line">s.frameworks &#x3D; &#39;UIKit&#39;                  #所需的framework，多个用逗号隔开</span><br><span class="line">s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;   #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span><br><span class="line">end&lt;&#x2F;twitter_username&gt;</span><br></pre></td></tr></table></figure>

<p>编辑完podspec文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，验证需要执行一下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure>

<p>当你看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; PodDemoLibrary (0.1.0)</span><br><span class="line">PodDemoLibrary passed validation.</span><br></pre></td></tr></table></figure>

<p>时，说明验证通过了，不过这只是这个podspec文件是合格的，不一定说明这个Pod是可以用的，我们需要在本地做一下验证，这就是第四步的内容了，第四步在具体说明。</p>
<h2 id="创建podspec文件"><a href="#创建podspec文件" class="headerlink" title="创建podspec文件"></a>创建podspec文件</h2><p>如果从第二步过来，已经有了现成的项目，那么就需要给这个项目创建一个podspec文件，创建它需要执行Cocoapods的另外一个命令，官方文档在这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec create PodDemoLibrary git@github.com:abc&#x2F;PodDemoLibrary.git</span><br></pre></td></tr></table></figure>

<p>执行完之后，就创建了一个podspec文件，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure>

<p>验证无误就可以进入下一步了。</p>
<p>本地测试podspec文件</p>
<p>我们可以创建一个新的项目，在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。 在Podfile中我们可以这样编辑，有两种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;7.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, :path &#x3D;&gt; &#39;~&#x2F;code&#x2F;Cocoapods&#x2F;podTest&#x2F;PodDemoLibrary&#39;      #指定路径</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, :podspec &#x3D;&gt; &#39;~&#x2F;code&#x2F;Cocoapods&#x2F;podTest&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.podspec&#39;  #指定podspec文件</span><br></pre></td></tr></table></figure>

<p>然后执行pod install命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了，不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/PodDemoLibrary中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。</p>
<p>在项目中编写代码，测试库文件无误后就可以开始下一步了，提交podspec到Spec Repo中。</p>
<p>向Spec Repo提交podspec</p>
<p>向Spec Repo提交podspec需要完成两点一个是podspec必须通过验证无误，在一个就是删掉无用的注释（这个不是必须的，为了规范还是删掉吧）。</p>
<p>向我们的私有Spec Repo提交podspec只需要一个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push NewRepo PodDemoLibrary.podspec  #前面是本地Repo名字 后面是podspec名字</span><br></pre></td></tr></table></figure>

<p>完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/NewRepo目录下查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── PodDemoLibrary</span><br><span class="line">│   └── 0.1.0</span><br><span class="line">│       └── PodDemoLibrary.podspec</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被Push上去了。</p>
<p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pod search PodDemoLibrary</span><br><span class="line">-&gt; PodDemoLibrary (0.1.0)</span><br><span class="line">Just Testing.</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, &#39;~&gt; 0.1.0&#39;</span><br><span class="line">- Homepage: https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;PodDemoLibrary</span><br><span class="line">- Source:   https:&#x2F;&#x2F;github.com&#x2F;abc&#x2F;PodDemoLibrary.git</span><br><span class="line">- Versions: 0.1.0 [NewRepo repo]</span><br></pre></td></tr></table></figure>

<p>这里说的是添加到私有的Repo，如果要添加到Cocoapods的官方库了，可以使用trunk工具，具体可以查看官方文档。</p>
<h3 id="使用制作好的Pod"><a href="#使用制作好的Pod" class="headerlink" title="使用制作好的Pod"></a>使用制作好的Pod</h3><p>在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下代码即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#指出Pod源地址，否则只会在官方地址中寻找</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;newRepo&#x2F;NewRepo.git&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod &#39;PodDemoLibrary&#39;, &#39;~&gt; 0.1.0&#39;</span><br></pre></td></tr></table></figure>

<p>然后执行pod update，更新库依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。</p>
<h3 id="更新维护podspec"><a href="#更新维护podspec" class="headerlink" title="更新维护podspec"></a>更新维护podspec</h3><p>最后再来说一下制作好的podspec文件后续的更新维护工作，比如如何添加新的版本，如何删除Pod。</p>
<p>我已经制作好了PodDemoLibrary的0.1.0版本，现在我对他进行升级工作，这次我添加了更多的模块到PodDemoLibrary之中，包括工具类，底层Model及UIKit扩展等，这里又尝试了一下subspec功能，给PodDemoLibrary创建了多个子分支。</p>
<p>具体做法是先将源文件添加到Pod/Classes中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在Pod/Classes下有创建了四个子目录，完成之后继续编辑之前的PodDemoLibrary.podspec，这次增加了subspec特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             &#x3D; &quot;PodDemoLibrary&quot;</span><br><span class="line">s.version          &#x3D; &quot;1.0.0&quot;</span><br><span class="line">s.summary          &#x3D; &quot;Just Testing.&quot;</span><br><span class="line">s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">Testing Private Podspec.</span><br><span class="line">* Markdown format.</span><br><span class="line">* Don&#39;t worry about the indent, we strip it!</span><br><span class="line">DESC</span><br><span class="line">s.homepage         &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary&quot;</span><br><span class="line"># s.screenshots     &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot;</span><br><span class="line">s.license          &#x3D; &#39;MIT&#39;</span><br><span class="line">s.author           &#x3D; &#123; &quot;abc&quot; &#x3D;&gt; &quot;abc@gmail.com&quot; &#125;</span><br><span class="line">s.source           &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;PodDemoLibrary&#x2F;PodDemoLibrary.git&quot;, :tag &#x3D;&gt; &quot;1.0.0&quot; &#125;</span><br><span class="line"># s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;twitter_username&gt;&#39;</span><br><span class="line">s.platform     &#x3D; :ios, &#39;8.0&#39;</span><br><span class="line">s.requires_arc &#x3D; true</span><br><span class="line">#s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line">#s.resource_bundles &#x3D; &#123;</span><br><span class="line">#  &#39;PodDemoLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">#&#125;</span><br><span class="line">#s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">s.subspec &#39;NetWorkEngine&#39; do |networkEngine|</span><br><span class="line">networkEngine.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;NetworkEngine&#x2F;**&#x2F;*&#39;</span><br><span class="line">networkEngine.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;NetworkEngine&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">networkEngine.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;DataModel&#39; do |dataModel|</span><br><span class="line">dataModel.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;DataModel&#x2F;**&#x2F;*&#39;</span><br><span class="line">dataModel.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;DataModel&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;CommonTools&#39; do |commonTools|</span><br><span class="line">commonTools.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;CommonTools&#x2F;**&#x2F;*&#39;</span><br><span class="line">commonTools.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;CommonTools&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">commonTools.dependency &#39;OpenUDID&#39;, &#39;~&gt; 1.0.0&#39;</span><br><span class="line">end</span><br><span class="line">s.subspec &#39;UIKitAddition&#39; do |ui|</span><br><span class="line">ui.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;UIKitAddition&#x2F;**&#x2F;*&#39;</span><br><span class="line">ui.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;UIKitAddition&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">ui.resource &#x3D; &quot;Pod&#x2F;Assets&#x2F;MLSUIKitResource.bundle&quot;</span><br><span class="line">ui.dependency &#39;PodDemoLibrary&#x2F;CommonTools&#39;</span><br><span class="line">end</span><br><span class="line">s.frameworks &#x3D; &#39;UIKit&#39;</span><br><span class="line">#s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.1&#39;</span><br><span class="line">#s.dependency &#39;OpenUDID&#39;, &#39;~&gt; 1.0.0&#39;</span><br><span class="line">end&lt;&#x2F;twitter_username&gt;</span><br></pre></td></tr></table></figure>

<p>因为我们创建了subspec所以项目整体的依赖dependency，源文件source_files，头文件public_header_files，资源文件resource等都移动到了各自的subspec中，每个subspec之间也可以有相互的依赖关系，比如UIKitAddition就依赖于CommonTools。</p>
<p>编辑完成之后，在测试项目里pod update一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的tag-&gt;1.0.0。</p>
<p>最后再次使用pod lib lint验证编辑好的podsepc文件，没有自身的WARNING或者ERROR之后，就可以再次提交到Spec Repo中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo push NewRepo PodDemoLibrary.podspec</span><br></pre></td></tr></table></figure>

<p>之后再次到~/.cocoapods/repos/NewRepo目录下查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── PodDemoLibrary</span><br><span class="line">│   ├── 0.1.0</span><br><span class="line">│   │   └── PodDemoLibrary.podspec</span><br><span class="line">│   └── 1.0.0</span><br><span class="line">│       └── PodDemoLibrary.podspec</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>已经有两个版本了，使用pod search可以看到记录</p>
<p>完成这些之后，在实际项目中我们就可以选择使用整个组件库或者是组件库的某一个部分了，对应的Podfile中添加的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#x2F;NetWorkEngine&#39;, &#39;1.0.0&#39;  #使用某一个部分</span><br><span class="line">pod &#39;PodDemoLibrary&#x2F;UIKitAddition&#39;, &#39;1.0.0&#39;</span><br><span class="line">pod &#39;PodDemoLibrary&#39;, &#39;1.0.0&#39;   #使用整个库</span><br></pre></td></tr></table></figure>

<p>最后介绍一下如何删除一个私有Spec Repo，只需要执行一条命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo remove NewRepo</span><br></pre></td></tr></table></figure>

<p>这样这个Spec Repo就在本地删除了，我们还可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo add NewRepo git@github.com:abc&#x2F;NewRepo.git</span><br></pre></td></tr></table></figure>

<p>再把它给加回来。</p>
<p>如果我们要删除私有Spec Repo下的某一个podspec怎么操作呢，此时无需借助Cocoapods，只需要cd到~/.cocoapods/repos/NewRepo目录下，删掉库目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -Rf PodDemoLibrary</span><br></pre></td></tr></table></figure>

<p>然后在将Git的变动push到远端仓库即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all .</span><br><span class="line">$ git ci -m &quot;remove unuseful pods&quot;</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="noopener">使用Cocoapods创建私有podspec</a></p>
<p><a href="http://guides.cocoapods.org/making/private-cocoapods.html" target="_blank" rel="noopener">Private Pods</a></p>
<p><a href="http://blog.grio.com/2014/11/creating-a-private-cocoapod.html" target="_blank" rel="noopener">Creating a Private CocoaPod</a></p>
<p><a href="https://objectpartners.com/2014/06/25/developing-private-in-house-libraries-with-cocoapods/" target="_blank" rel="noopener">Developing Private In-House Libraries with CocoaPods</a></p>
<p><a href="https://www.jianshu.com/p/c94d394f0be7" target="_blank" rel="noopener">制作自己的cocoapods</a></p>
<p><a href="https://www.jianshu.com/p/1e5927eeb341" target="_blank" rel="noopener">Cocoapods使用私有库中遇到的坑</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/45fd89a7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/45fd89a7.html" class="post-title-link" itemprop="url">Realm-Swift使用入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-29 17:55:36" itemprop="dateCreated datePublished" datetime="2018-10-29T17:55:36+08:00">2018-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Realm适用iOS和Android平台，本身相比sqlite、CoreData操作简单，在这里记录下使用方式；<br>（Swift4.2）</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pod ‘RealmSwift’</code></p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>打开 Realm 数据库</p>
<p>要打开一个 Realm 数据库，首先需要初始化一个新的 Realm 对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let realm &#x3D; try! Realm()</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(myDog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将会初始化出一个默认 Realm 数据库。</p>
<h3 id="配置-Realm-数据库"><a href="#配置-Realm-数据库" class="headerlink" title="配置 Realm 数据库"></a>配置 Realm 数据库</h3><p>可配置本地 Realm 数据库在磁盘上的路径；</p>
<p>对于可同步 Realm 数据库而言，可以配置管理用户，以及服务器上的远程路径；</p>
<h3 id="配置版本迁移"><a href="#配置版本迁移" class="headerlink" title="配置版本迁移"></a>配置版本迁移</h3><p>压缩功能，高效地利用磁盘空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func setDefaultRealmForUser(username: String) &#123;</span><br><span class="line">    var config &#x3D; Realm.Configuration()</span><br><span class="line">    &#x2F;&#x2F; 使用默认的目录，但是请将文件名替换为用户名</span><br><span class="line">    config.fileURL &#x3D; config.fileURL!.deletingLastPathComponent().appendingPathComponent(&quot;\(username).realm&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将该配置设置为默认 Realm 配置</span><br><span class="line">    Realm.Configuration.defaultConfiguration &#x3D; config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作-Realm-对象"><a href="#操作-Realm-对象" class="headerlink" title="操作 Realm 对象"></a>操作 Realm 对象</h3><p>对象的自更新</p>
<p>Object 实例是底层数据的动态体现，会自动进行更新；因此这意味着无需去刷新对象的当前状态。修改某个对象的属性，会立即影响到所有指向该对象的其他实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let myDog &#x3D; Dog()</span><br><span class="line">myDog.name &#x3D; &quot;Fido&quot;</span><br><span class="line">myDog.age &#x3D; 1</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(myDog)</span><br><span class="line">&#125;</span><br><span class="line">let myPuppy &#x3D; realm.objects(Dog.self).filter(&quot;age &#x3D;&#x3D; 1&quot;).first</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    myPuppy!.age &#x3D; 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;age of my dog: \(myDog.age)&quot;) &#x2F;&#x2F; &#x3D;&gt; 2</span><br></pre></td></tr></table></figure>

<p>这不仅使得 Realm 保证高速和高效，同时还让代码更为简洁、更为灵活。如果您的 UI 代码基于某个特定的 Realm 对象来实现，那么在触发 UI 重绘以前，您根本无需进行数据刷新或者重新检索。</p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>对象的所有更改（添加、修改和删除）都必须在写入事务内完成。</p>
<p>Realm 对象可以被实例化，还可作为未管理对象使用（例如，还未添加到 Realm 数据库），并且使用方式与其它正常 Swift 对象无异。然而，如果要在线程之间共享对象，或者在应用启动后反复使用，那么您必须将这些对象添加到 Realm 数据库中。向 Realm 数据库中添加对象必须在写入事务内完成。由于写入事务将会产生无法忽略的性能消耗，因此您应当检视您的代码，以确保尽可能减少写入事务的数量。</p>
<p>warning：Realm 的写入操作是同步以及阻塞进行的，它并不会异步执行。如果线程 A 开始进行写入操作，然后线程 B 在线程 A 结束之前，对相同的 Realm 数据库也执行了写入操作，那么线程 A 必须要在线程 B 的写入操作发生之前，结束并提交其事务。写入事务会在 beginWrite() 执行时自动刷新，因此重复写入并不会产生竞争条件。</p>
<h3 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h3><p>Realm 提供了一系列更新对象的方法，根据使用场景的不同， 每个方法都有各自的优缺点。</p>
<h4 id="直接更新"><a href="#直接更新" class="headerlink" title="直接更新"></a>直接更新</h4><p>您可以在写入事务中，通过设置对象的属性从而完成更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在事务中更新对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    author.name &#x3D; &quot;Thomas Pynchon&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键值编码"><a href="#键值编码" class="headerlink" title="键值编码"></a>键值编码</h4><p>Object、Result 和 List 均允许使用 键值编码(KVC)。 当您需要在运行时决定何种属性需要进行更新的时候， 这个方法就非常有用了。<br>批量更新对象时，为集合实现 KVC 是一个很好的做法， 这样就不用承受遍历集合时为每个项目创建访问器 所带来的性能损耗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let persons &#x3D; realm.objects(Person.self)</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    persons.first?.setValue(true, forKeyPath: &quot;isFirst&quot;)</span><br><span class="line">    &#x2F;&#x2F; 将每个 person 对象的 planet 属性设置为 &quot;Earth&quot;</span><br><span class="line">    persons.setValue(&quot;Earth&quot;, forKeyPath: &quot;planet&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过主键更新"><a href="#通过主键更新" class="headerlink" title="通过主键更新"></a>通过主键更新</h4><p>如果数据模型类中包含了主键，那么 可以使用 Realm().add(_:update:)，从而让 Realm 基于主键来自动更新或者添加对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个 book 对象，其主键与之前存储的 book 对象相同</span><br><span class="line">let cheeseBook &#x3D; Book()</span><br><span class="line">cheeseBook.title &#x3D; &quot;Cheese recipes&quot;</span><br><span class="line">cheeseBook.price &#x3D; 9000</span><br><span class="line">cheeseBook.id &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; 更新这个 id &#x3D; 1 的 book</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(cheeseBook, update: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个主键值为 “1” 的 Book 对象已经存在于数据库当中 ，那么该对象只会进行更新。如果不存在的话， 那么一个全新的 Book 对象就会被创建出来，并被添加到数据库当中。</p>
<p>您可以通过传递一个子集，其中只包含打算更新的值， 从而对带有主键的对象进行部分更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设主键为 &#96;1&#96; 的 &quot;Book&quot; 对象已经存在</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Book.self, value: [&quot;id&quot;: 1, &quot;price&quot;: 9000.0], update: true)</span><br><span class="line">    &#x2F;&#x2F; book 对象的 &#96;title&#96; 属性仍旧保持不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有定义主键，那么最好不要对这类对象传递 update: true 参数。</p>
<p>请注意，对于可空属性 而言， 在更新对象的时候，nil 仍会被视为有效值。如果您提供了一个属性值存在 nil 的字典，那么这个设定会被应用到应用当中，并且这些属性值也会被清空。 为了确保不会出现意外的数据丢失， 在使用此方法之前请再三确认， 只提供了想要进行更新的属性值。</p>
<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><p>在写入事务中，将要删除的对象传递给 Realm().delete(_:) 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cheeseBook 存储在 Realm 数据库中</span><br><span class="line">&#x2F;&#x2F; 在事务中删除对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.delete(cheeseBook)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您同样也可以删除存储在 Realm 数据库当中的所有数据。请注意，Realm 文件会保留在磁盘上所占用的空间，从而为以后的对象预留足够的空间，从而实现快速存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从 Realm 数据库中删除所有对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.deleteAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询将会返回一个 Results 实例，其中包含了一组 Object 对象。Results 的接口与 Array 基本相同，并且可以使用索引下标来访问包含在 Results 当中的对象。与 Array 所不同的是，Results 只能持有一个 Object 子类类型。</p>
<p>所有的查询操作（包括检索和属性访问）在 Realm 中都是延迟加载的。只有当属性被访问时，数据才会被读取。</p>
<p>查询结果并不是数据的拷贝：（在写入事务中）修改查询结果会直接修改磁盘上的数据。与之类似，您可以从 Results 当中的 Object 来直接遍历关系图。</p>
<p>除非对结果进行了访问，否则查询的执行将会被推迟（Lazy）。这意味着 将多个临时 Results 关联在一起，然后对数据进行排序和条件检索的操作， 并不会执行中间状态处理之类的额外工作。</p>
<p>一旦执行了查询，或者添加了通知模块， 那么 Results 将时刻与 Realm 数据库当中的数据保持一致， 如有可能，会在后台线程中执行再一次查询操作。</p>
<p>从 Realm 数据库中检索对象的最基本方法是 Realm().objects(_:)，这个方法将会返回 Object 子类类型在默认 Realm 数据库当中的查询到的所有数据，并以 Results 实例的形式返回。</p>
<p><code>let dogs = realm.objects(Dog.self) // 从默认的 Realm 数据库中遍历所有 Dog 对象</code></p>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>如果您对 NSPredicate 有所了解的话，那么您就已经掌握了在 Realm 中进行查询的方法了。Objects、Realm、List 和 Results 均提供了相关的方法，从而只需传递 NSPredicate 实例、断言字符串、或者断言格式化字符串来查询特定的 Object 实例，这与对 NSArray 进行查询所类似。</p>
<p>例如，下面这个例子通过调用 Results().filter(_:…) 方法，从默认 Realm 数据库中遍历出所有棕黄色、名字以 “B” 开头的狗狗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用断言字符串来查询</span><br><span class="line">var tanDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39; AND name BEGINSWITH &#39;B&#39;&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 NSPredicate 来查询</span><br><span class="line">let predicate &#x3D; NSPredicate(format: &quot;color &#x3D; %@ AND name BEGINSWITH %@&quot;, &quot;tan&quot;, &quot;B&quot;)</span><br><span class="line">tanDogs &#x3D; realm.objects(Dog.self).filter(predicate)</span><br></pre></td></tr></table></figure>

<p>参见 Apple 的断言编程指南来获取更多关于构建断言的信息，此外还可以使用我们的 NSPredicate Cheatsheet。Realm 支持大多数常见的断言：</p>
<p>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</p>
<p>比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!= 和 BETWEEN 支持 Int、Int8、Int16、Int32、Int64、Float、Double 以及 Date 这几种属性类型，例如 age == 45；</p>
<p>比较是否相同：== 和 !=，例如，Results().filter(“company == %@”, company)；</p>
<p>比较操作符 == 和 != 支持布尔属性；</p>
<p>对于 String 和 Data 属性而言，支持使用 ==、!=、BEGINSWITH、CONTAINS 和 ENDSWITH 操作符，例如 name CONTAINS ‘Ja’；</p>
<p>对于 String 属性而言，LIKE 操作符可以用来比较左端属性和右端表达式：? 和 可用作通配符，其中 ? 可以匹配任意一个字符， 匹配 0 个及其以上的字符。例如：value LIKE ‘?bc*’ 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</p>
<p>字符串的比较忽略大小写，例如 name CONTAINS[c] ‘Ja’。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。[c] 修饰符可以与 [d] 修饰符结合使用；</p>
<p>字符串的比较忽略变音符号，例如 name BEGINSWITH[d] ‘e’ 能够匹配到 étoile。这个修饰符可以与 [c] 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见当前的限制一节来了解详细信息。）</p>
<p>Realm 支持以下组合操作符：“AND”、“OR” 和 “NOT”，例如 name BEGINSWITH ‘J’ AND age &gt;= 32；</p>
<p>包含操作符：IN，例如 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</p>
<p>空值比较：==、!=，例如 Results().filter(“ceo == nil”)。请注意，Realm 将 nil 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，nil 等同于自身；</p>
<p>ANY 比较，例如 ANY student.age &lt; 21；</p>
<p>List 和 Results 属性支持聚集表达式：@count、@min、@max、@sum 和 @avg，例如 realm.objects(Company.self).filter(“employees.@count &gt; 5”) 可用以检索所有拥有 5 名以上雇员的公司。</p>
<p>支持子查询，不过存在以下限制：</p>
<p>@count 是唯一一个能在 SUBQUERY 表达式当中使用的操作符；</p>
<p>SUBQUERY(…).@count 表达式只能与常量相比较；</p>
<p>目前仍不支持关联子查询。</p>
<p>参见 Results().filter(_:…)。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Results 允许您指定一个排序标准，然后基于关键路径、属性或者多个排序描述符来进行排序。例如，下列代码让上述示例中返回的 Dog 对象按名字进行升序排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对颜色为棕黄色、名字以 &quot;B&quot; 开头的狗狗进行排序</span><br><span class="line">let sortedDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39; AND name BEGINSWITH &#39;B&#39;&quot;).sorted(byKeyPath: &quot;name&quot;)</span><br></pre></td></tr></table></figure>

<p>关键路径同样也可以是某个多对一关系属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var name &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var dog: Dog?</span><br><span class="line">&#125;</span><br><span class="line">class Dog: Object &#123;</span><br><span class="line">    @objc dynamic var name &#x3D; &quot;&quot;</span><br><span class="line">    @objc dynamic var age &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dogOwners &#x3D; realm.objects(Person.self)</span><br><span class="line">let ownersByDogAge &#x3D; dogOwners.sorted(byKeyPath: &quot;dog.age&quot;)</span><br></pre></td></tr></table></figure>

<p>请注意，sorted(byKeyPath:) 和 sorted(byProperty:) 不支持 将多个属性用作排序基准，此外也无法链式排序（只有最后一个 sorted 调用会被使用）。 如果要对多个属性进行排序，请使用 sorted(by:)方法，然后向其中输入多个 SortDescriptor 对象。</p>
<p>欲了解更多信息，参见：</p>
<p>Results().sorted(_:)</p>
<p>Results().sorted(byKeyPath:ascending:)</p>
<p>注意，在对查询进行排序的时候，只能保证 Results 的次序不变。 出于性能考量，插入次序将无法保证。 如果您希望维护插入次序， 那么可以在这里查看解决方案。</p>
<h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。</p>
<p>如果您需要获取一个棕黄色狗狗的结果集，然后在此基础上再获取名字以 ‘B’ 开头的棕黄色狗狗，那么您可以像这样将这两个查询连接起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tanDogs &#x3D; realm.objects(Dog.self).filter(&quot;color &#x3D; &#39;tan&#39;&quot;)</span><br><span class="line">let tanDogsWithBNames &#x3D; tanDogs.filter(&quot;name BEGINSWITH &#39;B&#39;&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="结果的自更新"><a href="#结果的自更新" class="headerlink" title="结果的自更新"></a>结果的自更新</h3><p>Object 实例是底层数据的动态体现，其会自动进行更新，这意味着您无需去重新检索结果。它们会直接映射出 Realm 数据库在当前线程中的状态，包括当前线程上的写入事务。唯一的例外是，在使用 for…in 枚举时，它会将刚开始遍历时满足匹配条件的所有对象给遍历完，即使在遍历过程中有对象被过滤器修改或者删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let puppies &#x3D; realm.objects(Dog.self).filter(&quot;age &lt; 2&quot;)</span><br><span class="line">puppies.count &#x2F;&#x2F; &#x3D;&gt; 0</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Dog.self, value: [&quot;name&quot;: &quot;Fido&quot;, &quot;age&quot;: 1])</span><br><span class="line">&#125;</span><br><span class="line">puppies.count &#x2F;&#x2F; &#x3D;&gt; 1</span><br></pre></td></tr></table></figure>

<p>所有的 Results 对象均有此特性，无论是匹配查询出来的还是链式查询出来的。</p>
<p>Results 属性不仅让 Realm 数据库保证高速和高效，同时还让代码更为简洁、更加灵活。例如，如果视图控制器基于查询结果来实现，那么您可以将 Results 存储在属性当中，这样每次访问就不需要刷新以确保数据最新了。</p>
<p>您可以订阅 Realm 通知，以了解 Realm 数据何时发生了更新，比如说可以决定应用 UI 何时进行刷新，而无需重新检索 Results。<br>由于结果是自动更新的，因此不要迷信下标索引和总数会保持不变。Results 不变的唯一情况是在快速枚举的时候，这样就可以在枚举过程中，对匹配条件的对象进行修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try! realm.write &#123;</span><br><span class="line">    for person in realm.objects(Person.self).filter(&quot;age &#x3D;&#x3D; 10&quot;) &#123;</span><br><span class="line">        person.age +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以使用键值编码 来对 Results 执行相关操作。</p>
<h3 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h3><p>大多数其他数据库技术都提供了从检索中对结果进行“分页”的能力（例如 SQLite 中的 “LIMIT” 关键字）。这通常是很有必要的，可以避免一次性从硬盘中读取太多的数据，或者将太多查询结果加载到内存当中。</p>
<p>由于 Realm 中的检索是惰性的，因此这行这种分页行为是没有必要的。因为 Realm 只会在检索到的结果被明确访问时，才会从其中加载对象。</p>
<p>如果由于 UI 相关或者其他代码实现相关的原因导致您需要从检索中获取一个特定的对象子集，这和获取 Results 对象一样简单，只需要读出您所需要的对象即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 循环读取出前 5 个 Dog 对象</span><br><span class="line">&#x2F;&#x2F; 从而限制从磁盘中读取的对象数量</span><br><span class="line">let dogs &#x3D; try! Realm().objects(Dog.self)</span><br><span class="line">for i in 0..&lt;5 &#123;&#x3D;&quot;&quot; let&#x3D;&quot;&quot; dog&#x3D;&quot;dogs[i]&quot; ...&#x3D;&quot;&quot; &#125;&#x3D;&quot;&quot; &lt;&#x3D;&quot;&quot; code&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="本地迁移"><a href="#本地迁移" class="headerlink" title="本地迁移"></a>本地迁移</h3><p>通过设置 Realm.Configuration.schemaVersion 以及 Realm.Configuration.migrationBlock 可以定义本地迁移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">let config &#x3D; Realm.Configuration(</span><br><span class="line">    &#x2F;&#x2F; 设置新的架构版本。必须大于之前所使用的</span><br><span class="line">    &#x2F;&#x2F; （如果之前从未设置过架构版本，那么当前的架构版本为 0）</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置模块，如果 Realm 的架构版本低于上面所定义的版本，</span><br><span class="line">    &#x2F;&#x2F; 那么这段代码就会自动调用</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        &#x2F;&#x2F; 我们目前还未执行过迁移，因此 oldSchemaVersion &#x3D;&#x3D; 0</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有什么要做的！</span><br><span class="line">            &#x2F;&#x2F; Realm 会自行检测新增和被移除的属性</span><br><span class="line">            &#x2F;&#x2F; 然后会自动更新磁盘上的架构</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通知 Realm 为默认的 Realm 数据库使用这个新的配置对象</span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; config</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 现在我们已经通知了 Realm 如何处理架构变化，</span><br><span class="line">&#x2F;&#x2F; 打开文件将会自动执行迁移</span><br><span class="line">let realm &#x3D; try! Realm()</span><br></pre></td></tr></table></figure>

<h2 id="值的更新"><a href="#值的更新" class="headerlink" title="值的更新"></a>值的更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; Realm.Configuration(</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; enumerateObjects(ofType:_:) 方法将会遍历</span><br><span class="line">            &#x2F;&#x2F; 所有存储在 Realm 文件当中的 &#96;Person&#96; 对象</span><br><span class="line">            migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in</span><br><span class="line">                &#x2F;&#x2F; 将两个 name 合并到 fullName 当中</span><br><span class="line">                let firstName &#x3D; oldObject![&quot;firstName&quot;] as! String</span><br><span class="line">                let lastName &#x3D; oldObject![&quot;lastName&quot;] as! String</span><br><span class="line">                newObject![&quot;fullName&quot;] &#x3D; &quot;\(firstName) \(lastName)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span><br><span class="line"></span><br><span class="line">Realm.Configuration.defaultConfiguration &#x3D; Realm.Configuration(</span><br><span class="line">    schemaVersion: 1,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">        &#x2F;&#x2F; 我们目前还未执行过迁移，因此 oldSchemaVersion &#x3D;&#x3D; 0</span><br><span class="line">        if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 重命名操作必须要在 &#96;enumerateObjects(ofType: _:)&#96; 调用之外进行</span><br><span class="line">            migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>当整个 Realm 数据库发生变化时，就会发送 Realm 通知；如果只有个别对象被修改、添加或者删除，那么就会发送集合通知。</p>
<p>通知只会在最初所注册的注册的线程中传递，并且该线程必须拥有一个正在运行的 Run Loop</p>
<p>Realm 通知</p>
<p>通知处理模块可以对整个 Realm 数据库进行注册。每次涉及到 Realm 的写入事务提交之后，无论写入事务发生在哪个线程还是进程中，通知处理模块都会被激活：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 Realm 通知</span><br><span class="line">let token &#x3D; realm.observe &#123; notification, realm in</span><br><span class="line">    viewController.updateUI()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 随后</span><br><span class="line">token.invalidate()</span><br></pre></td></tr></table></figure>

<h3 id="集合通知"><a href="#集合通知" class="headerlink" title="集合通知"></a>集合通知</h3><p>可以通过传递到通知模块当中的 RealmCollectionChange 参数来访问这些变更。该对象存放了受删除 (deletions)、插入 (insertions) 以及修改 (modifications) 所影响的索引信息。</p>
<h3 id="对象通知"><a href="#对象通知" class="headerlink" title="对象通知"></a>对象通知</h3><p>Realm 支持对象级别的通知。可以在特定的 Realm 对象上进行通知的注册，对象被删除、修改时获取相应的通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class StepCounter: Object &#123;</span><br><span class="line">    @objc dynamic var steps &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stepCounter &#x3D; StepCounter()</span><br><span class="line">let realm &#x3D; try! Realm()</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(stepCounter)</span><br><span class="line">&#125;</span><br><span class="line">var token : NotificationToken?</span><br><span class="line">token &#x3D; stepCounter.observe &#123; change in</span><br><span class="line">    switch change &#123;</span><br><span class="line">    case .change(let properties):</span><br><span class="line">        for property in properties &#123;</span><br><span class="line">            if property.name &#x3D;&#x3D; &quot;steps&quot; &amp;&amp; property.newValue as! Int &gt; 1000 &#123;</span><br><span class="line">                print(&quot;Congratulations, you&#39;ve exceeded 1000 steps.&quot;)</span><br><span class="line">                token &#x3D; nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;An error occurred: \(error)&quot;)</span><br><span class="line">    case .deleted:</span><br><span class="line">        print(&quot;The object was deleted.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跨线程使用-Realm-数据库"><a href="#跨线程使用-Realm-数据库" class="headerlink" title="跨线程使用 Realm 数据库"></a>跨线程使用 Realm 数据库</h2><p>在不同的线程中使用同一个 Realm 文件，必须每一个线程初始化一个新的Realm 实例。</p>
<p>不支持跨线程共享Realm 实例。Realm 实例要访问相同的 Realm 文件还必须使用相同的 Realm.Configuration。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Realm 没有提供对 JSON 的直接支持，可以使用 NSJSONSerialization.JSONObjectWithData(_:options:) 的输出</p>
<h2 id="常见限制"><a href="#常见限制" class="headerlink" title="常见限制"></a>常见限制</h2><p>Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如：</p>
<p>类名称的长度最大只能存储 57 个 UTF8 字符。</p>
<p>属性名称的长度最大只能支持 63 个 UTF8 字符。</p>
<p>Data 和 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。</p>
<p>每个单独的 Realm 文件大小无法超过应用在 iOS 系统中所被允许使用的内存量——这个量对于每个设备而言都是不同的，并且还取决于当时内存空间的碎片化情况(关于此问题有一个相关的 Radar：rdar://17119975)。如果您需要存储海量数据的话，那么可以选择使用多个 Realm 文件并进行映射。</p>
<p>对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>尽管 Realm 文件可以被多个线程同时访问，但是您不能直接跨线程传递 Realms、Realm 对象、查询和查询结果。如果您需要跨线程传递 Realm 对象的话，您可以使用 ThreadSafeReference API。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Setter 和 Getter：因为 Realm 在底层数据库中重写了 setters 和 getters 方法，所以您不可以在您的对象上再对其进行重写。一个简单的替代方法就是：创建一个新的 Realm 忽略属性，该属性的访问起可以被重写， 并且可以调用其他的 getter 和 setter 方法。</p>
<p>自动增长属性：Realm 没有线程且进程安全的自动增长属性机制，而这在其他数据库中常常用来产生主键。然而，在绝大多数情况下，对于主键来说，我们需要的是一个唯一的、自动生成的值，因此没有必要使用顺序的、连续的、整数的 ID 作为主键，因此一个独一无二的字符串主键通常就能满足需求了。一个常见的模式是将默认的属性值设置为 NSUUID().UUIDString 以产生一个唯一的字符串 ID。</p>
<p>自动增长属性另一种常见的动机是为了维持插入之后的顺序。在某些情况下，这可以通过向某个 List中添加对象，或者使用 NSDate() 默认值的 createdAt 属性。</p>
<p>Objective-C 中的属性：如果您需要在 Objective‑C 中访问 Realm Swift 模型的话，那么注意所有 List以及 RealmOptional 属性都不可用（就像其他 Swift 独有的数据类型一样）——如果有必要的话，您可以添加封装的 getter 和 setter 方法，将其在 NSNumber 或者 NSArray 之间进行转化。此外，早于 Xcode 7 Beta 5 之前的版本有一个 已知的Swift bug，它会导致自动生成的 Objective‑C 头文件（-Swift.h）无法通过编译。您就必须将 List 类型的属性设置为 private 或者 internal。请前往 GitHub issue #1925了解更多信息。</p>
<p>Object 子类的自定义构造器：当您创建 Object 子类模型的时候，您或许会想要添加自己的构造器方法，以便增加便利性。</p>
<p>由于 Swift 内省机制中现有的一些限制，我们不能给这个类中添加指定构造器(designated initializer)。相反，它们需要被标记为便利构造器(convenience initializer)，使用相同名字的 Swift 关键词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyModel: Object &#123;</span><br><span class="line">    @objc dynamic var myValue &#x3D; &quot;&quot;</span><br><span class="line">    convenience init(myValue: String) &#123;</span><br><span class="line">        self.init() &#x2F;&#x2F; 请注意这里使用的是 &#39;self&#39; 而不是 &#39;super&#39;</span><br><span class="line">        self.myValue &#x3D; myValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/fa3fafc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/fa3fafc.html" class="post-title-link" itemprop="url">What Remains of Edith Finch - Home</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-23 19:04:46" itemprop="dateCreated datePublished" datetime="2018-09-23T19:04:46+08:00">2018-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="伊迪丝·芬奇的记忆"><a href="#伊迪丝·芬奇的记忆" class="headerlink" title="伊迪丝·芬奇的记忆"></a>伊迪丝·芬奇的记忆</h1><p><img src="/imags/blog_edith_finch_home.png" alt=""></p>
<p>死亡并不是逝者一个人的事，它还会给活下来的人心中留下些东西，是阴影还是阳光，则取决于我们如何看它。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/p/fa3fafc.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/6c2e93eb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/6c2e93eb.html" class="post-title-link" itemprop="url">Git 常用命令速查表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-31 16:46:42" itemprop="dateCreated datePublished" datetime="2018-08-31T16:46:42+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git add</td>
<td>添加至暂存区</td>
</tr>
<tr>
<td>git add–interactive</td>
<td>交互式添加</td>
</tr>
<tr>
<td>git apply</td>
<td>应用补丁</td>
</tr>
<tr>
<td>git am</td>
<td>应用邮件格式补丁</td>
</tr>
<tr>
<td>git annotate</td>
<td>等同于 git blame</td>
</tr>
<tr>
<td>git archive</td>
<td>文件归档打包</td>
</tr>
<tr>
<td>git bisect</td>
<td>二分查找</td>
</tr>
<tr>
<td>git blame</td>
<td>文件逐行追溯</td>
</tr>
<tr>
<td>git branch</td>
<td>分支管理</td>
</tr>
<tr>
<td>git cat-file</td>
<td>版本库对象研究工具</td>
</tr>
<tr>
<td>git checkout</td>
<td>检出到工作区、切换或创建分支</td>
</tr>
<tr>
<td>git cherry-pick</td>
<td>提交拣选</td>
</tr>
<tr>
<td>git citool</td>
<td>图形化提交，相当于 git gui 命令</td>
</tr>
<tr>
<td>git clean</td>
<td>清除工作区未跟踪文件</td>
</tr>
<tr>
<td>git clone</td>
<td>克隆版本库</td>
</tr>
<tr>
<td>git commit</td>
<td>提交</td>
</tr>
<tr>
<td>git config</td>
<td>查询和修改配置</td>
</tr>
<tr>
<td>git describe</td>
<td>通过里程碑直观地显示提交ID</td>
</tr>
<tr>
<td>git diff</td>
<td>差异比较</td>
</tr>
<tr>
<td>git difftool</td>
<td>调用图形化差异比较工具</td>
</tr>
<tr>
<td>git fetch</td>
<td>获取远程版本库的提交</td>
</tr>
<tr>
<td>git format-patch</td>
<td>创建邮件格式的补丁文件。参见 git am 命令</td>
</tr>
<tr>
<td>git grep</td>
<td>文件内容搜索定位工具</td>
</tr>
<tr>
<td>git gui</td>
<td>基于Tcl/Tk的图形化工具，侧重提交等操作</td>
</tr>
<tr>
<td>git help</td>
<td>帮助</td>
</tr>
<tr>
<td>git init</td>
<td>版本库初始化</td>
</tr>
<tr>
<td>git init-db*</td>
<td>等同于 git init</td>
</tr>
<tr>
<td>git log</td>
<td>显示提交日志</td>
</tr>
<tr>
<td>git merge</td>
<td>分支合并</td>
</tr>
<tr>
<td>git mergetool</td>
<td>图形化冲突解决</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名</td>
</tr>
<tr>
<td>git pull</td>
<td>拉回远程版本库的提交</td>
</tr>
<tr>
<td>git push</td>
<td>推送至远程版本库</td>
</tr>
<tr>
<td>git rebase</td>
<td>分支变基</td>
</tr>
<tr>
<td>git rebase–interactive</td>
<td>交互式分支变基</td>
</tr>
<tr>
<td>git reflog</td>
<td>分支等引用变更记录管理</td>
</tr>
<tr>
<td>git remote</td>
<td>远程版本库管理</td>
</tr>
<tr>
<td>git repo-config*</td>
<td>同于 git config</td>
</tr>
<tr>
<td>git reset</td>
<td>重置改变分支“游标”指向</td>
</tr>
<tr>
<td>git rev-parse</td>
<td>将各种引用表示法转换为哈希值等</td>
</tr>
<tr>
<td>git revert</td>
<td>反转提交</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>git show</td>
<td>显示各种类型的对象</td>
</tr>
<tr>
<td>git stage*</td>
<td>等同于 git add</td>
</tr>
<tr>
<td>git stash</td>
<td>保存和恢复进度</td>
</tr>
<tr>
<td>git status</td>
<td>显示工作区文件状态</td>
</tr>
<tr>
<td>git tag</td>
<td>里程碑管理</td>
</tr>
</tbody></table>
<h2 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git commit-tree</td>
<td>从树对象创建提交</td>
</tr>
<tr>
<td>git hash-object</td>
<td>从标准输入或文件计算哈希值或创建对象</td>
</tr>
<tr>
<td>git ls-files</td>
<td>显示工作区和暂存区文件</td>
</tr>
<tr>
<td>git ls-tree</td>
<td>显示树对象包含的文件</td>
</tr>
<tr>
<td>git mktag</td>
<td>读取标准输入创建一个里程碑对象</td>
</tr>
<tr>
<td>git mktree</td>
<td>读取标准输入创建一个树对象</td>
</tr>
<tr>
<td>git read-tree</td>
<td>读取树对象到暂存区</td>
</tr>
<tr>
<td>git update-index</td>
<td>工作区内容注册到暂存区及暂存区管理</td>
</tr>
<tr>
<td>git unpack-file</td>
<td>创建临时文件包含指定 blob 的内容</td>
</tr>
<tr>
<td>git write-tree</td>
<td>从暂存区创建一个树对象</td>
</tr>
</tbody></table>
<h2 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git check-ref-format</td>
<td>检查引用名称是否符合规范</td>
</tr>
<tr>
<td>git for-each-ref</td>
<td>引用迭代器，用于shell编程</td>
</tr>
<tr>
<td>git ls-remote</td>
<td>显示远程版本库的引用</td>
</tr>
<tr>
<td>git name-rev</td>
<td>将提交ID显示为友好名称</td>
</tr>
<tr>
<td>git rev-list</td>
<td>显示版本范围</td>
</tr>
<tr>
<td>git show-branch</td>
<td>显示分支列表及拓扑关系</td>
</tr>
<tr>
<td>git show-ref</td>
<td>显示本地引用</td>
</tr>
<tr>
<td>git symbolic-ref</td>
<td>显示或者设置符号引用</td>
</tr>
<tr>
<td>git update-ref</td>
<td>更新引用的指向</td>
</tr>
<tr>
<td>git verify-tag</td>
<td>校验 GPG 签名的Tag</td>
</tr>
</tbody></table>
<h2 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git count-objects</td>
<td>显示松散对象的数量和磁盘占用</td>
</tr>
<tr>
<td>git filter-branch</td>
<td>版本库重构</td>
</tr>
<tr>
<td>git fsck</td>
<td>对象库完整性检查</td>
</tr>
<tr>
<td>git gc</td>
<td>版本库存储优化</td>
</tr>
<tr>
<td>git index-pack</td>
<td>从打包文件创建对应的索引文件</td>
</tr>
<tr>
<td>git pack-objects</td>
<td>从标准输入读入对象ID，打包到文件</td>
</tr>
<tr>
<td>git pack-redundant</td>
<td>查找多余的 pack 文件</td>
</tr>
<tr>
<td>git pack-refs</td>
<td>将引用打包到 .git/packed-refs 文件中</td>
</tr>
<tr>
<td>git prune</td>
<td>从对象库删除过期对象</td>
</tr>
<tr>
<td>git prune-packed</td>
<td>将已经打包的松散对象删除</td>
</tr>
<tr>
<td>git relink</td>
<td>为本地版本库中相同的对象建立硬连接</td>
</tr>
<tr>
<td>git repack</td>
<td>将版本库未打包的松散对象打包</td>
</tr>
<tr>
<td>git show-index</td>
<td>读取包的索引文件，显示打包文件中的内容</td>
</tr>
<tr>
<td>git unpack-objects</td>
<td>从打包文件释放文件</td>
</tr>
<tr>
<td>git verify-pack</td>
<td>校验对象库打包文件</td>
</tr>
</tbody></table>
<h2 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git fetch-pack</td>
<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>
</tr>
<tr>
<td>git receive-pack</td>
<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>
</tr>
<tr>
<td>git send-pack</td>
<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>
</tr>
<tr>
<td>git upload-archive</td>
<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>
</tr>
<tr>
<td>git upload-pack</td>
<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>
</tr>
</tbody></table>
<h2 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git imap-send</td>
<td>将补丁通过 IMAP 发送</td>
</tr>
<tr>
<td>git mailinfo</td>
<td>从邮件导出提交说明和补丁</td>
</tr>
<tr>
<td>git mailsplit</td>
<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>
</tr>
<tr>
<td>git request-pull</td>
<td>创建包含提交间差异和执行PULL操作地址的信息</td>
</tr>
<tr>
<td>git send-email</td>
<td>发送邮件</td>
</tr>
</tbody></table>
<h2 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git daemon</td>
<td>实现Git协议</td>
</tr>
<tr>
<td>git http-backend</td>
<td>实现HTTP协议的CGI程序，支持智能HTTP协议</td>
</tr>
<tr>
<td>git instaweb</td>
<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>
</tr>
<tr>
<td>git shell</td>
<td>受限制的shell，提供仅执行Git命令的SSH访问</td>
</tr>
<tr>
<td>git update-server-info</td>
<td>更新哑协议需要的辅助文件</td>
</tr>
<tr>
<td>git http-fetch</td>
<td>通过HTTP协议获取版本库</td>
</tr>
<tr>
<td>git http-push</td>
<td>通过HTTP/DAV协议推送</td>
</tr>
<tr>
<td>git remote-ext</td>
<td>由Git命令调用，通过外部命令提供扩展协议支持</td>
</tr>
<tr>
<td>git remote-fd</td>
<td>由Git命令调用，使用文件描述符作为协议接口</td>
</tr>
<tr>
<td>git remote-ftp</td>
<td>由Git命令调用，提供对FTP协议的支持</td>
</tr>
<tr>
<td>git remote-ftps</td>
<td>由Git命令调用，提供对FTPS协议的支持</td>
</tr>
<tr>
<td>git remote-http</td>
<td>由Git命令调用，提供对HTTP协议的支持</td>
</tr>
<tr>
<td>git remote-https</td>
<td>由Git命令调用，提供对HTTPS协议的支持</td>
</tr>
<tr>
<td>git remote-testgit</td>
<td>协议扩展示例脚本</td>
</tr>
</tbody></table>
<h2 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git archimport</td>
<td>导入Arch版本库到Git</td>
</tr>
<tr>
<td>git bundle</td>
<td>提交打包和解包，以便在不同版本库间传递</td>
</tr>
<tr>
<td>git cvsexportcommit</td>
<td>将Git的一个提交作为一个CVS检出</td>
</tr>
<tr>
<td>git cvsimport</td>
<td>导入CVS版本库到Git。或者使用 cvs2git</td>
</tr>
<tr>
<td>git cvsserver</td>
<td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td>
</tr>
<tr>
<td>git fast-export</td>
<td>将提交导出为 git-fast-import 格式</td>
</tr>
<tr>
<td>git fast-import</td>
<td>其他版本库迁移至Git的通用工具</td>
</tr>
<tr>
<td>git svn</td>
<td>Git 作为前端操作 Subversion</td>
</tr>
</tbody></table>
<h2 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git merge-base</td>
<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>
</tr>
<tr>
<td>git merge-file</td>
<td>针对文件的两个不同版本执行三向文件合并</td>
</tr>
<tr>
<td>git merge-index</td>
<td>对index中的冲突文件调用指定的冲突解决工具</td>
</tr>
<tr>
<td>git merge-octopus</td>
<td>合并两个以上分支。参见 git merge 的octopus合并策略</td>
</tr>
<tr>
<td>git merge-one-file</td>
<td>由 git merge-index 调用的标准辅助程序</td>
</tr>
<tr>
<td>git merge-ours</td>
<td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td>
</tr>
<tr>
<td>git merge-recursive</td>
<td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td>
</tr>
<tr>
<td>git merge-resolve</td>
<td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td>
</tr>
<tr>
<td>git merge-subtree</td>
<td>子树合并。参见 git merge 的 subtree 合并策略</td>
</tr>
<tr>
<td>git merge-tree</td>
<td>显式三向合并结果，不改变暂存区</td>
</tr>
<tr>
<td>git fmt-merge-msg</td>
<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>
</tr>
<tr>
<td>git rerere</td>
<td>重用所记录的冲突解决方案</td>
</tr>
</tbody></table>
<h2 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git bisect–helper</td>
<td>由 git bisect 命令调用，确认二分查找进度</td>
</tr>
<tr>
<td>git check-attr</td>
<td>显示某个文件是否设置了某个属性</td>
</tr>
<tr>
<td>git checkout-index</td>
<td>从暂存区拷贝文件至工作区</td>
</tr>
<tr>
<td>git cherry</td>
<td>查找没有合并到上游的提交</td>
</tr>
<tr>
<td>git diff-files</td>
<td>比较暂存区和工作区，相当于 git diff –raw</td>
</tr>
<tr>
<td>git diff-index</td>
<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>
</tr>
<tr>
<td>git diff-tree</td>
<td>比较两个树对象，相当于 git diff –raw A B</td>
</tr>
<tr>
<td>git difftool–helper</td>
<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>
</tr>
<tr>
<td>git get-tar-commit-id</td>
<td>从 git archive 创建的 tar 包中提取提交ID</td>
</tr>
<tr>
<td>git gui–askpass</td>
<td>命令 git gui 的获取用户口令输入界面</td>
</tr>
<tr>
<td>git notes</td>
<td>提交评论管理</td>
</tr>
<tr>
<td>git patch-id</td>
<td>补丁过滤行号和空白字符后生成补丁唯一ID</td>
</tr>
<tr>
<td>git quiltimport</td>
<td>将Quilt补丁列表应用到当前分支</td>
</tr>
<tr>
<td>git replace</td>
<td>提交替换</td>
</tr>
<tr>
<td>git shortlog</td>
<td>对 git log 的汇总输出，适合于产品发布说明</td>
</tr>
<tr>
<td>git stripspace</td>
<td>删除空行，供其他脚本调用</td>
</tr>
<tr>
<td>git submodule</td>
<td>子模组管理</td>
</tr>
<tr>
<td>git var</td>
<td>显示 Git 环境变量</td>
</tr>
<tr>
<td>git web–browse</td>
<td>启动浏览器以查看目录或文件</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>显示提交历史及每次提交的改动</td>
</tr>
<tr>
<td>git-mergetool–lib</td>
<td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td>
</tr>
<tr>
<td>git-parse-remote</td>
<td>包含于其他脚本中，提供操作远程版本库的函数</td>
</tr>
<tr>
<td>git-sh-setup</td>
<td>包含于其他脚本中，提供 shell 编程的函数库</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/c6cc69a1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/c6cc69a1.html" class="post-title-link" itemprop="url">iOS WKWebView适配iOS8支持网页宽度自适应</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-22 12:21:39" itemprop="dateCreated datePublished" datetime="2018-08-22T12:21:39+08:00">2018-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>iOS在iOS8推出基于WebKit的WKWebView显示网页、富文本内容，相比UIWebView在速度、内容消耗上有了很大的提升，但WKWebView也埋下了不少坑，最近碰到一个iOS8独享bug，iOS8上，网页宽度自适应失效，内容强制显示屏幕宽度，而不是WKWebView的宽度，主要是标签的支持问题，在此记录下解决方案，希望iOS8不再是开发者的痛；（ps：iOS12都快出了，iOS8还想走多远 ==）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *jScript &#x3D; @&quot;var meta &#x3D; document.createElement(&#39;meta&#39;); meta.setAttribute(&#39;name&#39;, &#39;viewport&#39;); meta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width&#39;); document.getElementsByTagName(&#39;head&#39;)[0].appendChild(meta);&quot;;</span><br><span class="line">            </span><br><span class="line">WKUserScript *wkUScript &#x3D; [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</span><br><span class="line">WKUserContentController *wkUController &#x3D; [[WKUserContentController alloc] init];</span><br><span class="line">wkUController addUserScript:wkUScript];</span><br><span class="line">Configuration.userContentController &#x3D; wkUController;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/ae1b8e69.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/ae1b8e69.html" class="post-title-link" itemprop="url">iOS 对应window旋转事件的响应和传递</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-07 12:01:21" itemprop="dateCreated datePublished" datetime="2018-08-07T12:01:21+08:00">2018-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="iOS-8-横竖屏不响应"><a href="#iOS-8-横竖屏不响应" class="headerlink" title="iOS 8 横竖屏不响应"></a>iOS 8 横竖屏不响应</h2><p>自定义appDelegate的window与main.storyboard 对屏幕旋转事件的响应冲突</p>
<p>在开启了横竖屏支持后，状态栏跟随变化但界面没触发旋转，在查找资料后发现，iOS设备的旋转事件会被window响应，通过window的rootViewController控制状态，window 上的view会发生旋转，而项目中ViewController是作为自定义window，需要在TabbarViewController、NavigationViewController、ViewController中传递控制。</p>
<p>但是！！！</p>
<p>在项目新建时，系统会自动创建main.storyboard，它也是携带window，如果没有删除main.storyboard，window响应会冲突，在iOS8上，自定义window的旋转事件不会响应！</p>
<p>解决方案：删除main.storyboard，将自定义window设置为KeyAndVisible，clear 项目，重启Xcode</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/p/ae1b8e69.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/ad66c3e1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/ad66c3e1.html" class="post-title-link" itemprop="url">思考的深度：我为什么写作?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-01 15:13:37" itemprop="dateCreated datePublished" datetime="2018-08-01T15:13:37+08:00">2018-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>写作就是思考。</p>
<p>想法来得太快，而我的灵魂跟不上，</p>
<p>2018年，有太多故事、太多新闻、太多大事件，在这些刺激中，有种种想法萌生，但大多数的想法总是突然出现由转瞬离去，让我没有时间去思考这些想法，回忆中，经历过不少事情，又好像没经历过什么的真实感，不禁觉得是在梦中。</p>
<p>把想法提取出来，解刨它、观察它、分析它、刺激它、淬炼它</p>
<p>写作，一方面是记录，记录当时自己的想法，人的记忆太不靠谱，不如让文字来记忆。<br>另一方面，在写作的过程中，想法具备了形态，就想人出生到时，每一个文字都是它的形象，正篇文章则是它的全貌，把想法提取出来，解刨它、观察它、分析它、刺激它、淬炼它，这就是思考</p>
<p>看清自己、看清世界</p>
<p>写作就是想慢下来，让自己能看清自己、看清世界。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/274e32fc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/274e32fc.html" class="post-title-link" itemprop="url">IT 终端代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-31 18:25:28" itemprop="dateCreated datePublished" datetime="2018-07-31T18:25:28+08:00">2018-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有一种痛苦叫网络很慢。。。</p>
<p>通过Github pull或push代码是程序员常有的操作，但在不可描述的因素下，有时糟糕的网络很考验程序员的心性，在此介绍下两种终端代理方式：</p>
<h2 id="设置Git请求代理"><a href="#设置Git请求代理" class="headerlink" title="设置Git请求代理"></a>设置Git请求代理</h2><h3 id="1、通过设置git请求代码"><a href="#1、通过设置git请求代码" class="headerlink" title="1、通过设置git请求代码"></a>1、通过设置git请求代码</h3><p><code>git config --global http.https://github.com.proxy &#39;socks5://127.0.0.1:1080&#39;</code></p>
<p>这种做法可以实现push和pull都走用户的代理通道，这里我指向的是我的SSR</p>
<p>取消方式去下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="2、通过ProxyChains-NG实现终端下任意应用代理"><a href="#2、通过ProxyChains-NG实现终端下任意应用代理" class="headerlink" title="2、通过ProxyChains-NG实现终端下任意应用代理"></a>2、通过ProxyChains-NG实现终端下任意应用代理</h3><p>什么是 proxychains-ng</p>
<p>主页：<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a></p>
<p><strong>proxychains-ng 介绍</strong></p>
<p>proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.</p>
<p>proxychains-ng是proxychains的加强版，主要有以下功能和不足：</p>
<ul>
<li>支持http/https/socks4/socks5</li>
<li>支持认证</li>
<li>远端dns查询</li>
<li>多种代理模式</li>
<li>不支持udp/icmp转发</li>
<li>少部分程序和在后台运行的可能无法代理</li>
</ul>
<p><strong>proxychains-ng 原理</strong></p>
<p>简单的说就是这个程序 Hook 了 sockets 相关的操作，让普通程序的 sockets 数据走 SOCKS/HTTP 代理。</p>
<p>其核心就是利用了 LD_PRELOAD 这个环境变量（Mac 上是 DYLD_INSERT_LIBRARIES）。</p>
<p>在 Unix 系统中，如果设置了 LD_PRELOAD 环境变量，那么在程序运行时，动态链接器会先加载该环境变量所指定的动态库。也就是说，这个动态库的加载优先于任何其它的库，包括 libc。</p>
<p>ProxyChains 创建了一个叫 libproxychains4.so（Mac 上是 libproxychains4.dylib）的动态库。里面重写了 connect、close 以及 sendto 等与 socket 相关的函数，通过这些函数发出的数据将会走代理，详细代码可以参考 libproxychains.c。</p>
<p>在主程序里，它会读取配置文件，查找 libproxychains4 所在位置，把这些信息存入环境变量后执行子程序。这样子程序里对 socket 相关的函数调用就会被 Hook 了，对子程序来说，跟代理相关的东西都是透明的。</p>
<p>linux下代理一般是通过http_proxy和https_proxy这两个环境变量，但是很多软件并不使用这两个变量，导致流量无法走代理。在不使用vpn的前提下，linux并没有转发所有流量的真全局代理。但是可以用proxychains-ng为程序指定走代理，proxychains-ng是proxychains的加强版，主要有以下功能：</p>
<ul>
<li>支持http/https/socks4/socks5</li>
<li>支持认证</li>
<li>远端dns查询</li>
<li>多种代理模式</li>
</ul>
<p>不足：</p>
<p>不支持udp/icmp转发<br>少部分程序和在后台运行的可能无法代理</p>
<h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p>下载源码：</p>
<p><code>git clone https://github.com/rofl0r/proxychains-ng</code></p>
<p>编译和安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr --sysconfdir&#x3D;&#x2F;etc</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line">make install-config</span><br></pre></td></tr></table></figure>

<h4 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h4><p>proxychains-ng的配置非常简单，只需将代理加入[ProxyList]中即可，贴一份配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dynamic_chain</span><br><span class="line">chain_len &#x3D; 1 #round_robin_chain和random_chain使用</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">[ProxyList]</span><br><span class="line">socks5     socks5.52os.net 1080</span><br><span class="line">socks4     socks4.52os.net 1081</span><br><span class="line">http     http.52os.net   3128</span><br></pre></td></tr></table></figure>

<p>proxychains-ng支持多种代理模式：</p>
<ul>
<li>dynamic_chain ：动态模式,按照代理列表顺序自动选取可用代理</li>
<li>strict_chain ：严格模式,严格按照代理列表顺序使用代理，所有代理必须可用</li>
<li>round_robin_chain ：轮询模式，自动跳过不可用代理</li>
<li>random_chain ：随机模式,随机使用代理</li>
</ul>
<h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><p><code>proxychains4 curl ip.cn</code></p>
<h2 id="3-Proxifier"><a href="#3-Proxifier" class="headerlink" title="3. Proxifier"></a>3. Proxifier</h2><p>谁用谁知道 =_=</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://jundongwu.com/p/a6096f68.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="记录思考的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俊东的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/p/a6096f68.html" class="post-title-link" itemprop="url">音符节拍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-12 11:05:16" itemprop="dateCreated datePublished" datetime="2018-07-12T11:05:16+08:00">2018-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 21:06:58" itemprop="dateModified" datetime="2020-09-03T21:06:58+08:00">2020-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开发中遇到一个关于音符节拍的需求，整理下相关知识，扩展下音乐常识。</p>
<h2 id="1，什么叫拍？"><a href="#1，什么叫拍？" class="headerlink" title="1，什么叫拍？"></a>1，什么叫拍？</h2><p>一拍就是音乐中用来定义音的长度的单位，但是根据曲作者的要求，这个基本单位的时长也是可以变化的。比如作者规定一分钟60拍，那么一拍就是1秒。</p>
<h2 id="2，什么是音符？"><a href="#2，什么是音符？" class="headerlink" title="2，什么是音符？"></a>2，什么是音符？</h2><p>音符就是用来表示这个音的长度的符号。同一个音，怎么在谱子上表达它需要发声多长时间呢？人们就规定了一套规则来说明这个长度。这就是音符。至于四分音符，八分音符，十六分音符这些都只是个名字，你可以不用去理解。只需要明白这些翻倍的数字表示他们所代表的时长减半。</p>
<h2 id="3，-什么叫四分音符为一拍？"><a href="#3，-什么叫四分音符为一拍？" class="headerlink" title="3， 什么叫四分音符为一拍？"></a>3， 什么叫四分音符为一拍？</h2><p>那么结合什么是拍子和什么是音符，我们现在可以解释什么叫四分音符为一拍了。也就是字面意思了。在谱子上写作四分音符的这个符号，在这首曲子中演奏一拍的时长。如果一拍是一秒就演奏一秒，一拍是半秒就演奏半秒。再结合四分音符，八分音符，十六分音符依次减半的规定。那么就有了，当四分音符为一拍时，八分音符为半拍。十六分音符为四分之一拍。再乘以一拍对应的时间。就是这些音符所需要被演奏的时长，（在我之前假设的前提下）也就是1秒，半秒，四分之一秒。同理，二分音符和全音就是2秒和4秒。</p>
<h2 id="4，什么叫小节？"><a href="#4，什么叫小节？" class="headerlink" title="4，什么叫小节？"></a>4，什么叫小节？</h2><p>关于小节的概念你可以这么理解，它就像是你写一个曲子最基本的节奏循环单位。比如圆舞曲，很多都是三拍子的，所以跳起舞来可以有一哒哒，二哒哒，三哒哒，这样的感觉。这就是节奏的意思了。所以一个小节，就是规定我这个曲子是按怎么样的节奏在演奏着，是哒哒哒，哒哒哒，还是哒哒哒哒，哒哒哒哒。</p>
<h2 id="5，4-4-3-4-6-8-这样的符号是什么意思？"><a href="#5，4-4-3-4-6-8-这样的符号是什么意思？" class="headerlink" title="5，4/4, 3/4, 6/8 这样的符号是什么意思？"></a>5，4/4, 3/4, 6/8 这样的符号是什么意思？</h2><p>先强调一次，3/4这种写法和分数一点关系都没有，在这里并不意味着0.75。大家也不用尝试着把它和几分之几秒或者拍拿去比较，这样比较容易把自己搞糊涂。</p>
<p>之前我们已经懂了什么叫四分音符为一拍，什么叫小节。下面我们就把这两个概念合在一起，4/4这个符号的意思是四分音符为一拍，每小节有四拍。分母的4表明是几分音符为一拍，分子的4表明一小节有几拍。因此同理类推，3/4这个符号表示四分音符为一拍，每小节三拍，6/8这个符号表示8分音符为一拍，每小节6拍。</p>
<h2 id="6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？"><a href="#6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？" class="headerlink" title="6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？"></a>6，为什么是四分音符为一拍，而不是八分音符或者十六分音符呢？</h2><p>这是作曲家自己规定的，不同的曲谱都可以不一样，比如我上面举到过的6/8拍中，就是八分音符为一拍，而不是四分音符。</p>
<h2 id="7，为什么在简谱中是四分音符对应一个阿拉伯数字？"><a href="#7，为什么在简谱中是四分音符对应一个阿拉伯数字？" class="headerlink" title="7，为什么在简谱中是四分音符对应一个阿拉伯数字？"></a>7，为什么在简谱中是四分音符对应一个阿拉伯数字？</h2><p>首先说明，这只是简谱几法自己规定的而已，以四分音符为一拍，所以四分音符才是正好是一个数字，其他的就在它的基础上在后面加横线表示时长加倍，加下划线表示时长减半。</p>
<p>以一分钟60拍，3/4拍为例，把它们全部串起来铺开来说一次就是：该曲谱规定，一拍的长度为一秒，且以四分音符为一拍，每一个小节有三拍，也就是三个四分音符的演奏长度，也就是三秒。在该前提下，八分音符为半拍，十六分音符为四分之一拍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description">记录思考的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">167</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
